---
title: 
tags:
  - java
  - spring
  - security
publish: false
date: 2024-12-18
---
## 스프링 시큐리티
몇 일전, 스프링 시큐리티에 대해 궁금증이 생겨서 잠깐 공부해보았었다. 이번에는 프로젝트에 활용해보기 위해서 사용 방법을 구체적으로 알아본다. 스프링 시큐리티는 `SecurityFilterChain`을 스프링 빈으로 등록하고, 프록시 기술을 이용해서 서블릿 필터 체인 내부에서 `SecurityFilterChain`을 동작한다.

## 스프링 시큐리티 컨픽
스프링 시큐리티는 스프링 구성 정보 클래스 어노테이션인 `@Configuration`과 어플리케이션 전반에 스프링 시큐리티를 적용하기 위한 어노테이션인 `@EnableWebSecurity`를 함께 사용한 구성 정보 클래스가 필요하다.

```java
@Configuration  
@EnableWebSecurity  
public class SecurityConfig {
	...
}
```

## 스프링 시큐리티 필터체인
이제 `SecurityFilterChain`을 스프링 빈으로 등록하기 위해 다음과 같이 코드를 작성한다.

```java
@Bean  
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {  
    http  
            .authorizeHttpRequests((authorize) -> authorize  
                    .requestMatchers("/", "/login", "/register").permitAll()  
					.requestMatchers("/admin").hasRole("ADMIN")  
					.anyRequest().authenticated()
            )  
            .httpBasic(Customizer.withDefaults())  
            .formLogin(Customizer.withDefaults());
  
    return http.build();  
}
```

- `HttpSecurity`를 통해서 `SecurityFilterChain`을 빌더 패턴으로 간단히 작성할 수 있다.
- `requestMatchers()`는 요청 `URI`를 매핑시킨다.
- `permitAll()`은 해당 요청 `URI`에 모든 요청을 허용한다.
- `hasRole()`은 해당 요청 `URI`에 특정 역할이 부여된 사용자만 허용한다.
- `anyRequest().authenticated()`는 그 외에 모든 요청에 인증이 필요하도록 한다.

중요한 것은 이 `authorize` 요청 `URI`의 순서인데, 만약 `anyRequest().permitAll()`이 최상단에 있다면 하위에 있는 규칙들은 작동하지 않는다.

## 커스텀 로그인 설정
위 처럼 `SecurityConfig`을 설정 후 특정 경로에 대한 접근 권한이 없는 경우, 자동으로 스프링 시큐리티가 제공하는 로그인 페이지로 리다이렉트 된다. 이는 `http.formLogin()` 메서드로 설정 가능하다.





---
References: 

Links to this page: 