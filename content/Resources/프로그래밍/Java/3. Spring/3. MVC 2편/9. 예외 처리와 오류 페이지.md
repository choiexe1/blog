---
title: 
tags:
  - java
  - programming
  - spring
  - mvc
  - exception
publish: true
date: 2024-12-01
---
## 서블릿 예외 처리
먼저 예외 처리에 대해서 알아보려면 스프링이 아닌 순수 서블릿 컨테이너가 예외를 어떻게 처리하는지 알아야 한다.

서블릿은 다음 2가지 방식으로 예외 처리를 지원한다.
- Exception(예외)
- response.sendError(HTTP 상태 코드, 오류 메시지)

어플리케이션 내부에서 예외가 발생하는 경우에, 서블릿까지 전파가 되면 다음의 흐름일 것이다.

```
WAS(여기까지 전파) <- 필터 <- 서블릿 <- 인터셉터 <- 컨트롤러 (예외 발생)
```


### Exception
**그렇다면 `WAS`가 `Exception`을 전달 받은 경우와 그렇지 않은 경우 어떻게 처리될까?**

Exception은 다음과 같이 처리된다.
- `Exception`을 전달 받은 경우
	- 내부적으로 처리할 수 없는 오류가 발생한 것으로 판단하고 서블릿 기본 오류 페이지와 함께 `HTTP 500` 상태코드를 반환한다.
- 그렇지 않은 경우
	- 서블릿 기본 오류 페이지와 함께 `HTTP 404` 상태코드를 반환한다.

### response.sendError(Http 상태 코드, 오류 메시지)

`HttpServletResponse` 객체가 제공하는 메서드이다. 이 메서드를 사용하면 당장 예외가 발생하는 것은 아니지만 서블릿 컨테이너에 예외가 발생했음을 알릴 수 있다.

또, 이 메서드는 상태 코드와 오류 메세지를 전달할 수 있다.

```
WAS <- 필터 <- 서블릿 <- 인터셉터 <- 컨트롤러(sendError() 호출)
```

`WAS`는 컨트롤러가 `sendError()`를 호출 했는지 확인하고, 호출 시의 상태 코드에 맞추어 기본 오류 페이지를 보여준다.

## 서블릿이 제공하는 오류 페이지 기능
서블릿 컨테이너가 기본으로 제공하는 오류 페이지는 사용자 친화적이지 않다. 따라서 서블릿이 제공하는 오류 페이지 기능을 통해서 두 가지 예외 처리 케이스를 좀 더 사용자 친화적으로 커스텀 할 수 있다.

지금은 스프링 부트를 통해서 서블릿 컨테이너를 실행하므로, 스프링 부트의 기능을 사용해서 서블릿 오류 페이지를 등록하면 된다.

### 에러 페이지 등록
에러 페이지 등록을 위해서는 다음과 같은 등록 절차가 필요하다.

1. `WebServerFactoryCustomizer<ConfigurableWebServerFactory>`를 구현하는 스프링 빈 등록
2. `WebServerFactoryCustomizer`의 메서드 `customize`를 통해 `ConfigurableWebServerFactory`에 `ErrorPage` 객체 등록
3. 오류 페이지 뷰를 반환하는 컨트롤러 구현

코드로 살펴보면 다음과 같다.

```java title="WebServerCostomizer.java"
@Component  
public class WebServerCustomizer implements WebServerFactoryCustomizer<ConfigurableWebServerFactory> {  
    @Override  
    public void customize(ConfigurableWebServerFactory factory) {  
        ErrorPage errorPage404 = new ErrorPage(HttpStatus.NOT_FOUND, "/error-page/404");  
        ErrorPage errorPage500 = new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, "/error-page/500");  
        ErrorPage errorPageEx = new ErrorPage(RuntimeException.class, "/error-page/500");  
  
        factory.addErrorPages(errorPage404, errorPage500, errorPageEx);  
    }  
}
```
- 이 클래스는 `WebServerFactoryCustomizer`를 구현 한 스프링 빈이다.
- `new ErrorPage(HTTP 상태 코드, 컨트롤러 경로)`로 객체를 생성한다. 여기서 `HTTP 상태 코드`는 이 에러 페이지가 어떤 상태 코드를 가지는 에러를 처리하는지를 의미하고 `컨트롤러 경로`는 해당 에러 코드의 경우에 요청할 컨트롤러 경로를 의미한다.
- 마지막으로 메서드 파라미터인 `ConfigurableWebServerFactory factory`에 `addErrorPages()`메서드를 통해 에러 페이지를 등록한다.

```java
@Slf4j  
@Controller  
public class ErrorPageController {    
    @RequestMapping("/error-page/404")  
    public String errorPage404() {  
        log.info("errorPage404");
        return "error-page/404";  
    }  
  
    @RequestMapping("/error-page/500")  
    public String errorPage500() {  
        log.info("errorPage500");  
        return "error-page/500";  
    }  
}
```
- 이 컨트롤러는 앞서 `ErrorPage`에 명시한 요청 경로를 처리하는 컨트롤러이다.

### 서블릿 컨테이너의 에러 처리 흐름

**예외 발생 흐름**

```
WAS(여기까지 전파) <- 필터 <- 서블릿 <- 인터셉터 <- 컨트롤러(예외발생)
```

**sendError() 흐름**

```
WAS(sendError 호출 기록 확인) <- 필터 <- 서블릿 <- 인터셉터 <- 컨트롤러(response.sendError())
```

예를 들어서 `RuntimeException`이 `WAS`까지 전달되면 `WAS`는 오류 페이지 정보를 확인한다.
`RuntimeException`의 오류 페이지로 `/error-page/500` 경로가 지정되어 있다. `WAS`는 이 오류 페이지를 출력하기 위해 `/error-page/500`을 다시 호출한다.

```
new ErrorPage(RuntimeException.class, "/error-page/500")
```

중요한 점은 웹 브라우저(클라이언트)는 서버 내부에서 이런 일이 일어나는지 전혀 모른다는 점이다. 오직 서버 내부에서 오류 페이지를 찾기 위해 추가적인 호출을 한다.


```
1. WAS <- 필터 <- 서블릿 <- 인터셉터 <- 컨트롤러
2. WAS "/error-page/500" 경로로 다시 요청 -> 필터 -> 서블릿 -> 인터셉터 -> 컨트롤러("error-page/500") -> 뷰 렌더링
```


말 그대로, 서버 내부적으로 해당 컨트롤러를 다시 호출하는데에서 문제가 발생한다. 서버 관점에서 바라보면 이미 클라이언트의 요청을 필터나 인터셉터에서 검증을 마쳤다. 그런데 비즈니스 로직에서 에러가 발생해서 `WAS`가 다시 컨트롤러를 호출하다보니 필터나 인터셉터에서 여러 번 호출이 발생한다.

이는 매우 비효율적이다.

## 예외 처리 - 필터
`WAS`가 에러 페이지를 보여주기 위해 내부적으로 컨트롤러를 다시 호출하여 비효율적으로 동작하는 문제를 해결하기 위해 서블릿은 `DispatcherType`이라는 추가 정보를 제공한다.


## 오류 정보 추가
`WAS`는 오류 페이지를 단순히 다시 요청만 하는게 아니라 오류 정보를 `request.attribute`에 담아서 전달한다. 필요하면 오류 페이지에서 전달 받은 이 오류 정보들을 사용할 수 있다.

오류 정보에 대한 이름은 `RequestDispatcher`에 상수로 정의되어 있다.






---
References: 김영한의 스프링 MVC 2편

Links to this page: 