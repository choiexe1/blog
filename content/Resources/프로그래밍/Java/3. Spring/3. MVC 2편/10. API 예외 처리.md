---
title: 
tags:
  - java
  - programming
  - api
  - exception
  - spring
  - mvc
publish: true
date: 2024-12-04
---
## API 예외 처리
HTML 페이지를 직접 렌더링 하는 MVC 구조의 웹 어플리케이션의 경우 `4xx`, `5xx`와 같은 오류 페이지만 존재하면 대부분의 문제를 해결할 수 있다.

그런데 API의 경우에는 생각할 내용이 더 많다. 오류 페이지는 단순히 고객에게 오류 화면을 보여주고 끝이지만 API는 각 오류 상황에 맞는 오류 응답 스펙을 정하고, JSON으로 데이터를 내려주어야 한다.

먼저 다음과 같은 간단한 Restful API 컨트롤러를 구현한다.

```java
@RestController  
@RequestMapping("/api")  
public class ApiExceptionController {  
    @GetMapping("/members/{id}")  
    public MemberDto getMember(@PathVariable("id") String id) {  
        if (id.equals("ex")) {  
            throw new RuntimeException("잘못된 사용자");  
        }  
  
        return new MemberDto(id, "hello" + id);  
    }  
  
    @Data  
    @AllArgsConstructor    static class MemberDto {  
        private String memberId;  
        private String name;  
    }  
}
```

그리고 앞서 만들었던 서블릿의 `WebServerCustomizer` 구현체를 이용해본다.

```java
@Component  
public class WebServerCustomizer implements WebServerFactoryCustomizer<ConfigurableWebServerFactory> {  
    @Override  
    public void customize(ConfigurableWebServerFactory factory) {  
        ErrorPage errorPage404 = new ErrorPage(HttpStatus.NOT_FOUND, "/error-page/404");  
        ErrorPage errorPage500 = new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, "/error-page/500");  
        ErrorPage errorPageEx = new ErrorPage(RuntimeException.class, "/error-page/500");  
  
        factory.addErrorPages(errorPage404, errorPage500, errorPageEx);  
    }  
}
```

이제 `ApiExceptionController`의 `getMember`에서 오류가 발생하면 런타임 예외가 발생하고, 이 예외는 여러 단계를 거쳐 서블릿에 전달된다.

앞서 학습한 대로 서블릿에 예외가 전달되면, 각 예외에 따라 지정된 경로의 컨트롤러를 다시 호출한다. 그리고 `WebServerCustomizer`에 런타임 예외가 전달되면 호출하는 컨트롤러는 `/error-page/500`이다. 이 경로는 `JSON` 형태의 응답이 아니라 뷰를 반환한다.

`Restful API`를 호출한 클라이언트는 정상 요청이든, 오류 요청이든 `JSON`이 반환되기를 기대할 것이다. 웹 브라우저가 아닌 이상 HTML을 응답 받아서 할 수 있는 것은 별로 없다.

문제를 해결하려면 다음과 같이 오류 페이지 컨트롤러도 `JSON` 형태의 응답을 할 수 있도록 수정해야 한다.

`JSON` 형태의 응답을 반환하는 `/error-page/500` 컨트롤러를 다음과 같이 구현한다.

```java
@RequestMapping(value = "/error-page/500", produces = MediaType.APPLICATION_JSON_VALUE)  
public ResponseEntity<Map<String, Object>> errorPage500Api(HttpServletRequest request,  
                                                           HttpServletResponse response) {  
    log.info("API errorPage 500");  
  
    Map<String, Object> result = new HashMap<>();  
    Exception ex = (Exception) request.getAttribute(ERROR_EXCEPTION);  
    result.put("status", request.getAttribute(ERROR_STATUS_CODE));  
    result.put("message", ex.getMessage());  
    Integer statusCode = (Integer) request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE);  
  
    return new ResponseEntity<>(result, HttpStatus.valueOf(statusCode));  
}
```

이 컨트롤러는 `@RequestMapping`의 `produces` 속성을 사용한다. HTTP 요청 헤더의 `Accept` 속성을 가지고 해당 컨트롤러로 매핑해주는 속성이다.

이에 대한 내용은 앞서 [[7. 스프링 MVC - 기본 기능#특정 헤더로 조건부 매핑]]에서 학습했다.

### 흐름
다시 `/api/members/{id}` 컨트롤러로 잘못된 요청을 보내보면, `WebServerCustomizer`에서 지정된 경로인 `/error-page/500`으로 전달된다. 여기서 요청자의 HTTP 요청 헤더 `Accept` 속성을 가지고, 동일한 경로의 두 컨트롤러 중 하나를 고른다. 이 요청에서는 `Accept`가 `application/json`이므로 위에 작성한 API 응답 컨트롤러가 요청을 처리한다.

따라서 HTTP 요청 헤더의 `Accept`가 `application/json`이 아니면 기존 오류 응답인 HTML 응답이 출력된다.

## API 예외 처리 - 스프링 부트 기본 오류 처리
API 예외 처리도 스프링 부트가 제공하는 기본 오류 방식을 사용할 수 있다. `WebServerCustomizer`를 사용하지 않으면(스프링 빈이 아니면) 스프링이 제공하는 `BasicErrorController` 사용이 기본 값이다.

`BasicErrorController`는 추상 클래스인 `AbstractErrorController`를 상속 받는다. 추상 클래스는 인터페이스와 다르게 구현과 멤버 변수를 제공할 수 있다. (인터페이스는 구현 제공 불가능, 멤버 변수가 아닌 클래스 변수 제공 가능)

다음의 코드는 `BasicErrorController`의 코드다.

```java title="BasicErrorController.java"
@Controller  
@RequestMapping({"${server.error.path:${error.path:/error}}"})  
public class BasicErrorController extends AbstractErrorController {
	
	@RequestMapping(produces = {"text/html"})  
	public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) {  
	    HttpStatus status = this.getStatus(request);  
	    Map<String, Object> model = Collections.unmodifiableMap(this.getErrorAttributes(request, this.getErrorAttributeOptions(request, MediaType.TEXT_HTML)));  
	    response.setStatus(status.value());  
	    ModelAndView modelAndView = this.resolveErrorView(request, response, status, model);  
	    return modelAndView != null ? modelAndView : new ModelAndView("error", model);  
	}

	@RequestMapping
	public ResponseEntity<Map<String, Object>> error(HttpServletRequest request) {  
	    HttpStatus status = this.getStatus(request);  
	    if (status == HttpStatus.NO_CONTENT) {  
	        return new ResponseEntity(status);  
	    } else {  
	        Map<String, Object> body = this.getErrorAttributes(request, this.getErrorAttributeOptions(request, MediaType.ALL));  
	        return new ResponseEntity(body, status);  
	    }  
	}
}
```

기본적으로 `Accept`를 참조하여 `text/html` 요청을 처리하는 컨트롤러와 `application/json` 요청을 처리하는 부분이 나뉘어져 있다. 

앞서 정의 했던 `/error-page/500` 컨트롤러와 거의 비슷한 구조를 가진다.

### HTML 페이지 vs API 오류
`BasicErrorController`를 확장하면 `JSON` 메세지도 변경할 수 있다. 그런데 API 오류는 조금 뒤에 설명할 `ExceptionHandler`가 제공하는 기능을 사용하는 것이 더 나은 방법이다. 그러므로 지금은 `BasicErrorController`를 확장하면 메세지를 변경할 수 있다는 것만 알아두자.

스프링 부트가 제공하는 `BasicErrorController`는 HTML 페이지를 제공하는 경우에는 매우 편리하다. `4xx`, `5xx`등 모두 잘 처리해준다.

그런데 API 오류  처리는 다른 차원의 이야기다. API 마다, 각각의 컨트롤러나 예외마다 서로 다른 응답 결과를 출력해야 할 수도 있다. 예를 들어서 회원과 관련된 API에서 예외가 발생할 때 응답과, 상품과 관련된 API에서 관련된 API에서 발생하는 예외에 따라 그 결과가 달라질 수 있다.

결과적으로 매우 세밀하고 복잡하다. 따라서 이 방법은 HTML 화면을 처리할 때 사용하고, **API 오류 처리는 뒤에서 설명할 `@ExceptionHandler`를 사용하자.**



---
References: 김영한의 스프링 MVC 2편

Links to this page: 