---
title: 
tags:
  - java
  - programming
  - api
  - exception
  - spring
  - mvc
publish: true
date: 2024-12-04
---
## API 예외 처리
HTML 페이지를 직접 렌더링 하는 MVC 구조의 웹 어플리케이션의 경우 `4xx`, `5xx`와 같은 오류 페이지만 존재하면 대부분의 문제를 해결할 수 있다.

그런데 API의 경우에는 생각할 내용이 더 많다. 오류 페이지는 단순히 고객에게 오류 화면을 보여주고 끝이지만 API는 각 오류 상황에 맞는 오류 응답 스펙을 정하고, JSON으로 데이터를 내려주어야 한다.

먼저 다음과 같은 간단한 Restful API 컨트롤러를 구현한다.

```java
@RestController  
@RequestMapping("/api")  
public class ApiExceptionController {  
    @GetMapping("/members/{id}")  
    public MemberDto getMember(@PathVariable("id") String id) {  
        if (id.equals("ex")) {  
            throw new RuntimeException("잘못된 사용자");  
        }  
  
        return new MemberDto(id, "hello" + id);  
    }  
  
    @Data  
    @AllArgsConstructor    static class MemberDto {  
        private String memberId;  
        private String name;  
    }  
}
```

그리고 앞서 만들었던 서블릿의 `WebServerCustomizer` 구현체를 이용해본다.

```java
@Component  
public class WebServerCustomizer implements WebServerFactoryCustomizer<ConfigurableWebServerFactory> {  
    @Override  
    public void customize(ConfigurableWebServerFactory factory) {  
        ErrorPage errorPage404 = new ErrorPage(HttpStatus.NOT_FOUND, "/error-page/404");  
        ErrorPage errorPage500 = new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, "/error-page/500");  
        ErrorPage errorPageEx = new ErrorPage(RuntimeException.class, "/error-page/500");  
  
        factory.addErrorPages(errorPage404, errorPage500, errorPageEx);  
    }  
}
```

이제 `ApiExceptionController`의 `getMember`에서 오류가 발생하면 런타임 예외가 발생하고, 이 예외는 여러 단계를 거쳐 WAS에 전달된다. 여기서 WAS는 서블릿 컨테이너인 톰캣이다.

앞서 학습한 대로 서블릿에 예외가 전달되면, 각 예외에 따라 지정된 경로의 컨트롤러를 다시 호출한다. 그리고 `WebServerCustomizer`에 런타임 예외가 전달되면 호출하는 컨트롤러는 `/error-page/500`이다. 이 경로는 `JSON` 형태의 응답이 아니라 뷰를 반환한다.

`Restful API`를 호출한 클라이언트는 정상 요청이든, 오류 요청이든 `JSON`이 반환되기를 기대할 것이다. 웹 브라우저가 아닌 이상 HTML을 응답 받아서 할 수 있는 것은 별로 없다.

문제를 해결하려면 다음과 같이 오류 페이지 컨트롤러도 `JSON` 형태의 응답을 할 수 있도록 수정해야 한다.

`JSON` 형태의 응답을 반환하는 `/error-page/500` 컨트롤러를 다음과 같이 구현한다.

```java
@RequestMapping(value = "/error-page/500", produces = MediaType.APPLICATION_JSON_VALUE)  
public ResponseEntity<Map<String, Object>> errorPage500Api(HttpServletRequest request,  
                                                           HttpServletResponse response) {  
    log.info("API errorPage 500");  
  
    Map<String, Object> result = new HashMap<>();  
    Exception ex = (Exception) request.getAttribute(ERROR_EXCEPTION);  
    result.put("status", request.getAttribute(ERROR_STATUS_CODE));  
    result.put("message", ex.getMessage());  
    Integer statusCode = (Integer) request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE);  
  
    return new ResponseEntity<>(result, HttpStatus.valueOf(statusCode));  
}
```

이 컨트롤러는 `@RequestMapping`의 `produces` 속성을 사용한다. HTTP 요청 헤더의 `Accept` 속성을 가지고 해당 컨트롤러로 매핑해주는 속성이다.

이에 대한 내용은 앞서 [[7. 스프링 MVC - 기본 기능#특정 헤더로 조건부 매핑]]에서 학습했다.

### 흐름
다시 `/api/members/{id}` 컨트롤러로 잘못된 요청을 보내보면, `WebServerCustomizer`에서 지정된 경로인 `/error-page/500`으로 전달된다. 여기서 요청자의 HTTP 요청 헤더 `Accept` 속성을 가지고, 동일한 경로의 두 컨트롤러 중 하나를 고른다. 이 요청에서는 `Accept`가 `application/json`이므로 위에 작성한 API 응답 컨트롤러가 요청을 처리한다.

따라서 HTTP 요청 헤더의 `Accept`가 `application/json`이 아니면 기존 오류 응답인 HTML 응답이 출력된다.

## API 예외 처리 - 스프링 부트 기본 오류 처리
API 예외 처리도 스프링 부트가 제공하는 기본 오류 방식을 사용할 수 있다. `WebServerCustomizer`를 사용하지 않으면(스프링 빈이 아니면) 스프링이 제공하는 `BasicErrorController` 사용이 기본 값이다.

`BasicErrorController`는 추상 클래스인 `AbstractErrorController`를 상속 받는다. 추상 클래스는 인터페이스와 다르게 구현과 멤버 변수를 제공할 수 있다. (인터페이스는 구현 제공 불가능, 멤버 변수가 아닌 클래스 변수 제공 가능)

다음의 코드는 `BasicErrorController`의 코드다.

```java title="BasicErrorController.java"
@Controller  
@RequestMapping({"${server.error.path:${error.path:/error}}"})  
public class BasicErrorController extends AbstractErrorController {
	
	@RequestMapping(produces = {"text/html"})  
	public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) {  
	    HttpStatus status = this.getStatus(request);  
	    Map<String, Object> model = Collections.unmodifiableMap(this.getErrorAttributes(request, this.getErrorAttributeOptions(request, MediaType.TEXT_HTML)));  
	    response.setStatus(status.value());  
	    ModelAndView modelAndView = this.resolveErrorView(request, response, status, model);  
	    return modelAndView != null ? modelAndView : new ModelAndView("error", model);  
	}

	@RequestMapping
	public ResponseEntity<Map<String, Object>> error(HttpServletRequest request) {  
	    HttpStatus status = this.getStatus(request);  
	    if (status == HttpStatus.NO_CONTENT) {  
	        return new ResponseEntity(status);  
	    } else {  
	        Map<String, Object> body = this.getErrorAttributes(request, this.getErrorAttributeOptions(request, MediaType.ALL));  
	        return new ResponseEntity(body, status);  
	    }  
	}
}
```

기본적으로 `Accept`를 참조하여 `text/html` 요청을 처리하는 컨트롤러와 `application/json` 요청을 처리하는 부분이 나뉘어져 있다. 

앞서 정의 했던 `/error-page/500` 컨트롤러와 거의 비슷한 구조를 가진다.

### HTML 페이지 vs API 오류
`BasicErrorController`를 확장하면 `JSON` 메세지도 변경할 수 있다. 그런데 API 오류는 조금 뒤에 설명할 `ExceptionHandler`가 제공하는 기능을 사용하는 것이 더 나은 방법이다. 그러므로 지금은 `BasicErrorController`를 확장하면 메세지를 변경할 수 있다는 것만 알아두자.

스프링 부트가 제공하는 `BasicErrorController`는 HTML 페이지를 제공하는 경우에는 매우 편리하다. `4xx`, `5xx`등 모두 잘 처리해준다.

그런데 API 오류  처리는 다른 차원의 이야기다. API 마다, 각각의 컨트롤러나 예외마다 서로 다른 응답 결과를 출력해야 할 수도 있다. 예를 들어서 회원과 관련된 API에서 예외가 발생할 때 응답과, 상품과 관련된 API에서 관련된 API에서 발생하는 예외에 따라 그 결과가 달라질 수 있다.

결과적으로 매우 세밀하고 복잡하다. 따라서 이 방법은 HTML 화면을 처리할 때 사용하고, **API 오류 처리는 뒤에서 설명할 `@ExceptionHandler`를 사용하자.**

## HandlerExceptionResolver

**목표**

예외가 발생해서 서블릿을 넘어 WAS까지 전달되면, HTTP 상태 코드가 500으로 처리된다. 발생하는 예외에 따라서 400, 404 등 다른 상태코드도 처리하고 싶다.

쉽게 말해 오류 메시지, 형식등을 API마다 다르게 처리하고 싶다.

### 상태코드 변환
예를 들어서 `IllegalArgumentException`을 처리하지 못해서 컨트롤러 밖으로 넘어가는 일이 발생하면 상태코드를 400으로 처리하고 싶다. 어떻게 해야할까?

```java
@GetMapping("/members/{id}")  
public MemberDto getMember(@PathVariable("id") String id) {  
    if (id.equals("ex")) {  
        throw new RuntimeException("잘못된 사용자");  
    }  
  
    if (id.equals("bad")) {  
        throw new IllegalArgumentException("잘못된 사용자");  
    }  
  
    return new MemberDto(id, "hello" + id);  
}
```

해당 컨트롤러에 경로 변수가 "bad"면 `IllegalArgumentException` 예외가 발생하도록 했다. 이제 해당 예외가 발생하도록 요청을 보내면 서블릿 컨테이너인 톰캣에 전달되고, 내부적으로 `BasicErrorController`를 통해서 아래와 같은 구조의 `JSON` 응답을 클라이언트에 반환한다.

```json
{
	"timestamp": "2024-12-04T06:29:45.076+00:00",
	"status": 500,
	"error": "Internal Server Error",
	"exception": "java.lang.IllegalArgumentException",
	"path": "/api/members/bad"
}
```

앞서 배운 내용을 상기해보면 서블릿 컨테이너 입장에서 자기 자신에게까지 예외가 전달되면 **내부적으로 처리할 수 없는 오류가 발생한 것으로 판단**한다. 따라서 `500` 상태코드를 반환한다.

스프링 MVC는 컨트롤러(핸들러) 밖으로 예외가 던져진 경우 예외를 해결하고 동작을 새로 정의할 수 있는 방법을 제공한다. 컨트롤러 밖으로 던져진 예외를 해결하고, 동작 방식을 변경하고 싶으면 `HandlerExceptionResolver`를 사용하면 된다. 줄여서 `ExceptionResolver`라고 한다.

#### ExceptionResolver 적용 전

![[exception-resolver-1.png]]

1. 클라이언트가 요청을 보낸다.
2. WAS는 `DispatcherServlet`을 호출하고 프론트 컨트롤러 패턴을 구현한`DispatcherServlet`는 내부적으로 핸들러 요청 경로에 맞는 핸들러를 찾는다. 
3. 인터셉터의 `preHandle`을 호출한다. `preHandle`의 반환 값이 `true`면 다음을 호출한다.
4. `preHandle` 호출이 끝나면 핸들러 어댑터를 이용해 핸들러를 호출한다.
5. 만약 `handle(handler)` 호출에서 예외 발생 시 `postHandle`은 호출되지 않는다. 
6. 핸들러의 예외와 관계 없이 `afterCompletion`은 반드시 호출된다. 이후에 `WAS`에 예외가 전달된다.

스프링 인터셉터의 동작 흐름은 [[8. 로그인 처리 2 - 필터와 인터셉터#스프링 인터셉터]]에서 다시 확인할 수 있다.
#### ExceptionResolver 적용 후
![[exception-resolver-2.png]]
`ExceptionResolver`를 적용하게 되면 앞서 설명한 과정 중에 예외 해결을 시도한다. 만약 핸들러에서 발생한 예외를 `ExceptionResolver`가 해결하면%% 주석처리 %% 정상 응답을 반환할 수 있다. 핸들러에서 발생한 예외를 해결해주는 해결사인 셈이다.

_학습과는 별개로, 스프링의 코드가 얼마나 아름답게 작성되어 있으면 이런 기능의 작동이 가능한건지 알면 알수록 놀랍다._

> [!tip] postHandle() 호출
> `ExceptionResolver`로 예외를 해결해도, `postHandle()`은 호출되지 않는다.

먼저 `HandlerExceptionResolver`는 어떻게 이루어져있는지 살펴본다.

```java
public class MyHandlerExceptionResolver implements HandlerExceptionResolver {  
    @Override  
    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler,  
                                         Exception ex) {  
          
    }  
}
```

---
References: 김영한의 스프링 MVC 2편

Links to this page: 