---
title: 
tags:
  - java
  - programming
  - api
  - exception
  - spring
  - mvc
publish: true
date: 2024-12-03
---
## API 예외 처리
HTML 페이지를 직접 렌더링 하는 MVC 구조의 웹 어플리케이션의 경우 `4xx`, `5xx`와 같은 오류 페이지만 존재하면 대부분의 문제를 해결할 수 있다.

그런데 API의 경우에는 생각할 내용이 더 많다. 오류 페이지는 단순히 고객에게 오류 화면을 보여주고 끝이지만 API는 각 오류 상황에 맞는 오류 응답 스펙을 정하고, JSON으로 데이터를 내려주어야 한다.

먼저 다음과 같은 간단한 Restful API 컨트롤러를 구현한다.

```java
@RestController  
@RequestMapping("/api")  
public class ApiExceptionController {  
    @GetMapping("/members/{id}")  
    public MemberDto getMember(@PathVariable("id") String id) {  
        if (id.equals("ex")) {  
            throw new RuntimeException("잘못된 사용자");  
        }  
  
        return new MemberDto(id, "hello" + id);  
    }  
  
    @Data  
    @AllArgsConstructor    static class MemberDto {  
        private String memberId;  
        private String name;  
    }  
}
```

그리고 앞서 만들었던 서블릿의 `WebServerCustomizer` 구현체를 이용해본다.

```java
@Component  
public class WebServerCustomizer implements WebServerFactoryCustomizer<ConfigurableWebServerFactory> {  
    @Override  
    public void customize(ConfigurableWebServerFactory factory) {  
        ErrorPage errorPage404 = new ErrorPage(HttpStatus.NOT_FOUND, "/error-page/404");  
        ErrorPage errorPage500 = new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, "/error-page/500");  
        ErrorPage errorPageEx = new ErrorPage(RuntimeException.class, "/error-page/500");  
  
        factory.addErrorPages(errorPage404, errorPage500, errorPageEx);  
    }  
}
```

이제 `ApiExceptionController`의 `getMember`에서 오류가 발생하면 런타임 예외가 발생하고, 이 예외는 여러 단계를 거쳐 서블릿에 전달된다.

앞서 학습한 대로 서블릿에 예외가 전달되면, 각 예외에 따라 지정된 경로의 컨트롤러를 다시 호출한다. 그리고 `WebServerCustomizer`에 런타임 예외가 전달되면 호출하는 컨트롤러는 `/error-page/500`이다. 이 경로는 `JSON` 형태의 응답이 아니라 뷰를 반환한다.

`Restful API`를 호출한 클라이언트는 정상 요청이든, 오류 요청이든 `JSON`이 반환되기를 기대할 것이다. 웹 브라우저가 아닌 이상 HTML을 응답 받아서 할 수 있는 것은 별로 없다.

문제를 해결하려면 다음과 같이 오류 페이지 컨트롤러도 `JSON` 형태의 응답을 할 수 있도록 수정해야 한다.

`JSON` 형태의 응답을 반환하는 `/error-page/500` 컨트롤러를 다음과 같이 구현한다.

```java
@RequestMapping(value = "/error-page/500", produces = MediaType.APPLICATION_JSON_VALUE)  
public ResponseEntity<Map<String, Object>> errorPage500Api(HttpServletRequest request,  
                                                           HttpServletResponse response) {  
    log.info("API errorPage 500");  
  
    Map<String, Object> result = new HashMap<>();  
    Exception ex = (Exception) request.getAttribute(ERROR_EXCEPTION);  
    result.put("status", request.getAttribute(ERROR_STATUS_CODE));  
    result.put("message", ex.getMessage());  
    Integer statusCode = (Integer) request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE);  
  
    return new ResponseEntity<>(result, HttpStatus.valueOf(statusCode));  
}
```

이 컨트롤러는 `@RequestMapping`의 `produces` 속성을 사용한다. HTTP 요청 헤더의 `Accept` 속성을 가지고 해당 컨트롤러로 매핑해주는 속성이다.

이에 대한 내용은 앞서 [[7. 스프링 MVC - 기본 기능#특정 헤더로 조건부 매핑]]에서 학습했다.

### 흐름
다시 `/api/members/{id}` 컨트롤러로 잘못된 요청을 보내보면, `WebServerCustomizer`에서 지정된 경로인 `/error-page/500`으로 전달된다. 여기서 요청자의 HTTP 요청 헤더 `Accept` 속성을 가지고, 동일한 경로의 두 컨트롤러 중 하나를 고른다. 이 요청에서는 `Accept`가 `application/json`이므로 위에 작성한 API 응답 컨트롤러가 요청을 처리한다.

따라서 HTTP 요청 헤더의 `Accept`가 `application/json`이 아니면 기존 오류 응답인 HTML 응


---
References: 김영한의 스프링 MVC 2편

Links to this page: 