---
title: 
tags:
  - java
  - programming
  - spring
  - mvc
  - validation
publish: true
date: 2024-11-28
---
## Bean Validation - 소개
검증 기능을 지금처럼 매번 코드로 작성하는 것은 상당히 번거롭다. 특히 특정 필드에 대한 검증 로직은 대부분 빈 값인지, 특정 크기를 넘는지와 같이 매우 일반적인 로직이다.

`Node.js` 계열에선 `ClassValidator`를 통해 데코레이터로 검증했는데, `Bean Validation`은 이 `ClassValidator`와 유사하게 어노테이션으로 검증한다.

다음의 코드를 살펴보자

```java
public class Item {
	private Long id;

	@NotBlank	
	private String itemName;
	
	@NotNull
	@Range(min = 1000, max = 1000000)
	private Integer price;
	
	@NotNull
	@Max(9999)
	private Integer quantity;
}
```

앞서 설명했던 일반적인 검증 로직을 모든 프로젝트에 적용할 수 있게 공통화하고 표준화 한 것이 바로 `Bean Validation`이다. `Bean Validation`을 잘 활용하면 어노테이션 하나로 검증 로직을 매우 편리하게 적용할 수 있다.


> [!tip] Bean Validation 2.0 (JSR-380)
> 참고로 `Bean Validation`은 특정한 구현체가 아니라 `Bean Validation 2.0(JSR-380)`이라는 기술 표준이다. 쉽게 이야기해서 검증 어노테이션과 여러 인터페이스의 모음이다. 마치 `JPA`가 표준 기술이고 그 구현체로 하이버네이트가 있는 것과 같다.
> 
> `Bean Validation`을 구현한 기술 중에 일반적으로 사용하는 구현체는 하이버네이트 Validator이다. 이름이 하이버네이트가 붙어서 그렇지 ORM과는 관련이 없다.

- [Hibernate Validator 공식 사이트](http://hibernate.org/validator)
- [Hibernate Validator 공식 메뉴얼](https://docs.jboss.org/hibernate/validator/6.2/reference/en-US/html_single/)


## Bean Validation - 시작
Bean Validation 기능을 어떻게 사용하는지 코드로 알아본다. 먼저 스프링과 통합하지 않고 순수한 `Bean Validation` 사용법 부터 테스트 코드로 알아본다.

먼저 `build.gradle`에 다음의 의존관계를 추가해야한다.

```
implementation 'org.springframework.boot:spring-boot-starter-validation'
```

그리고 `Item` 클래스에 다음과 같이 `Bean Validation` 어노테이션을 적용한다.

```java
@Data  
public class Item {  
  
    private Long id;  
  
    @NotBlank  
    private String itemName;  
  
    @NotNull  
    @Range(min = 1_000, max = 1_000_000)  
    private Integer price;  
  
    @Max(999)  
    @NotNull  
    private Integer quantity;  
  
    public Item() {  
    }  
  
    public Item(String itemName, Integer price, Integer quantity) {  
        this.itemName = itemName;  
        this.price = price;  
        this.quantity = quantity;  
    }  
}
```

**검증 어노테이션**
- `@NotBlank`: 빈 값 + 공백은 허용되지 않는다.
- `@NotNull`: `null`을 허용하지 않는다.
- `@Range(min = 1_000, max = 1_000_000)`: 범위 안의 값이어야 한다.
- `@Max(999)`: 최대 999까지만 허용한다.

```java
public class BeanValidationTest {  
  
    @Test  
    void beanValidation() {  
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();  
        Validator validator = factory.getValidator();  
  
        Item item = new Item();  
        item.setItemName(" ");  
        item.setPrice(0);  
        item.setQuantity(10000);  
  
        Set<ConstraintViolation<Item>> violations = validator.validate(item);  
  
        for (ConstraintViolation<Item> violation : violations) {  
            System.out.println("violation = " + violation);  
            System.out.println("violation.getMessage() = " + violation.getMessage());  
        }  
    }  
}
```
위의 코드와 같이 테스트 코드를 작성했다. 실행 결과는 다음과 같다.

```
violation = ConstraintViolationImpl{interpolatedMessage='999 이하여야 합니다', propertyPath=quantity, rootBeanClass=class hello.itemservice.domain.item.Item, messageTemplate='{javax.validation.constraints.Max.message}'}
violation.getMessage() = 999 이하여야 합니다
violation = ConstraintViolationImpl{interpolatedMessage='1000에서 1000000 사이여야 합니다', propertyPath=price, rootBeanClass=class hello.itemservice.domain.item.Item, messageTemplate='{org.hibernate.validator.constraints.Range.message}'}
violation.getMessage() = 1000에서 1000000 사이여야 합니다
violation = ConstraintViolationImpl{interpolatedMessage='공백일 수 없습니다', propertyPath=itemName, rootBeanClass=class hello.itemservice.domain.item.Item, messageTemplate='{javax.validation.constraints.NotBlank.message}'}
violation.getMessage() = 공백일 수 없습니다
```

`ConstraintViolation` 출력 결과를 보면 검증 오류가 발생한 객체, 필드, 메시지 정보등 다양한 정보를 확인할 수 있다.

## Bean Validation - 스프링 통합

`Bean Validation`과 스프링 통합 기능을 이용하기 위해, 다음과 같이 코드를 리팩터링한다.

```java
@Controller  
@RequestMapping("/validation/v3/items")  
@RequiredArgsConstructor  
@Slf4j  
public class ValidationItemControllerV3 {  
  
    private final ItemRepository itemRepository;  
  
    @GetMapping  
    public String items(Model model) {  
        List<Item> items = itemRepository.findAll();  
        model.addAttribute("items", items);  
        return "validation/v3/items";  
    }  
  
    @GetMapping("/{itemId}")  
    public String item(@PathVariable long itemId, Model model) {  
        Item item = itemRepository.findById(itemId);  
        model.addAttribute("item", item);  
        return "validation/v3/item";  
    }  
  
    @GetMapping("/add")  
    public String addForm(Model model) {  
        model.addAttribute("item", new Item());  
        return "validation/v3/addForm";  
    }  
  
    @PostMapping("/add")  
    public String addItem(@Validated @ModelAttribute Item item, BindingResult bindingResult,  
                          RedirectAttributes redirectAttributes) {  
  
        // 검증에 실패하면 다시 입력 폼으로  
        if (bindingResult.hasErrors()) {  
            log.info("errors = {}", bindingResult);  
            return "validation/v3/addForm";  
        }  
  
        Item savedItem = itemRepository.save(item);  
        redirectAttributes.addAttribute("itemId", savedItem.getId());  
        redirectAttributes.addAttribute("status", true);  
        return "redirect:/validation/v3/items/{itemId}";  
    }  
  
    @GetMapping("/{itemId}/edit")  
    public String editForm(@PathVariable Long itemId, Model model) {  
        Item item = itemRepository.findById(itemId);  
        model.addAttribute("item", item);  
        return "validation/v3/editForm";  
    }  
  
    @PostMapping("/{itemId}/edit")  
    public String edit(@PathVariable Long itemId, @ModelAttribute Item item) {  
        itemRepository.update(itemId, item);  
        return "redirect:/validation/v3/items/{itemId}";  
    }  
  
}
```

스프링 MVC가 `Bean Validator`를 잘 사용하고 있는 것을 확인했다. 별도의 ㅅ `Bean Validation`을 어떻게 인지하는 걸까

---
References: 김영한의 스프링 MVC 2편

Links to this page: 