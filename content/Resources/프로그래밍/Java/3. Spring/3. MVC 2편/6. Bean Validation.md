---
title: 
tags:
  - java
  - programming
  - spring
  - mvc
  - validation
publish: true
date: 2024-11-28
---
## Bean Validation - 소개
검증 기능을 지금처럼 매번 코드로 작성하는 것은 상당히 번거롭다. 특히 특정 필드에 대한 검증 로직은 대부분 빈 값인지, 특정 크기를 넘는지와 같이 매우 일반적인 로직이다.

`Node.js` 계열에선 `ClassValidator`를 통해 데코레이터로 검증했는데, `Bean Validation`은 이 `ClassValidator`와 유사하게 어노테이션으로 검증한다.

다음의 코드를 살펴보자

```java
public class Item {
	private Long id;

	@NotBlank	
	private String itemName;
	
	@NotNull
	@Range(min = 1000, max = 1000000)
	private Integer price;
	
	@NotNull
	@Max(9999)
	private Integer quantity;
}
```

앞서 설명했던 일반적인 검증 로직을 모든 프로젝트에 적용할 수 있게 공통화하고 표준화 한 것이 바로 `Bean Validation`이다. `Bean Validation`을 잘 활용하면 어노테이션 하나로 검증 로직을 매우 편리하게 적용할 수 있다.


> [!tip] Bean Validation 2.0 (JSR-380)
> 참고로 `Bean Validation`은 특정한 구현체가 아니라 `Bean Validation 2.0(JSR-380)`이라는 기술 표준이다. 쉽게 이야기해서 검증 어노테이션과 여러 인터페이스의 모음이다. 마치 `JPA`가 표준 기술이고 그 구현체로 하이버네이트가 있는 것과 같다.
> 
> `Bean Validation`을 구현한 기술 중에 일반적으로 사용하는 구현체는 하이버네이트 Validator이다. 이름이 하이버네이트가 붙어서 그렇지 ORM과는 관련이 없다.

- [Hibernate Validator 공식 사이트](http://hibernate.org/validator)
- [Hibernate Validator 공식 메뉴얼](https://docs.jboss.org/hibernate/validator/6.2/reference/en-US/html_single/)


## Bean Validation - 시작
Bean Validation 기능을 어떻게 사용하는지 코드로 알아본다. 먼저 스프링과 통합하지 않고 순수한 `Bean Validation` 사용법 부터 테스트 코드로 알아본다.

먼저 `build.gradle`에 다음의 의존관계를 추가해야한다.

```
implementation 'org.springframework.boot:spring-boot-starter-validation'
```

그리고 `Item` 클래스에 다음과 같이 `Bean Validation` 어노테이션을 적용한다.

```java
@Data  
public class Item {  
  
    private Long id;  
  
    @NotBlank  
    private String itemName;  
  
    @NotNull  
    @Range(min = 1_000, max = 1_000_000)  
    private Integer price;  
  
    @Max(999)  
    @NotNull  
    private Integer quantity;  
  
    public Item() {  
    }  
  
    public Item(String itemName, Integer price, Integer quantity) {  
        this.itemName = itemName;  
        this.price = price;  
        this.quantity = quantity;  
    }  
}
```

**검증 어노테이션**
- `@NotBlank`: 빈 값 + 공백은 허용되지 않는다.
- `@NotNull`: `null`을 허용하지 않는다.
- `@Range(min = 1_000, max = 1_000_000)`: 범위 안의 값이어야 한다.
- `@Max(999)`: 최대 999까지만 허용한다.

```java
public class BeanValidationTest {  
  
    @Test  
    void beanValidation() {  
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();  
        Validator validator = factory.getValidator();  
  
        Item item = new Item();  
        item.setItemName(" ");  
        item.setPrice(0);  
        item.setQuantity(10000);  
  
        Set<ConstraintViolation<Item>> violations = validator.validate(item);  
  
        for (ConstraintViolation<Item> violation : violations) {  
            System.out.println("violation = " + violation);  
            System.out.println("violation.getMessage() = " + violation.getMessage());  
        }  
    }  
}
```
위의 코드와 같이 테스트 코드를 작성했다. 실행 결과는 다음과 같다.

```
violation = ConstraintViolationImpl{interpolatedMessage='999 이하여야 합니다', propertyPath=quantity, rootBeanClass=class hello.itemservice.domain.item.Item, messageTemplate='{javax.validation.constraints.Max.message}'}
violation.getMessage() = 999 이하여야 합니다
violation = ConstraintViolationImpl{interpolatedMessage='1000에서 1000000 사이여야 합니다', propertyPath=price, rootBeanClass=class hello.itemservice.domain.item.Item, messageTemplate='{org.hibernate.validator.constraints.Range.message}'}
violation.getMessage() = 1000에서 1000000 사이여야 합니다
violation = ConstraintViolationImpl{interpolatedMessage='공백일 수 없습니다', propertyPath=itemName, rootBeanClass=class hello.itemservice.domain.item.Item, messageTemplate='{javax.validation.constraints.NotBlank.message}'}
violation.getMessage() = 공백일 수 없습니다
```

`ConstraintViolation` 출력 결과를 보면 검증 오류가 발생한 객체, 필드, 메시지 정보등 다양한 정보를 확인할 수 있다.

## Bean Validation - 스프링 통합

`Bean Validation`과 스프링 통합 기능을 이용하기 위해, 다음과 같이 코드를 리팩터링한다.

```java
@Controller  
@RequestMapping("/validation/v3/items")  
@RequiredArgsConstructor  
@Slf4j  
public class ValidationItemControllerV3 {  
  
    private final ItemRepository itemRepository;  
  
    @GetMapping  
    public String items(Model model) {  
        List<Item> items = itemRepository.findAll();  
        model.addAttribute("items", items);  
        return "validation/v3/items";  
    }  
  
    @GetMapping("/{itemId}")  
    public String item(@PathVariable long itemId, Model model) {  
        Item item = itemRepository.findById(itemId);  
        model.addAttribute("item", item);  
        return "validation/v3/item";  
    }  
  
    @GetMapping("/add")  
    public String addForm(Model model) {  
        model.addAttribute("item", new Item());  
        return "validation/v3/addForm";  
    }  
  
    @PostMapping("/add")  
    public String addItem(@Validated @ModelAttribute Item item, BindingResult bindingResult,  
                          RedirectAttributes redirectAttributes) {  
  
        // 검증에 실패하면 다시 입력 폼으로  
        if (bindingResult.hasErrors()) {  
            log.info("errors = {}", bindingResult);  
            return "validation/v3/addForm";  
        }  
  
        Item savedItem = itemRepository.save(item);  
        redirectAttributes.addAttribute("itemId", savedItem.getId());  
        redirectAttributes.addAttribute("status", true);  
        return "redirect:/validation/v3/items/{itemId}";  
    }  
  
    @GetMapping("/{itemId}/edit")  
    public String editForm(@PathVariable Long itemId, Model model) {  
        Item item = itemRepository.findById(itemId);  
        model.addAttribute("item", item);  
        return "validation/v3/editForm";  
    }  
  
    @PostMapping("/{itemId}/edit")  
    public String edit(@PathVariable Long itemId, @ModelAttribute Item item) {  
        itemRepository.update(itemId, item);  
        return "redirect:/validation/v3/items/{itemId}";  
    }  
  
}
```

결과를 살펴보니 스프링 MVC가 `Bean Validator`가 적용되어 있다. 

**어떻게 별도의 설정 없이 스프링 MVC가 `Bean Validation`을 어떻게 인지하는 걸까?**

스프링 부트는 `spring-boot-starter-validation` 의존 관계가 있으면, 자동으로 `Bean Validator`를 인지하고 스프링에 통합한다.

**스프링 부트는 자동으로 글로벌 Validator로 등록한다.**

`LocalValidatorFactoryBean`을 글로벌 `Validator`로 등록한다. 이 `Validator`는 `@NotNull`같은 어노테이션을 보고 검증을 수행한다. 이렇게 글로벌 `Validator`가 적용되어 있기 때문에, 검증할 대상 파라미터에 `@Valid`, `@Validated`만 적용하면 된다.

검증 오류가 발생하면, `FieldError`, `ObjectError`를 생성해서 `BindingResult`에 담아준다.

> [!warning] 직접 글로벌 Validator 등록 시
> 다음과 같이 직접 글로벌 `Validator`를 등록 시 스프링 부트는 `Bean Validator`를 글로벌 `Validator`로 등록하지 않는다. 따라서 어노테이션 기반의 빈 검증기가 동작하지 않는다.

```java title="ItemServiceApplication.java"
@SpringBootApplication  
public class ItemServiceApplication implements WebMvcConfigurer {  
  
    public static void main(String[] args) {  
       SpringApplication.run(ItemServiceApplication.class, args);  
    }

	@Override
	public Validator getValidator() {
		return new ItemValidator();
	} 
}
```

따라서, `Bean Validation`을 적용하면 따로 `Validator`에 관련한 설정은 해주지 않아도 된다.

> [!tip] @Validated, @Valid 참고
> 검증시 `@Validated` `@Valid` 둘다 사용가능하다.
> 
> `javax.validation.@Valid` 를 사용하려면 `build.gradle` 의존관계 추가가 필요하다. (이전에 추가했다.) 
> 
> `implementation 'org.springframework.boot:spring-boot-starter-validation'`
> 
> `@Validated` 는 스프링 전용 검증 애노테이션이고, `@Valid` 는 자바 표준 검증 애노테이션이다. 둘중 아무거나 사용해도 동일하게 작동하지만, `@Validated` 는 내부에 `groups` 라는 기능을 포함하고 있다.

### 검증 순서
1. `@ModelAttribute` 각각의 필드에 타입 변환 시도
	- 성공하면 다음으로
	- 실패하면 `typeMismatch`로 `FieldError` 추가
2. `Validator` 적용

중요한 점은 객체에 값 바인딩이 성공한 필드에 한해서 `Bean Validation`이 적용 된다. 쉽게 말해서 타입 변환이 실패하면 `@Range`나 `@Max`와 같은 어노테이션 적용은 무의미하다.

예를 들어 아이템의 수량을 의미하는 필드인 `quantity`는 `Integer` 타입이고, `@Max(999)` 어노테이션이 적용 되어 있다. 그런데 HTTP 요청으로 ㄷ

---
References: 김영한의 스프링 MVC 2편

Links to this page: 