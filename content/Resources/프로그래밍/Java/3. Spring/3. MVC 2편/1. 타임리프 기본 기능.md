---
title: 
tags:
  - thymeleaf
publish: true
date: 2024-11-25
---
## 타임리프 소개
- [공식 사이트](https://www.thymeleaf.org)
- [공식 문서 - 기본 기능](https://www.thymeleaf.org/doc/tutorials/3.1/usingthymeleaf.html)
- [공식 메뉴얼 - 스프링 통합](https://www.thymeleaf.org/doc/tutorials/3.1/thymeleafspring.html)

이전 강의인 스프링 MVC 1편에서 타임리프를 간단히 사용해보고 특징도 알아보았다. 이번에는 타임리프의 개념을 간단히 소개하고 실제 동작하는 기본 기능 위주로 알아본다.

### 타임리프의 특징
- 서버 사이드 HTML 렌더링 (SSR)
- 내추럴 템플릿
- 스프링 통합 지원

#### 서버 사이드 HTML 렌더링 (SSR)

타임리프는 백엔드 서버에서 HTML을 동적으로 렌더링하는 용도로 사용된다.

#### 내추럴 템플릿

타임리프는 순수 HTML을 최대한 유지하는 특징이 있다. 타임리프로 작성한 파일은 HTML을 유지하기 때문에 웹 브라우저에서 파일을 직접 열어도 내용을 확인할 수 있고, 서버를 통해 뷰 템플릿을 거치면 동적으로 변경된 결과를 확인할 수 있다.

JSP를 포함한 다른 뷰 템플릿들은 해당 파일을 여는 경우, 예를 들어서 JSP 파일 자체를 그대로 웹 브라우저에서 열어보면 JSP 소스코드와 HTML이 뒤죽박죽 섞여서 웹 브라우저에서 정상적인 HTML 결과를 확인할 수 없다. 오직 서버를 통해 JSP가 렌더링 되고 HTML 응답 결과를 받아야 화면을 확인할 수 있다.

반면에 타임리프로 작성된 파일은 해당 파일을 그대로 웹 브라우저에서 열어도 정상적인 HTML 결과를 확인 할 수 있다. 물론 이 경우 동적으로 결과가 렌더링 되지는 않는다. 하지만 HTML 마크업 결과가 어떻게 되는지 파일만 열어도 바로 확인할 수 있다.

이렇게 HTML을 그대로 유지하면서 뷰 템플릿도 사용할 수 있는 타임리프의 특징을 내추럴 템플릿(Natural Templates)이라 한다.

#### 스프링 통합 지원
타임리프는 스프링과 자연스럽게 통합되고, 스프링의 다양한 기능을 편리하게 사용할 수 있게 지원한다. 이 부분은 스프링 통합과 폼 장에서 알아본다.

## 기본 기능

### 텍스트 - text, utext
타임리프의 기본 기능인 텍스트를 출력하는 기능

```html
<li>th:text 사용 <span th:text="${data}"></span></li>  
<li>컨텐츠 안에서 직접 출력 = [[${data}]]</li>
```

- `[[${data}]]`로 컨텐츠 내에서 직접 텍스트를 출력할 수 있다.

#### 이스케이프
서버에서 모델에 데이터를 담아서 템플릿 엔진에서 렌더링 할 때, 타임리프는 기본적으로 이스케이프를 적용한다. 따라서 서버에서 `Hello <b>Spring!</b>`와 같은 문자열을 타임리프를 통해 렌더링 할 때 개발자의 의도에 맞게 Spring이 굵은 글씨체로 나오게 하기 위해서는 **Unescape**를 해주어야 한다.

- th:text -> th:utext
- \[\[...]] -> \[(...)]


### 변수 - SpringEL
타임리프에서 변수를 사용할 때는 변수 표현식을 사용한다. 변수 표현식은 다음과 같다.

`${...}`

그리고 이 변수 표현식에는 스프링 EL이라는 스프링이 제공하는 표현식을 사용할 수 있다.

```html
<h1>SpringEL 표현식</h1>  
<ul>Object  
    <li>${user.username} = <span th:text="${user.username}"></span></li>  
    <li>${user['username']} = <span th:text="${user['username']}"></span></li>  
    <li>${user.getUsername()} = <span th:text="${user.getUsername()}"></span></li>  
</ul>  
<ul>List  
    <li>${users[0].username} = <span th:text="${users[0].username}"></span></li>  
    <li>${users[0]['username']} = <span th:text="${users[0]['username']}"></span></li>  
    <li>${users[0].getUsername()} = <span th:text="${users[0].getUsername()}"></span></li>  
</ul>  
<ul>Map  
    <li>${userMap['userA'].username} = <span th:text="${userMap['userA'].username}"></span></li>  
    <li>${userMap['userA']['username']} = <span th:text="${userMap['userA']['username']}"></span></li>  
    <li>${userMap['userA'].getUsername()} = <span th:text="${userMap['userA'].getUsername()}"></span></li>  
</ul>
```

### 지역 변수 선언
`th:with`를 사용하면 지역 변수를 선언해서 사용할 수 있다. 지역 변수는 선언한 태그 범위의 안에서만 사용할 수 있다.

```html
<h1>지역 변수 - th:with</h1>  
<div th:with="first=${users[0]}">  
    <p>처음 사람의 이름은 [[${first.username}]]</p>  
</div>
```

### 기본 객체
타임리프는 기본 객체들을 제공한다. 강의에서는 타임리프 3.0 버전을 사용하는데, 내가 사용하는 버전은 3.1 버전이라 차이가 존재한다.

타임리프 3.1 버전의 기본 객체는 [타임리프 공식 문서 - 기본 객체](https://www.thymeleaf.org/doc/tutorials/3.1/usingthymeleaf.html#expression-basic-objects)에서 확인할 수 있다.

기본 객체의 종류는 다음과 같다.
- `#ctx`: 컨텍스트 객체
- `#vars`: 컨텍스트 변수 객체
- `#locale`: 로케일 컨텍스트 객체

### 유틸리티 객체와 날짜
타임리프는 문자, 숫자, 날짜, URI 등을 편리하게 다루는 다양한 유틸리티 객체들을 제공한다.

- `#message` : 메시지, 국제화 처리
- `#uris` : URI 이스케이프 지원
- `#dates` : `java.util.Date` 서식 지원
- `#calendars` : `java.util.Calendar` 서식 지원
- `#temporals` : 자바8 날짜 서식 지원
- `#numbers` : 숫자 서식 지원
- `#strings` : 문자 관련 편의 기능
- `#objects` : 객체 관련 기능 제공
- `#bools` : boolean 관련 기능 제공
  `#arrays` : 배열 관련 기능 제공
  `#lists` , `#sets` , `#maps` : 컬렉션 관련 기능 제공
  `#ids` : 아이디 처리 관련 기능 제공, 뒤에서 설명

### URL 링크
타임리프에서 URL을 생성할 때는 `@{...}` 문법을 사용하면 된다.

```html
<h1>URL 링크</h1>  
<ul>  
    <li><a th:href="@{/hello}">basic url</a></li>  
    <li><a th:href="@{/hello(param1=${param1}, param2=${param2})}">hello query param</a></li>  
    <li><a th:href="@{/hello/{param1}/{param2}(param1=${param1}, param2=${param2})}">path variable</a></li>  
    <li><a th:href="@{/hello/{param1}(param1=${param1}, param2=${param2})}">path variable + query parameter</a></li>  
</ul>
```

#### 단순 URL
- `@{/hello}` 
	- -> `/hello`
#### 쿼리 파라미터
- `@{/hello(param1=${param1}, param2=${param2})}`
	- -> `/hello?param1=data1&param2=data2`
	- `()` 괄호에 있는 부분은 쿼리 파라미터로 치환된다.
#### 경로 변수
- `@{/hello/{param1}/{param2}(param1=${param1}, param2=${param2})}`
	- -> `/hello/data1/data2`
	- URL 경로 상에 변수가 있으면 `()` 부분은 경로 변수로 처리된다.
#### 경로 변수 + 쿼리 파라미터
- `@{/hello/{param1}(param1=${param1}, param2=${param2})}`
	- -> `/hello/data1?param2=data2`
	- 경로 변수와 쿼리 파라미터를 함께 사용할 수 있다.

상대경로, 절대경로, 프로토콜 기준을 표현할 수도 있다.
- `/hello`: 절대 경로
- `hello`: 상대 경로

### 리터럴
리터럴은 소스 코드 상에서 고정된 값을 말하는 용어다. 타임리프에는 다음과 같은 리터럴이 있다.

- 문자: `'hello'`
- 숫자: `10`
- 불린: `true`, `false`
- null: `null`

타임리프에서 문자 리터럴은 항상 작은 따옴표로 감싸야 한다. 그런데 문자를 항상 작은 따옴표로 감싸는 것은 너무 귀찮은 일이다. 공백 없이 쭉 이어진다면 하나의 의미있는 토큰으로 인지해서 다음과 같이 작은 따옴표를 생략할 수 있다.

- `<span th:text="hello">`: 하나의 토큰으로 인지한다.
- `<span th:text="hello spring!">`:  오류가 발생한다. 문자 리터럴은 원칙상 작은 따옴표로 감싸야한다. 중간에 공백이 있어서 하나의 토큰으로 인식되지 않는다.

#### 리터럴 대체 (Literal substitutions)
```html
<li>리터럴 대체 |hello ${data}| = <span th:text="|hello ${data}|"></span></li>
```

리터럴 대체 문법을 사용하면 마치 템플릿을 사용하는 것 처럼 편리하다.

### 반복
타임리프에서 반복은 `th:each`를 사용한다. 추가로 반복에서 사용할 수 있는 여러 상태 값을 지원한다.


---
References: 김영한의 스프링 MVC 2편

Links to this page: 