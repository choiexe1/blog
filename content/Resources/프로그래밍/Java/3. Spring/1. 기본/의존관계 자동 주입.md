---
title: 
tags:
  - java
  - programming
  - spring
publish: true
date: 2024-11-18
---
## 다양한 의존관계 주입 방법
의존관계 주입은 다음과 같이 크게 4가지 방법이 있다.
- 생성자 주입
- 수정자 주입(setter 주입)
- 필드 주입
- 일반 메서드 주입

### 생성자 주입
지금까지 주로 사용했던 방법이다. 생성자를 통해서 의존 관계를 주입한다.

**특징**
- 생성자 호출 시점에 딱 1번만 호출되는 것이 보장된다.
- **불변**, **필수** 의존관계에 사용한다.

```java
@Component  
public class OrderServiceImpl implements OrderService {  
    private final MemberRepository memberRepository;  
    private final DiscountPolicy discountPolicy;
    
	@Autowired  
	public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {  
	    this.memberRepository = memberRepository;  
	    this.discountPolicy = discountPolicy; 
	}
}
```

> [!summary] @Autowired 생략
> 스프링 빈 컴포넌트에 생성자가 딱 1개만 존재하면, `@Autowired`를 생략해도 자동 주입 된다.
> 
> 이유는 생성자가 2개라면 스프링 컨테이너 입장에서, 어떤 생성자를 통해서 의존관계를 주입해야 할 지 모호성이 생기기 때문이다.

### 수정자 주입 (setter 주입)
필드 값을 변경하는 수정자 메서드인 세터를 통해서 의존관계를 주입하는 방법이다.

**특징**
- **선택**, **변경** 가능성이 있는 의존관계에 사용
- 자바 빈 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법이다.

```java
@Component  
public class OrderServiceImpl implements OrderService {  
    private MemberRepository memberRepository;  
    private DiscountPolicy discountPolicy;

	@Autowired
	public void setMemberRepository(MemberRepository memberRepository) {
		this.memberRepository = memberRepository;
	}
	
	@Autowired
	public void setDiscountPolicy(DiscountPolicy discountPolicy) {
		this.discountPolicy = discountPolicy;
	}
}
```

> [!summary] @Autowired의 기본 동작
> `@Autowired`의 기본 동작은 주입할 대상이 없으면 오류가 발생한다.
> 
> 예시로, 위 코드 예제에서 `MemberRepository`가 스프링 빈으로 등록되어 있지 않을 때는 스프링 컨테이너 내부에 주입할 대상이 없으므로 오류가 발생한다.
> 
> 주입할 대상이 없어도 동작하게 하려면 `@Autowired(required = false)`로 지정하면 된다.

### 필드 주입
이름 그대로 필드에 바로 주입하는 방법이다.

**특징**
- 외부에서 변경이 불가능하다. (테스트하기 힘들다는 치명적인 단점)
- DI 프레임워크가 없으면 주입이 불가능하기 때문에 아무것도 할 수 없다.
- 사용하지 말자.
	- 어플리케이션의 실제 코드와 관계 없는 테스트 코드
	- 스프링 설정을 목적으로 하는 `@Configuration`같은 곳에서만 특별한 용도로 사용

```java
@Component
public class OrderServiceImpl implements OrderService {
	@Autowired private MemberRepository memberRepository;
	@Autowired private DiscountPolicy discountPolicy;
}
```

> [!tip] 테스트 코드에 자동 주입 적용
> 테스트 코드에 `@Autowired`를 적용 시키기 위해서는 `@SpringBootTest` 어노테이션을 테스트 케이스 클래스에 적용 시켜서 스프링 컨테이너를 테스트에 통합한 경우에만 가능하다.

### 일반 메서드 주입
일반 메서드를 통해서 주입 받을 수 있다.

**특징**
- 한번에 여러 필드를 주입 받을 수 있다.
- 일반적으로 잘 사용하지 않는다.

```java
@Autowired  
public void init(MemberRepository memberRepository, DiscountPolicy discountPolicy) {  
    this.memberRepository = memberRepository;  
    this.discountPolicy = discountPolicy;  
}
```

## 옵션 처리
주입할 스프링 빈이 없어도 동작해야 할 때가 있다.

예를 들어 해당 클래스가 주입되지 않았으면 어떤 로직을 실행하지 않거나 하는 등의 조건에 필요하다.

그런데 `@Autowired`만 사용하면 `required` 옵션의 기본 값이 `true`로 되어 있어서, 자동 주입 대상이 없으면 오류가 발생한다.

자동 주입 대상을 옵션으로 처리하는 방법은 다음과 같다.
- `@Autowired(required=false)`: 자동 주입 할 대상이 없으면 수정자 메서드 자체가 호출이 안됨
- `org.springframework.lang.@Nullable`: 자동 주입할 대상이 없으면 null이 입력된다.
- `Optional<>`: 자동 주입할 대상이 없으면 Optional.empty가 입력된다.

```java
public class AutowiredTest {  
    @Test  
    void AutowiredOption() {  
        ApplicationContext ac = new AnnotationConfigApplicationContext(  
                TestBean.class);  
    }  
  
    static class TestBean {  
        @Autowired(required = false)  
        public void setNoBean1(Member noBean1) {  
            System.out.println("noBean1 = " + noBean1);  
        }  
  
        @Autowired  
        public void setNoBean2(@Nullable Member noBean2) {  
            System.out.println("noBean2 = " + noBean2);  
        }  
  
        @Autowired  
        public void setNoBean3(Optional<Member> noBean3) {  
            System.out.println("noBean3 = " + noBean3);  
        }  
    }  
}
```

- **setNoBean1(Member noBean1)**: `@Autowired(required=false)`로 설정되어 있어 메서드 자체를 호출 하지 않는다. 참고로 `Member`는 스프링 빈이 아니므로, `required` 옵션을 `true`로 설정 시 에러가 발생한다.
- **setNoBean(@Nullable Member noBean2)**: `@Nullable`은 `null`일 수도 있다는 어노테이션이다. 자바 8부터 지원한다. 메서드는 정상적으로 호출 되고, `null`이 출력된다.
- **setNoBean(Optional\<Member> noBean3)**: 마찬가지로 메서드는 호출되고, `noBean3` 파라미터의 값이 `Optinal.empty`로 입력된다.

## 생성자 주입을 선택하라
과거에는 수정자 주입과 필드 주입을 많이 사용했지만, 최근에는 스프링을 포함한 DI 프레임워크 대부분이 생성자 주입을 권장한다.

> `Nest.JS`도 제공자(Provider)로 DI 할 수 있지만, 보통은 생성자 주입을 사용했다.

### 불변
- 대부분의 의존관계 주입은 한번 일어나면 어플리케이션 종료 시점까지 의존관계를 변경할 일이 없다. 오히려 대부분의 의존관계는 어플리케이션 종료 전까지 변하면 안된다.
- 수정자 주입을 사용하면, `수정자 메서드`를 `public`으로 열어두어야 한다. 누군가 실수로 변경할 수도 있고, 변경하면 안되는 메서드를 열어두는 것은 좋은 설계 방법이 아니다.
- 생성자 주입은 객체를 생성할 때 딱 1번만 호출되므로 이후에 호출되는 일이 없다. 따라서 불변하게 설계할 수 있다.

### final 키워드
생성자 주입을 사용하면 필드에 `final` 키워드를 사용할 수 있다. 그래서 생성자에서 혹시라도 값이 설정되지 않는 오류를 컴파일 시점에 막아준다.

```java
@Component
public class OrderServiceImpl implements OrderService {
	private final MemberRepository memberRepository;
	private final DiscountPolicy discountPolicy;

	@Autowired
	public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
		this.memberRepository = memberRepository;
	}
}
```

생성자에 필수 필드인 `discountPolicy`가 누락되었다. 자바는 컴파일 시점에 다음 오류를 발생시킨다.

`java: variable discountPolicy might not have been initialized`

기억하자, 컴파일 오류는 세상에서 가장 빠르고, 좋은 오류다.

> [!tip] 참고
> 수정자 주입을 포함한 나머지 주입 방식들은 모두 생성자 호출 이후에 호출되므로, 필드에 `final` 키워드를 사용할 수 없다. 오직 생성자 주입만 `final` 키워드를 사용할 수 있다.

> [!note] 정리
> 생성자 주입 방식을 선택하는 이유는 여러가지가 있지만, 프레임워크에 의존하지 않고 순수한 자바 언어의 특징을 잘 살리는 방법이기도 하다.
> 
> 기본적으로 생성자 주입을 사용하고, 필수 값이 아닌 경우에는 수정자 주입 방식을 옵션으로 부여하면 된다. 생성자 주입과 수정자 주입을 동시에 사용할 수 있다.
> 
> 항상 생성자 주입을 선택해라, 그리고 가끔 옵션이 필요하면 수정자 주입을 선택해라. 필드 주입은 사용하지 않는 게 좋다.

## 롬복과 최신 트렌드
막상 개발을 해보면, 대부분이 다 불변이고 그래서 다음과 같이 생성자에 `final` 키워드를 사용하게 된다.

그런데 생성자도 만들어야 하고, 주입 받은 값을 대입하는 코드도 만들어야 하고.. 필드 주입처럼 좀 편리하게 사용하는 방법은 없을까?

다음 기본 코드를 최적화 해보자.

```java
@Component  
public class OrderServiceImpl implements OrderService {  
    private final MemberRepository memberRepository;  
    private final DiscountPolicy discountPolicy;  
      
    public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {  
        this.memberRepository = memberRepository;  
        this.discountPolicy = discountPolicy;  
    }
}
```

- 생성자가 1개이므로 `@Autowired` 어노테이션을 생략한다.

**롬복(Lombok)**
- 이제 롬복 라이브러리를 프로젝트에 적용 시켜본다.
- 다음의 의존 관계들을 `build.gradle`에 추가한다.

```
compileOnly 'org.projectlombok:lombok'
annotationProcessor 'org.projectlombok:lombok'
testCompileOnly 'org.projectlombok:lombok'
testAnnotationProcessor 'org.projectlombok:lombok'
```
- 인텔리제이 롬복(Lombok) 플러그인을 설치한다.
- 인텔리제이 `Preferences` -> `Annotation Processors` 검색 -> `Enable annotation processing` 체크 후 재시작 한다.

> [!tip] 롬복
> 스프링 이니셜라이저에서 프로젝트 생성 시에 디펜던시로 추가할 수 있다.



```java
import lombok.Getter;  
import lombok.Setter;  
  
@Getter  
@Setter  
public class HelloLombok {  
    private String name;  
    private int age;  
  
    public static void main(String[] args) {  
        HelloLombok lombok = new HelloLombok();  
  
        lombok.setName("Hello");  
        lombok.setAge(123);  
    }  
}
```

롬복은 `Annotation Processor`를 통해 작동한다. `Annotation Processor`는 컴파일 단계에서 `Annotation`에 정의된 일련의 프로세스를 동작하게 해주는 것을 의미한다.

위 코드의 어노테이션인 `@Getter`와 `@Setter`는 롬복에서 제공하는 기능으로 어노테이션과 어노테이션 프로세서를 제공하여 표준적으로 작성해야 할 코드를 개발자 대신 생성해주는 라이브러리다.

이 외에도 다양한 어노테이션을 제공하므로 다음에 한번 라이브러리에 대해 공부해보자.

다시 `OrderServiceImpl` 코드로 돌아간다.

```java
@Component  
@RequiredArgsConstructor  
public class OrderServiceImpl implements OrderService {  
    private final MemberRepository memberRepository;  
    private final DiscountPolicy discountPolicy;  
}
```

`@RequiredArgsConstructor`는 롬복에서 제공하는 기능 중 하나로, `final` 키워드가 붙은 필드를 모아서 생성자를 자동으로 만들어준다.

이 코드와 이전의 코드는 완전히 동일하다. 실제 `class` 파일을 열어보면 생성자 코드가 추가가 되어 있다.

> [!note] 정리
> 최근에는 생성자를 딱 1개 두고, `@Autowired`를 생략하는 방법을 주로 사용한다. 여기에 `Lombok` 라이브러리의 `@RequiredArgsConstructor`를 함께 사용하면 기능은 다 제공하면서 코드는 깔끔하게 사용할 수 있다.

## 조회 빈이 2개 이상인 문제

`@Autowired`는 타입(Type)으로 조회한다. 따라서 실제로는 더 많은 기능을 제공하지만 다음 코드와 유사하게 동작한다.

`DiscountPolicy`의 하위 타입인 `FixDiscountPolicy`와 `RateDiscountPolicy`를 모두 스프링 빈으로 선언해본다.

```java
@Component
public class FixDiscountPolicy implements DiscountPolicy {}

@Component
public class RateDiscountPolicy implements DiscountPolicy {}
```

그리고 다음과 같이 의존관계를 자동 주입 하면 `NoUniqueBeanDefinitionException` 예외가 발생한다.

```java
public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {  
    this.memberRepository = memberRepository;  
    this.discountPolicy = discountPolicy;  
}
```

`DiscountPolicy` 타입의 빈 하나를 기대했는데, 스프링 빈 저장소에서 두개가 발견되어 버린 것이다.

앞서 `DiscountPolicy`의 하위 타입을 모두 스프링 빈으로 선언했었다. 스프링 컨테이너는 어떤 `DiscountPolicy`를 `OrderServiceImpl`에 의존관계 주입 해야할 지 정할 수 없게 된다. 그 때문에 발생한 예외이다.

물론 생성자 주입 시 하위 타입으로 지정할 수도 있다. 다만 이는 DIP를 위반하고 유연성이 떨어지는 단점이 생긴다.

그리고 이름만 다르고, 완전히 똑같은 타입의 스프링 빈이 2개 있을 때 해결이 안된다. 스프링 빈을 수동 등록해서 문제를 해결해도 되지만, 의존 관계 자동 주입에서 해결하는 여러 방법이 존재한다.



---
References: 김영한의 스프링 핵심 원리 - 기본편

Links to this page: 