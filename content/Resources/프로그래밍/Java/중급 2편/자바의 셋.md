---
title: 
tags:
  - java
  - programming
  - data-structure
  - algorithm
  - set
  - collection-framework
publish: true
date: 2024-11-04
---
## 자바가 제공하는 Set 1 (HashSet, LinkedHashSet)
![[자바-set.png]]

위는 자바에서 제공하는 컬렉션 프레임워크 `Set`의 구조도이다.

**Set 인터페이스**

자바의 `Set` 인터페이스는 `java.util` 패키지의 컬렉션 프레임워크에 속하는 인터페이스 중 하나이다. 

`Set` 인터페이스는 중복을 허용하지 않는 유일한 요소의 집합을 나타낸다. 즉, 어떤 요소도 같은 `Set` 내에 두 번 이상 나타날 수 없다. `Set`은 수학적 집합 개념을 구현한 것으로, 순서를 보장하지 않으며, 특정 요소가 집합에 있는지 여부를 확인하는 데 최적화 되어 있다.

`Set` 인터페이스는 `HashSet`, `LinkedHashSet`, `TreeSet`등의 여러 구현 클래스를 가지고 있으며, 각 클래스는 `Set` 인터페이스를 구현하며 각각의 특성을 가지고 있다.

지금부터 `Set` 인터페이스의 주요 구현체를 하나씩 알아본다.
1. `HashSet`
2. `LinkedHashSet`
3. `TreeSet`

### HashSet
- **구현**: 해시 자료구조를 사용해서 요소를 저장한다.
- **순서**: 요소들은 특정한 순서 없이 저장된다. 즉, 요소를 추가한 순서를 보장하지 않는다.
- **시간 복잡도**: `HashSet`의 주요 연산(추가, 삭제, 검색)은 평균적으로 `O(1)`의 시간 복잡도를 가진다.
- **용도**: 데이터의 유일성만 중요하고, 순서가 중요하지 않은 경우에 적합하다.

앞서 우리가 구현한 [[해시 알고리즘 3#직접 구현하는 Set 4 (제네릭과 인터페이스 도입)|MyHashSet]]이 바로 `HashSet`이다.

### LinkedHashSet
- 구현: `LinkedHashSet`은 `HashSet`에 연결 리스트를 추가해서 요소들의 순서를 유지한다.
- 순서: 요소들은 추가된 순서대로 유지된다. 즉, 순서대로 조회 시 요소들이 추가된 순서대로 반환된다.
- 시간 복잡도: `HashSet`과 마찬가지로 주요 연산에 대해 평균 `O(1)`의 시간 복잡도를 가진다.
- 용도: 데이터의 유일성과 함께 삽입 순서를 유지해야 할 때 적합하다.
- 참고: 연결 링크를 유지해야 하기 때문에 `HashSet`보다는 조금 더 무겁다.

![[linked-hash-set.png]]
- `LinkedHashSet`은 `HashSet`에 연결 링크만 추가한 것이다. `HashSet`에 `LinkedList`를 합친 것으로 이해하면 된다.
- 데이터를 삽입할 때 노드로써 추가하고, 순서를 `LinkedList`처럼 삽입 순서대로 연결하는 것이다.
- 예시로 첫 번째 데이터인 `1`을 삽입할 때 `Node`를 생성하고 해당 `Node`에 값을 넣는다. 그 후에 들어오는 데이터는 또 다시 노드를 생성하고, 해당 노드에 대한 참조값을 `1`번 노드에 연결한다.
	- `head(first)`부터 순서대로 링크를 따라가면 입력 순서대로 데이터를 순회할 수 있게 된다.
	- 양방향으로 연결된다. (그림에서는 이해를 돕기 위해 화살표는 다음 순서로만 보여주었다. 실제로는 양방향이다.)
- 이미지에서는 `1`, `2`, `5`, `8`, `14`, `99` 순서대로 입력된다. 해당 순서대로 연결 되어 있는 것을 확인할 수 있다.

## 자바가 제공하는 Set 2 (TreeSet)

`TreeSet`을 이해하려면 먼저 트리 구조를 알아야 한다.

![[tree-structure.png]]
- 트리(Tree)는 부모 노드와 자식 노드로 구성된다.
- 가장 높은 조상을 루트(root, 뿌리)라 한다.
- 자식이 2개까지 올 수 있는 트리를 **이진 트리**라 한다.
- 여기에 노드의 왼쪽 자손은 더 작은 값을 가지고, 오른쪽 자손을 더 큰 값을 가지는 것을 **이진 탐색 트리**라 한다.
- 자바가 제공하는 `TreeSet`은 이진 탐색 트리를 개선한 레드-블랙 트리를 사용한다. 기본 개념은 비슷하므로 이진 탐색 트리의 원리를 알아보자.

##### TreeSet
- **구현**: `TreeSet`은 이진 탐색 트리를 개선한 레드-블랙 트리를 내부에서 사용한다.
- **순서**: 요소들은 정렬된 순서로 저장된다. 순서의 기준은 비교자(`Comparator`)로 변경할 수 있다. 비교자는 뒤에서 다룬다.
- **시간 복잡도**: 주요 연산들은 O(log n)의 시간 복잡도를 가진다. 따라서 `HashSet`보다는 느리다.
- **용도**: 데이터를 정렬된 순서로 유지하면서 집합의 특성을 유지해야 할 때 사용한다. 예를 들어, 범위 검색이나 정렬된 데이터가 필요한 경우에 유용하다. 참고로 입력된 순서가 아니라 데이터 값을 기준으로 순서를 따진다.
  예를 들어 `3`, `1`, `2`를 순서대로 입력해도 `1`, `2`, `3` 순서로 출력된다.

**트리 구조의 구현**

![[tree-structure-implements.png]]
```java
class Node {
	Object item;
	Node left;
	Node right;
}
```

- 트리 구조는 왼쪽, 오른쪽 노드를 알고 있으면 된다.
- 앞서 다룬 [[노드와 연결, 연결 리스트|연결 리스트]]의 구현을 떠올려보면 쉽게 이해가 될 것이다.

#### 이진 탐색 트리 - 입력 예시

이진 탐색 트리의 핵심은 데이터를 입력하는 시점에 정렬해서 보관한다는 점이다.
그리고 작은 값은 왼쪽에, 큰 값은 오른쪽에 저장한다.
데이터를 `10`, `5`, `15`, `1`, `6`, `11`, `16` 순서대로 입력한다고 가정해보자.

처음에 `10`을 입력하고, 다음으로 `5`, `15`를 입력한다.

![[binary-search-tree-example-01.png]]
- `5`는 `10`보다 작으므로 왼쪽에 저장된다.
- `15`는 `10`보다 크므로 오른쪽에 저장된다.


![[binary-search-tree-example-02.png]]
- `1`은 `10`보다 작다, 따라서 왼쪽으로 찾아간다. `1`은 `5`보다 작다. 왼쪽에 저장된다.
- `6`은 `10`보다 작다, 따라서 왼쪽으로 찾아간다. `6`은 `5`보다 크다. 오른쪽에 저장된다.

#### 이진 탐색 트리 - 검색 예시
![[binary-search-tree-example-03.png]]

위 이미지에는 총 15개의 데이터가 들어있다. 여기선 숫자 `35`를 검색한다고 가정한다.

1. 루트인 `20`과 `35`를 비교한다. `35`가 더 크므로 오른쪽으로 찾아간다.
2. `40`과 `35`를 비교한다. `35`가 더 작으므로 왼쪽으로 찾아간다.
3. `30`과 `35`를 비교한다. `35`가 더 크므로 오른쪽으로 찾아간다.
4. 노드에 있는 값을 비교한다. `35`와 같으므로 `35`를 찾는다.

데이터가 총 15개인데, 4번의 계산만으로 필요한 결과를 찾았다. 이것은 `O(n)`인 리스트의 검색보다는 빠르고, `O(1)`인 해시의 검색보다는 느리다.
- 리스트의 경우 `O(n)`이므로 15번의 연산이 필요하다.
- 해시 검색은 `O(1)`이므로 1번의 연산이 필요하다.

이진 탐색 트리 계산의 핵심은 한번에 절반을 날린다는 점이다. 계산을 단순화 하기 위해 16개의 데이터가 있다고 가정하자.
- 16개의 데이터가 있다. 루트에서 처음 비교를 통해 절반의 데이터를 찾지 않아도 된다. 따라서 16 / 2 = 8이 된다.
- 8개의 데이터가 있다. 비교를 통해 절반만 남는다. 8 / 2 = 4가 된다.
- 4개의 데이터가 있다. 비교를 통해 절반만 남는다. 4 / 2 = 2가 된다.
- 2개의 데이터가 있다. 비교를 통해 절반만 남는다. 2 / 2 = 1이 된다.
- 1이 남았으므로 이 값이 맞는지 확인하면 된다.

##### 이진 탐색 트리의 빅 오 - O(log n)
![[binary-search-trees-bigO.png]]

16개 데이터의 경우 단 4번의 비교만으로 최종 노드에 도달할 수 있다. 
- 16개의 데이터는 2로 1번 나누면 된다. 
	- $2^4$이다. 
	- 로그 표현은 $log_2(16) = 4$
- 32개의 데이터는 2로 5번 나누면 된다. 
	- $2^5$이다. 
	- 로그 표현은 $log_2(32) = 5$
- 64개의 데이터는 2로 6번 나누면 된다. 
	- $2^6$이다. 
	- 로그 표현은 $log_2(64) = 6$
- 1024개의 데이터는 2로 10번 나누면 된다.
	- $2^{10}$이다.
	- 로그 표현은 $log_2(1024) = 10$

1024개의 데이터는 단 10번의 계산으로 원하는 결과를 찾을 수 있다. 

데이터의 크기가 늘어나도 늘어난 만큼 한 번의 계산에 절반을 연산에서 제외하기 때문에, `O(n)`과 비교해서 데이터의 크기가 클 수록 효과적이다.

로그는 단순히 2로 몇번 나누어야 1에 도달할 수 있는지, 표현하는 것이다.


---
References: 김영한의 실전 자바 - 중급 2편

Links to this page: [[해시 알고리즘 3]], [[노드와 연결, 연결 리스트]]