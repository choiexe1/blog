---
title: 
tags:
  - java
  - programming
  - algorithm
  - data-structure
  - collection-framework
  - hash
  - set
publish: true
date: 2024-10-27
---
## 직접 구현하는 Set 1 (MyHashSetV1)
지금까지 학습한 내용을 기반으로 해시 알고리즘을 적용해서 `Set` 자료구조를 다시 구현한다.
그 전에 `Set`의 정의를 다시 한번 복습한다.

- `Set`은 중복을 허용하지 않고, 순서를 보장하지 않는 자료구조이다.

이전에 구현한 성능이 `O(n)`으로 느린 [[Set 자료구조#직접 구현하는 Set 0|MyHashSetV0]]을 다시 한번 확인 해보자. 

**`MyHashSetV0`의 단점**
- `add()`로 데이터를 추가할 때 셋에 중복 데이터가 있는지 전체 데이터를 순회하며 항상 확인해야 한다. 따라서 `O(n)`으로 입력 성능이 나쁘다.
- `contains()`로 데이터를 찾을 때는 셋에 있는 모든 데이터를 찾고 비교해야 하므로 평균 `O(n)`이 걸린다.

`MyHashSetV0`의 문제는 데이터를 추가할 때 중복 데이터가 있는지 체크하는 부분에서 성능이 `O(n)`으로 좋지 않다는 점이다. 이렇게 성능이 느린 `MyHashSetV0`을 해시 알고리즘을 사용해서 평균 `O(1)`로 개선한다.

- **add(value)**: 셋에 값을 추가한다. 중복 데이터는 저장하지 않는다.
- **contains(value)**: 셋에 값이 있는지 확인한다.
- **remove(value)**: 셋에 있는 값을 제거한다.

### 해시 알고리즘을 사용하도록 개선된 MyHashSetV1
```java
import java.util.Arrays;  
import java.util.LinkedList;  
  
public class MyHashSetV1 {  
    static final int DEFAULT_INITIAL_CAPACITY = 16;  
    private int size;  
    private int capacity = DEFAULT_INITIAL_CAPACITY;  
  
    LinkedList<Integer>[] buckets;  
  
    public MyHashSetV1() {  
        initBuckets();  
    }  
  
    public MyHashSetV1(int capacity) {  
        this.capacity = capacity;  
        initBuckets();  
    }  
  
    private void initBuckets() {  
        buckets = new LinkedList[capacity];  
  
        for (int i = 0; i < capacity; i++) {  
            buckets[i] = new LinkedList<>();  
        }  
    }  
  
    public boolean add(int value) {  
        int hashIndex = hashIndex(value);  
        LinkedList<Integer> bucket = buckets[hashIndex];  
  
        if (bucket.contains(value)) return false;  
  
        bucket.add(value);  
        size++;  
  
        return true;  
    }  
  
    public boolean contains(int searchValue) {  
        int hashIndex = hashIndex(searchValue);  
        LinkedList<Integer> bucket = buckets[hashIndex];  
  
        return bucket.contains(searchValue);  
    }  
  
    public boolean remove(int value) {  
        int hashIndex = hashIndex(value);  
        LinkedList<Integer> bucket = buckets[hashIndex];  
  
        boolean result = bucket.remove(Integer.valueOf(value));  
  
        if (result) {  
            size--;  
            return true;  
        } else {  
            return false;  
        }  
    }  
  
    public int getSize() {  
        return size;  
    }  
  
    private int hashIndex(int value) {  
        return value % capacity;  
    }  
  
    @Override  
    public String toString() {  
        return "MyHashSetV1{" +  
                "size=" + size +  
                ", capacity=" + capacity +  
                ", buckets=" + Arrays.toString(buckets) +  
                '}';  
    }  
}
```

- `buckets`: 연결 리스트를 배열로 사용한다.
	- 배열 안에 연결 리스트가 들어있고, 연결 리스트 안에 데이터가 저장된다.
	- 해시 인덱스가 충돌이 발생하면 같은 연결 리스트 안에 여러 데이터가 저장된다.
- `initBuckets()`: 인스턴스 생성 시점의 `capacity` 크기만큼의 연결 리스트를 생성해서 배열을 채운다. 배열의 모든 인덱스 위치에는 연결 리스트가 들어있다.
- `add()`: 해시 인덱스를 사용해서 데이터를 보관한다.
- `contains()`: 해시 인덱스를 사용해서 데이터를 확인한다.
- `remove()`: 해시 인덱스를 사용해서 데이터를 제거한다.

이미 해시 알고리즘을 학습할 때 대부분 작성해본 코드를 객체로 변경한 것이어서 이해하는데 큰 불편함은 없을 것이다.

`MyHashSetV1`은 해시 알고리즘을 사용한 덕분에 등록, 검색, 삭제 모두 평균 `O(1)`로 연산 속도를 크게 개선했다.

> [!warning] 남은 문제
> 해시 인덱스를 사용하려면 데이터의 값을 배열의 인덱스로 사용해야 한다. 그런데 배열의 인덱스는 0, 1, 2 같은 숫자만 사용할 수 있다. 
> 
> "A", "B"와 같은 문자열은 배열의 인덱스로 사용할 수 없다. 다음 예시와 같이 숫자가 아닌 문자열 데이터를 저장할 때, 해시 인덱스를 사용하려면 어떻게 해야할까?
> 
> ```java
> MyHashSetV1 set = new MyHashSetV1();
> 
> set.add("A");
> set.add("B");
> set.add("HELLO");
> ```

## 문자열 해시 코드
지금까지 해시 인덱스를 구할 때 숫자를 기반으로 해시 인덱스를 구했다. 해시 인덱스는 배열의 인덱스로 사용해야 하므로 `0`, `1`, `2` 같은 양의 숫자만 사용할 수 있다. 따라서 문자를 사용할 수 없다.

다음 코드를 통해서 문자를 숫자로 변경하는 방법을 알아본다.

```java
public class StringHashMain {  
    static final int CAPACITY = 10;  
  
    public static void main(String[] args) {  
        char charA = 'A';  
        char charB = 'B';  
  
        // char를 int로 타입 캐스팅  
        System.out.println("charA = " + (int) charA);  
        System.out.println("charB = " + (int) charB);  
  
        // hashCode  
        System.out.println("hashCode('A') = " + hashCode("A"));  
        System.out.println("hashCode('B') = " + hashCode("B"));  
        System.out.println("hashCode('C') = " + hashCode("AB"));  
  
        System.out.println("hashIndex(hashCode('A')) = " + hashIndex(hashCode("A")));  
        System.out.println("hashIndex(hashCode('B')) = " + hashIndex(hashCode("B")));  
        System.out.println("hashIndex(hashCode('AB')) = " + hashIndex(hashCode("AB")));  
    }  
  
    static int hashCode(String str) {  
        char[] charArray = str.toCharArray();  
        int sum = 0;  
        for (char c : charArray) {  
            sum += (int) c;  
        }  
        return sum;  
    }  
  
    static int hashIndex(int value) {  
        return value % CAPACITY;  
    }  
}
```

모든 문자는 본인만의 고유한 숫자로 표현할 수 있다. 예전에 C를 잠깐 학습해볼 때 이 내용과 연관있는 `ASCII`에 대해 배웠다.
예를 들어서 문자 `A`는 `65`, `B`는 `66`으로 표현된다. 단순하게는 `char`형을 `int`형으로 캐스팅하면 문자의 고유한 숫자를 확인할 수 있다.

이 숫자를 통해 해시 인덱스를 구하면 된다. `AB`와 같이 연속된 문자는 각각의 문자를 더하는 방식으로 숫자를 표현하면 된다. `65`와 `66`을 더하면 `131`이 된다.

![[해시코드-1.png]]
- `hashCode()`를 사용해서 문자열을 해시 코드로 변경한다. 그러면 고유한 정수 숫자 값이 나오는데 이것을 해시 코드라 한다.
- 숫자 값인 해시 코드를 사용해서 해시 인덱스를 생성한다.
- 이렇게 생성된 해시 인덱스를 배열의 인덱스로 사용하면 된다.
  
[[해시 함수]]에 대한 용어 정리는 해당 문서에서 확인할 수 있다.

> [!note] 정리
> 문자 데이터를 사용할 때도 해시 함수를 사용해서 정수 기반의 해시 코드로 변환한 덕분에, 해시 인덱스를 사용할 수 있게 되었다. 따라서 문자의 경우에도 해시 인덱스를 통해 빠르게 저장하고 조회할 수 있다.
> 
> 핵심은 해시 코드이다.
> 
> 세상의 어떤 객체든지 정수로 만든 해시 코드만 정의할 수 있다면 해시 인덱스를 사용할 수 있다. 그렇다면 문자 뿐만 아니라 내가 직접 만든 `Member`, `User`와 같은 객체는 어떻게 해시 코드를 정의할 수 있을까?

## 자바의 hashCode()



---
References: 김영한의 실전 자바 - 중급 2편

Links to this page: [[해시 알고리즘]], [[Set 자료구조]], [[해시 함수]]