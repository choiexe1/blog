---
title: 
tags:
  - java
  - programming
  - collection-framework
  - data-structure
publish: true
date: 2024-10-25
---
## 자바의 리스트 자료구조
앞서 계속해서 학습했듯 순서가 있고, 중복을 허용하는 자료구조를 리스트라 한다. 자바의 컬렉션 프레임워크가 제공하는 가장 대표적인 자료 구조가 바로 리스트이다. 리스트와 관련된 컬렉션 프레임워크는 다음과 같은 구조를 가진다.

### 컬렉션 프레임워크 - 리스트
![[자바의_리스트.png]]

`Collection` 인터페이스를 빼면 앞서 실제로 구현했던 구조와 동일하다. 물론 기능이나 성능엔 차이가 있을 수 있지만 구조나 핵심 부분은 거의 차이가 없다.

#### Collection 인터페이스

`Collection` 인터페이스는 `java.util` 패키지의 컬렉션 프레임워크의 핵심 인터페이스 중 하나이다. 이 인터페이스는 자바에서 다양한 컬렉션, 즉 데이터 그룹을 다루기 위한 메서드를 정의한다. `Collection` 인터페이스는 `List`, `Set`, `Queue`와 같은 다양한 하위 인터페이스와 함께 사용되며 이를 통해 데이터를 리스트, 세트, 큐등의 형태로 관리할 수 있다.

#### List 인터페이스
`List` 인터페이스는 `java.util` 패키지에 있는 컬렉션 프레임워크의 일부다. `List`는 객체들의 순서가 있는 컬렉션을 나타내며 같은 객체의 중복 저장을 허용한다. 리스트는 배열과 비슷하지만 크기가 동적으로 변화하는 컬렉션을 다룰 때 유연하게 사용할 수 있다. (아마 파이썬의 기본 제공 자료구조인 리스트와 동일한 개념인듯)

`List` 인터페이스는 `ArrayList`, `LinkedList`와 같은 여러 구현 클래스를 가지고 있으며, 각 클래스는 `List` 인터페이스와 메서드를 구현한다.

#### java.util.ArrayList
자바가 제공하는 `ArrayList`는 우리가 직접 만든 `MyArrayList`와 거의 비슷하다. 특징은 다음과 같다.
- 배열을 사용해서 데이터를 관리한다.
- 기본 `CAPACITY`가 10이다.
	- `CAPACITY`를 넘어가면 배열 크기가 50% 증가한다.
- 메모리 고속 복사 연산을 사용한다.
	- `ArrayList`의 중간 위치에 데이터를 추가하면 추가할 위치 이후의 모든 요소를 한 칸씩 뒤로 이동시킨다.
	- 자바가 제공하는 `ArrayList`는 이 부분을 최적화 하는데, 배열의 요소 이동은 시스템 레벨에서 최적화된 메모리 고속 복사 연산을 사용해서 비교적 빠르게 수행된다. 참고로 `System.arraycopy()`를 사용한다.


![[메모리_고속_복사연산.png]]
- 시스템 레벨에서 배열을 한 번에 아주 빠르게 복사한다. 이 부분은 OS, 하드웨어에 따라 성능이 다르기 때문에 정확한 측정이 어렵지만, 한 칸씩 이동하는 방식과 비교하면 보통 수 배 이상의 빠른 성능을 제공한다.


#### java.util.LinkedList
자바가 제공하는 `LinkedList`는 직접 만든 `MyLinkedList`와 거의 비슷하다. 특징은 다음과 같다.
- 이중 연결 리스트 구조
- 첫 번째 노드와 마지막 노드 둘 다 참조

우리가 직접 만든 `MyLinkedList`는 단일 연결 리스트 구조다. 따라서 이전 노드로 이동할 수 없었다.

![[자바_이중_연결_리스트.png]]
- 자바가 제공하는 `LinkedList`는 이중 연결 구조를 사용하여 다음 노드 뿐만 아니라, 이전 노드로도 이동할 수있다.
	- `node.next`를 호출하면 다음 노드로, `node.prev`를 호출하면 이전 노드로 이동한다.
- 마지막 노드에 대한 참조를 제공한다. 따라서 데이터를 마지막에 추가하는 경우에도 `O(1)`의 성능을 제공한다.
- 이전 노드로 이동할 수 있기 때문에 마지막 노드부터 앞으로, 역방향으로 조회할 수 있다.
	- 덕분에 인덱스 조회 성능을 최적화 할 수 있다.
	- 예를 들어 인덱스로 조회하는 경우 인덱스가 사이즈 절반 이하라면 처음부터 찾고, 절반 이상이라면 뒤에서부터 역방향으로 찾으면 성능을 최적화 할 수 있다.

## 자바 리스트의 성능 비교
```java
package collection.list;  
  
import java.util.ArrayList;  
import java.util.LinkedList;  
import java.util.List;  
  
public class JavaListPerformanceTest {  
    public static void main(String[] args) {  
        int size = 50_000;  
        System.out.println("==ArrayList 추가==");  
        addFirst(new ArrayList<>(), size);  
        addMid(new ArrayList<>(), size);  
          
        ArrayList<Integer> arrayList = new ArrayList<>(); //조회용 데이터로 사용  
        addLast(arrayList, size);  
        System.out.println("==LinkedList 추가==");  
        addFirst(new LinkedList<>(), size);  
        addMid(new LinkedList<>(), size);  
          
        LinkedList<Integer> linkedList = new LinkedList<>(); //조회용 데이터로 사용  
        addLast(linkedList, size);  
        int loop = 10000;  
          
        System.out.println("==ArrayList 조회==");  
        getIndex(arrayList, loop, 0);  
        getIndex(arrayList, loop, size / 2);  
        getIndex(arrayList, loop, size - 1);  
          
        System.out.println("==LinkedList 조회==");  
        getIndex(linkedList, loop, 0);  
        getIndex(linkedList, loop, size / 2);  
        getIndex(linkedList, loop, size - 1);  
          
        System.out.println("==ArrayList 검색==");  
        search(arrayList, loop, 0);  
        search(arrayList, loop, size / 2);  
        search(arrayList, loop, size - 1);  
          
        System.out.println("==LinkedList 검색==");  
        search(linkedList, loop, 0);  
        search(linkedList, loop, size / 2);  
        search(linkedList, loop, size - 1);  
    }  
    private static void addFirst(List<Integer> list, int size) {  
        long startTime = System.currentTimeMillis();  
        for (int i = 0; i < size; i++) {  
            list.add(0, i);  
        }  
        long endTime = System.currentTimeMillis();  
        System.out.println("앞에 추가 - 크기: " + size + ", 계산 시간: " + (endTime  
                - startTime) + "ms");  
    }  
    private static void addMid(List<Integer> list, int size) {  
        long startTime = System.currentTimeMillis();  
        for (int i = 0; i < size; i++) {  
            list.add(i / 2, i);  
        }  
        long endTime = System.currentTimeMillis();  
        System.out.println("평균 추가 - 크기: " + size + ", 계산 시간: " + (endTime  
                - startTime) + "ms");  
    }  
    private static void addLast(List<Integer> list, int size) {  
        long startTime = System.currentTimeMillis();  
        for (int i = 0; i < size; i++) {  
            list.add(i);  
        }  
        long endTime = System.currentTimeMillis();  
        System.out.println("뒤에 추가 - 크기: " + size + ", 계산 시간: " + (endTime  
                - startTime) + "ms");  
    }  
    private static void getIndex(List<Integer> list, int loop, int index) {  
        long startTime = System.currentTimeMillis();  
        for (int i = 0; i < loop; i++) {  
            list.get(index);  
        }  
        long endTime = System.currentTimeMillis();  
        System.out.println("index: " + index + ", 반복: " + loop + ", 계산 시간: "  
                + (endTime - startTime) + "ms");  
    }  
    private static void search(List<Integer> list, int loop, int findValue) {  
        long startTime = System.currentTimeMillis();  
        for (int i = 0; i < loop; i++) {  
            list.indexOf(findValue);  
        }  
        long endTime = System.currentTimeMillis();  
        System.out.println("findValue: " + findValue + ", 반복: " + loop +   
                        ", 계산 시간: " + (endTime - startTime) + "ms");  
    }  
}
```

직접 만든 배열 리스트와 연결 리스트 - 성능 비교 표

---
References: 

Links to this page: 