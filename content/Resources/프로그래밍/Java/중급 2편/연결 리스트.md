---
title: 
tags:
  - java
  - programming
  - collection-framework
  - data-structure
  - linked-list
publish: true
date: 2024-10-22
---
## 노드와 연결 1
[[배열과 배열 리스트#배열 리스트 (ArrayList)|배열 리스트]]의 단점은 데이터가 얼마나 추가될지 예측할 수 없는 경우 사용되지 않는 나머지 메모리 공간은 낭비된다.

배열의 중간에 데이터를 추가하거나 삭제하는 경우에도 한 칸씩 데이터를 옮겨야 하기 때문에 성능이 좋지 않다.

낭비되는 메모리 없이 딱 필요한 만큼만 메모리를 확보해서 사용하고, 또 앞이나 중간에 데이터를 추가하거나 삭제할 때도 효율적인 자료 구조가 있는데, 바로 노드를 만드록 각 노드를 서로 연결하는 방식이다.

```java
public class Node {
	Object item;
	Node next;
}
```

노드 클래스는 내부에 저장할 데이터인 `item`과 다음 연결할 노드의 참조인 `next`를 가진다. 이 노드 클래스 이용하면 아래 사진처럼 데이터 `A`, `B`, `C`를 연결 할 수 있다.

![[연결리스트-01.png]]
- `Node 0`은 첫번째 노드 인스턴스를 의미한다. `next`엔 `Node 1`의 참조값이 들어있다.
- 마찬가지로 `Node 1`의 `next`에는 `Node 2`의 참조값이 들어있다.

```java
public class Node {  
    Object item;  
    Node next;  
  
    public Node(Object item) {  
        this.item = item;  
    }  
}
```

```java
public static void main(String[] args) {  
    Node first = new Node("A");  
    first.next = new Node("B");  
    first.next.next = new Node("C");  
  
    System.out.println("모든 노드 탐색");  
    Node x = first;  
    while (x != null) {  
        System.out.println(x.item);  
        x = x.next;  
    }  
}
```

단순하게 만들어진 `Node` 클래스를 이용해서 모든 노드들의 아이템 값을 간단하게 접근할 수 있다.

- `x`가 `null`이 아닐 때 까지 자기 자신의 `item`을 표준 출력으로 출력하고 `x.next`를 통해 참조값을 다음 노드로 변경한다.

## 노드와 연결 2
노드의 연결 상태를 더 편하게 보기 위해 `toString()`을 오버라이딩 한다.

```java
//IDE 생성 toString() 
@Override 
public String toString() {
	return "Node{" + "item=" + item + ", next=" + next + '}'; 
}
```

```java
public static void main(String[] args) {  
    Node first = new Node("A");  
    first.next = new Node("B");  
    first.next.next = new Node("C");  
  
    System.out.println(first);  
}
```
예시 코드를 통해 출력해보면

```java
Node{item=A, next=Node{item=B, next=Node{item=C, next=null}}}
```
위 형태로 출력된다. 

`first`의 `next`를 출력하면 `Node`가 출력된다. 동일한 클래스인 `Node`는 마찬가지로 `toString()`이 오버라이딩 되어 있기 때문에 위와 같은 형태로 출력되는 것이다.

필요한 정보를 확인할 수는 있지만, 한 눈에 보기에는 조금 복잡하다. 대신에 `[A -> B -> C]`와 같이 필요한 정보만 편리하게 확인할 수 있게 `toString()`을 직접 구현해본다.

```java
@Override  
public String toString() {  
    StringBuilder sb = new StringBuilder();  
    Node x = this;  
  
    sb.append("[");  
    while (x != null) {  
        sb.append(x.item);  
        if (x.next != null) {  
            sb.append(" -> ");  
        }  
        x = x.next;  
    }  
    sb.append("]");  
  
    return sb.toString();  
}
```
- 직접 구현한 `toString()`은 연결된 모든 노드를 탐색해서 `item`을 `[A -> B -> C]`와 같은 형태로 출력한다.
- 반복문 안에서 문자를 더하기 때문에 `StringBuilder`를 사용하는 것이 효과적이다. 관련해서는 [[String 클래스#StringBuilder|StringBuilder]]를 참고할 수 있다.
- `while`을 사용해서 다음 노드가 없을 때 까지 반복한다.

## 노드와 연결 3
이번 섹션에선 노드와 연결을 활용해서 아래와 같은 다양한 기능을 만들어본다.
- 모든 노드 탐색
- 마지막 노드 조회
- 특정 인덱스의 노드 조회
- 노드에 데이터 추가

```java
public class NodeMain3 {  
    public static void main(String[] args) {  
        Node first = new Node("A");  
        first.next = new Node("B");  
        first.next.next = new Node("C");  
  
  
        // 모든 노드 탐색  
        printAll(first); // A, B, C  
  
        // 마지막 노드 조회  
        Node lastNode = getLastNode(first);  
        System.out.println(lastNode); // [C]  
  
        // 특정 인덱스 노드 조회  
        int index = 2;  
        Node index2Node = getNode(first, index);  
        System.out.println(index2Node); // [C]  
  
        // 데이터 추가  
        add(first, "D");  
        System.out.println(first); // [A->B->C->D]  
        add(first, "E");  
        System.out.println(first); // [A->B->C->D->E]  
        add(first, "F");  
        System.out.println(first); // [A->B->C->D->E->F]  
    }  
  
    private static void printAll(Node node) {  
        Node x = node;  
        while (x != null) {  
            System.out.println(x.item);  
            x = x.next;  
        }  
    }  
  
    private static Node getLastNode(Node node) {  
        Node x = node;  
        while (x.next != null) {  
            x = x.next;  
        }  
        return x;  
    }  
  
    private static Node getNode(Node node, int index) {  
        Node x = node;  
        for (int i = 0; i < index; i++) {  
            x = x.next;  
        }  
        return x;  
    }  
  
    private static void add(Node node, String param) {  
        Node lastNode = getLastNode(node);  
        lastNode.next = new Node(param);  
    }  
}
```

**모든 노드 탐색하기**

- `printAll(Node node)`: 마지막 노드가 없을 때 까지 반복해서 노드의 데이터를 출력한다.

**마지막 노드 조회하기**
- `Node getLastNode(Node node)`: 마지막 노드를 조회한다.
- `Node.next`의 참조값이 `null`이면 노드의 끝이다.
- `getLastNode()`는 노드를 순서대로 탐색하면서 `Node.next`의 참조값이 `null`인 노드를 찾아서 반환한다.

**특정 인덱스의 노드 조회하기**
- `getNode(Node node, int index)`: 인덱스로 특정 위치의 노드를 찾는다.
- `x = x.next`를 호출할 때 마다 `x`가 참조하는 노드의 위치가 순서대로 증가한다. 즉 루프로 `index`의 수 만큼 반복해서 이동하면 원하는 위치의 노드를 찾을 수 있다.

**데이터 추가하기**
- `add(Node node, String param)`: 마지막 노드에 새로 만든 노드를 연결한다.
- `getLastNode()`로 마지막 노드를 찾고, 마지막 노드의 `next`에 새로운 노드를 연결한다.

> [!note] 노드와 연결 핵심
>
> - 노드는 내부에 데이터와 다음 노드에 대한 참조를 가지고 있다.
> - 지금까지 설명한 구조는 각각의 노드가 참조를 통해 연결(Link)되어 있다.
> - 데이터를 추가할 때 동적으로 필요한 만큼의 노드만 만들어서 연결하면 된다. 따라서 배열과 다르게 메모리를 낭비하지 않는다.
> 	- 물론 `next` 필드를 통해 참조값을 보관해야 하기 때문에 배열과 비교해서 추가적인 메모리 낭비도 발생한다.
> - 이렇게 각각의 노드를 연결해서 사용하는 자료 구조로 리스트를 만들 수 있는데, 이것을 **연결 리스트라고 한다.**

---
References: 김영한의 실전 자바 - 중급 2편

Links to this page: 