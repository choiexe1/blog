---
title: 
tags:
  - java
  - programming
  - algorithm
  - data-structure
  - collection-framework
publish: true
date: 2024-10-26
---
## 해시 알고리즘 1
지금까지 공부한 자료구조에서는 데이터를 검색할 때 모든 데이터를 하나 하나 찾아야 했다.

해시(Hash) 알고리즘을 사용하면 데이터를 찾는 검색 성능을 평균 `O(1)`로 비약적으로 끌어 올릴 수 있다.

**해결해야 할 문제**

- 입력: 0~9 사이의 여러 값이 입력된다. 중복된 값은 입력되지 않는다.
- 찾기: 0~9 사이의 값이 하나 입력된다. 입력된 값 중에 찾는 값이 있는지 확인한다.

배열은 인덱스의 위치를 사용해서 데이터를 찾을 때 `O(1)`로 매우 빠른 성능을 가지고 있다. 반면에 데이터를 검색할 때는 배열에 들어있는 데이터를 하나하나 모두 비교해야 하므로 인덱스를 활용할 수 없다.

그런데 만약에 데이터를 검색할 때도 인덱스를 활용해서 데이터를 한 번에 찾을 수 있다면 어떻게 될까?
이렇게만 할 수 있다면 `O(n)`에서 `O(1)`로 성능을 끌어 올릴 수 있을 것이다.

![[해시-알고리즘-1.png]]

- **인덱스 0**: 1
- **인덱스 1**: 2
- **인덱스 2**: 5
- **인덱스 3**: 8

물론 인덱스와 데이터의 값은 서로 다르기 때문에 이것은 불가능해보인다. 여기서 생각의 틀을 완전히 뒤집어보자.


![[해시-알고리즘-2.png]]
데이터의 값 자체를 배열의 인덱스와 맞추어 저장하면 어떨까? 위 이미지처럼 값 자체를 배열의 인덱스로 사용하는 것이다.

이렇게 되면 인덱스 번호가 데이터가 되고, 데이터가 인덱스 번호가 되어 동일해진다. 이제 배열에서 인덱스 접근을 통해 검색 데이터를 `O(1)`로 찾을 수 있다.

```java title="적용 결과"
Integer[] inputArray = new Integer[10];  
  
inputArray[1] = 1;  
inputArray[2] = 2;  
inputArray[5] = 5;  
inputArray[8] = 8;  
System.out.println("inputArray = " + Arrays.toString(inputArray));  
  
int searchValue = 8;
int result = inputArray[searchValue];
System.out.println("result = " + result); // O(1)로 검색 결과를 찾아낸다.
```

> [!note] 정리
> 데이터의 값 자체를 배열의 인덱스로 사용해서, 검색 시 배열의 인덱스로 데이터를 찾을 수 있게 했다. 그 덕분에 `O(n)`의 성능을 `O(1)`로 획기적으로 개선 할 수 있었다.
> 
> 문제는 입력 값의 범위만큼 큰 배열을 사용해야 한다는 점이다. 따라서 배열에 낭비되는 메모리 공간이 많이 발생한다. 이 문제를 더 알아보자.

## 해시 알고리즘 2
이번에는 입력 값의 범위를 해결해야 할 문제 범위인 0~99로 넓힌다.

**해결해야 할 문제**

- 입력: 0~9 사이의 여러 값이 입력된다. 중복된 값은 입력되지 않는다.
- 찾기: 0~9 사이의 값이 하나 입력된다. 입력된 값 중에 찾는 값이 있는지 확인한다.

검색 속도를 높이기 위해 앞서 학습한 것 처럼 데이터의 값을 배열의 인덱스로 사용한다. 제시된 문제의 입력 값의 범위가 0~99이기 때문에 크기 100의 배열이 필요하다.

```java
public static void main(String[] args) {  
    Integer[] inputArray = new Integer[100];  
  
    inputArray[1] = 1;  
    inputArray[2] = 2;  
    inputArray[5] = 5;  
    inputArray[8] = 8;  
    inputArray[14] = 14;  
    inputArray[99] = 99;  
    System.out.println("inputArray = " + Arrays.toString(inputArray));  
  
    int searchValue = 99;  
    int result = inputArray[searchValue];  
    System.out.println("result = " + result);  
}
```

**한계**

- 데이터의 값을 인덱스로 사용한 덕분에 `O(1)`의 매우 빠른 속도 검색 속도를 얻을 수 있다. 하지만 낭비되는 메모리 공간이 너무 많다.
- 만약 `int` 숫자의 모든 범위를 입력할 수 있도록 하려면 배열의 크기를 얼마로 잡아야 할까?
- **4byte * 42억 = 약 17기가바이트**의 메모리가 필요하다.

데이터의 값을 인덱스로 사용 할 때, 입력할 수 있는 값의 범위가 `int`라면 한번의 연산에 최신 컴퓨터의 메모리가 거의 다 소모되어 버린다. 그리고 사용자가 1, 2, 1000, 200000의 네 개의 값만 입력하면 대부분의 공간이 빈 공간으로 낭비될 것이다.

뿐만 아니라 처음 배열을 생성하기 위해 메모리를 할당하는데도 너무 오랜 시간이 소모된다. 따라서 데이터의 값을 인덱스로 사용하는 방식은 입력 값의 범위가 넓다면 사용하기 어려워 보인다.

## 해시 알고리즘 3 (나머지 연산)
앞에서 이야기한 것 처럼 모든 숫자를 입력할 수 있다고 가정하면, 입력값의 범위가 너무 넓어져서 데이터의 값을 인덱스로 사용하기 어렵다. 더군다나 입력 값의 범위가 넓어져도 모든 공간을 사용하는 것이 아니라 낭비되는 공간이 존재한다.

공간도 절약하면서 넓은 범위의 값을 사용할 수 있는 방법이 있는데, 바로 **나머지 연산**을 활용하는 것이다. 저장할 수 있는 배열의 크기인 `CAPACITY`를 10이라고 가정한다. 그 크기에 맞추어 나머지 연산을 사용하면 된다.

- 1 % 10 = 1
- 2 % 10 = 2
- 5 % 10 = 5
- 8 % 10 = 8
- 14 % 10 = 4
- 99 % 10 = 9

여기서 14, 99는 10보다 큰 값이다. 따라서 일반적인 방법으로는 크기가 10인 배열의 인덱스로 사용할 수 없다.
하지만 나머지 연산의 결과를 사용하면 14는 4로, 99는 9로 크기가 10인 배열의 인덱스로 사용할 수 있다.

나머지 연산의 결과는 절대로 배열의 크기를 넘지 않는다. 따라서 연산 결과는 배열의 크기를 넘지 않으므로 안전하게 인덱스로 사용할 수 있다.

### 해시 인덱스
이렇게 배열의 인덱스로 사용할 수 있도록 원래의 값을 계산한 인덱스를 해시 인덱스(Hash Index)라고 한다.
14의 해시 인덱스는 4, 99의 해시 인덱스는 9이다.

이렇게 나머지 연산을 통해서 해시 인덱스를 구하고, 해시 인덱스를 배열의 인덱스로 사용해본다.

![[해시-인덱스.png]]
- `value % CAPACITY(10)`하여 나온 해시 인덱스를 배열의 인덱스로 사용한다.
- 인덱스만 해시 인덱스를 사용하고, 값은 원래 값을 저장한다.
- 배열의 인덱스를 사용하기 때문에 하나의 값을 저장하는데 `O(1)`로 빠른 성능을 제공한다.
	- 해시 인덱스 생성 
---
References: 김영한의 실전 자바 - 중급 2편

Links to this page: [[Set 자료구조]]