---
title: 
tags:
  - java
  - programming
  - algorithm
  - data-structure
  - collection-framework
publish: true
date: 2024-10-26
---
## 해시 알고리즘 1
지금까지 공부한 자료구조에서는 데이터를 검색할 때 모든 데이터를 하나 하나 찾아야 했다.

해시(Hash) 알고리즘을 사용하면 데이터를 찾는 검색 성능을 평균 `O(1)`로 비약적으로 끌어 올릴 수 있다.

**해결해야 할 문제**

- 입력: 0~9 사이의 여러 값이 입력된다. 중복된 값은 입력되지 않는다.
- 찾기: 0~9 사이의 값이 하나 입력된다. 입력된 값 중에 찾는 값이 있는지 확인한다.

배열은 인덱스의 위치를 사용해서 데이터를 찾을 때 `O(1)`로 매우 빠른 성능을 가지고 있다. 반면에 데이터를 검색할 때는 배열에 들어있는 데이터를 하나하나 모두 비교해야 하므로 인덱스를 활용할 수 없다.

그런데 만약에 데이터를 검색할 때도 인덱스를 활용해서 데이터를 한 번에 찾을 수 있다면 어떻게 될까?
이렇게만 할 수 있다면 `O(n)`에서 `O(1)`로 성능을 끌어 올릴 수 있을 것이다.

![[해시-알고리즘-1.png]]

- **인덱스 0**: 1
- **인덱스 1**: 2
- **인덱스 2**: 5
- **인덱스 3**: 8

물론 인덱스와 데이터의 값은 서로 다르기 때문에 이것은 불가능해보인다. 여기서 생각의 틀을 완전히 뒤집어보자.


![[해시-알고리즘-2.png]]
데이터의 값 자체를 배열의 인덱스와 맞추어 저장하면 어떨까? 위 이미지처럼 값 자체를 배열의 인덱스로 사용하는 것이다.

이렇게 되면 인덱스 번호가 데이터가 되고, 데이터가 인덱스 번호가 되어 동일해진다. 이제 배열에서 인덱스 접근을 통해 검색 데이터를 `O(1)`로 찾을 수 있다.

```java title="적용 결과"
Integer[] inputArray = new Integer[10];  
  
inputArray[1] = 1;  
inputArray[2] = 2;  
inputArray[5] = 5;  
inputArray[8] = 8;  
System.out.println("inputArray = " + Arrays.toString(inputArray));  
  
int searchValue = 8;
int result = inputArray[searchValue];
System.out.println("result = " + result); // O(1)로 검색 결과를 찾아낸다.
```

> [!note] 정리
> 데이터의 값 자체를 배열의 인덱스로 사용해서, 검색 시 배열의 인덱스로 데이터를 찾을 수 있게 했다. 그 덕분에 `O(n)`의 성능을 `O(1)`로 획기적으로 개선 할 수 있었다.
> 
> 문제는 입력 값의 범위만큼 큰 배열을 사용해야 한다는 점이다. 따라서 배열에 낭비되는 메모리 공간이 많이 발생한다. 이 문제를 더 알아보자.

## 해시 알고리즘 2
이번에는 입력 값의 범위를 

---
References: 김영한의 실전 자바 - 중급 2편

Links to this page: [[Set 자료구조]]