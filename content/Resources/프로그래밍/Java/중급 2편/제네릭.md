---
title: 
tags:
  - java
  - programming
  - generic
publish: true
date: 2024-10-12
---
## 제네릭 (Generic)
만약 특정 유형의 값을 보관하는 래퍼 클래스를 만들때, 같은 기능을 가진 여러 클래스를 만들어야 한다. 즉 같은 코드를 여러번 작성해야 한다. 예시로 `StringBox`, `IntegerBox`같은 클래스를 유형에 맞게 만들어야 하는 것이다.

다형성을 이용하여 `ObjectBox`를 만들고 이용하려해도 타입 안정성이 떨어지고, 다운 캐스팅을 해야하는 번거로움이 생긴다.

제네릭을 사용하면 코드 재사용과 타입 안정성이라는 두 마리 토끼를 다 잡을 수 있다.

```java title="제네릭 예제 1"
public class GenericBox<T> {  
  private T value;  
  
  public void set(T value) {  
    this.value = value;  
  }  
  
  public T get() {  
    return value;  
  }  
}
```
- 다이아몬드 기호(<>)를 사용한 클래스를 **제네릭 클래스**라고 한다.
- 제네릭 클래스를 사용할 때는 `Integer`나 `String`같은 타입을 미리 결정하지 않는다.
- 대신에 클래스명 오른쪽에 `<T>`와 같이 선언하면 제네릭 클래스가 된다. 여기서 **T**를 **타입 매개변수**라고 한다. 이 타입 매개변수는 이후에 `Integer`, `String`등의 타입으로 변할 수 있다.
- 그리고 클래스 내부에 `T` 타입이 필요한 곳에 `T value`와 같이 타입 매개변수를 적어주면 된다.

```java title="제네릭 예제 2"
public static void main(String[] args) {  
  GenericBox<Integer> integerBox = new GenericBox<Integer>();  
  integerBox.set(10);  
  Integer integer = integerBox.get();  
  
  GenericBox<String> stringBox = new GenericBox<>(); // 타입 추론
  stringBox.set("Hello");  
  String string = stringBox.get();  
  
  System.out.println("integer = " + integer);  
  System.out.println("string = " + string);  
}
```
- 제네릭 클래스는 선언 시점에 유형을 정해주어야 한다.
- 단, 원시 유형(primitive type)은 사용할 수 없다.
- `stringBox` 변수 선언 부분을 살펴보면, `new GenericBox<>()`로 타입 추론 기능을 이용한다. 생성하는 제네릭의 타입을 생략하는 것이다. 좌측의 변수 유형에 따라 추론 된다.

> [!note] 
> 참고로 제네릭을 도입한다고 해서 앞서 설명한 `GenericBox<String>` 또는 `GenericBox<Integer>`같은 코드가 실제 만들어지는 것이 아니다. 
> 
> 대신에 자바 컴파일러가 우리가 입력한 타입 정보를 기반으로 이런 코드가 있다고 가정하고 컴파일 과정에 타입 정보를 반영하는 것이다.

## 용어와 관례
제네릭의 핵심은 **사용할 타입을 미리 결정하지 않는다는 점**이다. 클래스 내부에서 사용하는 타입을 실제 사용하는 생성 시점에 결정하는 것이다.

즉 제네릭 클래스는 생성 시점에 **타입 인자**를 받아 **타입 매개변수**로 사용하는 것이다.
### 용어 정리
- **제네릭 (Generic)**
	- 제네릭이라는 단어는 일반적인, 범용적인이라는 뜻을 가진다.
	- 풀어보면 특정 타입에 속한 것이 아니라, 범용적으로 사용한다는 의미를 가진다.
- **제네릭 타입 (Generic Type)**
	- 클래스나 인터페이스를 정의할 때 타입 매개변수를 사용하는 것을 말한다.
	- 제네릭 클래스, 제네릭 인터페이스를 모두 합쳐서 제네릭 타입이라 한다.
- **타입 매개변수**: `GenericBox<T>`에서 `T`가 타입 매개변수
- **타입 인자**: 생성 시점의 `GenericBox<Integer>`에서 `Integer`가 타입 인수

### 제네릭 명명 관례
타입 매개변수는 일반적인 변수명처럼 소문자로 사용해도 문제는 없다. 하지만 일반적으로 대문자를 사용하고 용도에 맞는 단어의 첫 글자를 사용하는 관례를 따른다.

주로 사용하는 키워드는 다음과 같다.
- E - Element
- K - Key
- N - Number
- T - Type
- V - Value
- S, U, V etc. - 2nd, 3rd, 4th types

## 로 타입 (Raw type)
```java
GenericBox box = new GenericBox();
```
제네릭 클래스를 생성할 때 다이아몬드 기호 없이 위와 같이 생성할 수 있다. 이런 것을 로 타입 또는 원시 타입이라 한다.

로 타입을 사용하면 내부의 타입 매개변수가 `Object`로 사용된다.

제네릭 타입을 사용할 때는 항상 다이아몬드 기호(<>)를 사용하여 생성 시점에 타입을 지정해야 한다. 그런데 왜 이런 로 타입을 지원하는 것일까?

제네릭은 자바가 처음 등장할 때 부터 있던 것이 아니라, 오랜 기간 사용된 이후에 등장했기 때문에 제네릭이 없던 시절의 코드와 하위 호환이 필요했다. 그래서 어쩔 수 없이 로 타입을 지원한다.

> [!note]
> 정리하면 **로 타입을 사용하지 않아야 한다.** 만약에 `Object` 타입을 타입 매개변수로 사용해야 한다면 타입 인자로 `Object`를 지정해서 사용하면 된다.

## 타입 매개변수 제한
```java title="타입 매개변수 제한 예제 1"
public class AnimalHospitalV2<T> {  
  private T animal;  
  
  public void set(T animal) {  
    this.animal = animal;  
  }  
  
  public void checkUp() {  
    System.out.println("동물 이름: " + animal.getName());  
    System.out.println("동물 사이즈: " + animal.getSize());  
  }  
  
  public T bigger(T target) {  
    return animal.getSize() > target.getSize() ? animal : target;  
  }  
}
```

동물 병원 제네릭 클래스는 `checkUp()`을 통해 변수 `animal`에 접근하려고 한다. 그러나 타입 매개변수인 `T`가 생성 시점에 결정되기 때문에 `animal` 변수가 어떤 메서드들을 가졌는지 컴파일 타임엔 알 수 없다.

즉 `animal.getName()`과 같은 메서드에 접근할 수 없게 되는 것이다. 이런 경우 단순히 `Object`의 기능만을 사용할 수 있게 된다.

> [!warning]
> 제네릭 타입을 선언하면 자바 컴파일러 입장에서 `<T>`에 어떤 유형이 들어올 지 알 수 없다. 
> 
> 따라서 `<T>`를 어떤 타입이든 받을 수 있는 모든 객체의 최종 부모인 `Object` 타입으로 가정한다. 따라서 `Object`가 제공하는 메서드만 호출할 수 있다.

**문제**
- 제네릭에서 타입 매개변수를 사용하면 어떤 타입이든 들어올 수 있다.
- 따라서 타입 매개변수를 어떤 타입이든 수용할 수 있는 `Object`로 가정하고, `Object`의 기능만 사용할 수 있다.

최소한 `Animal` 클래스나 그 자식을 타입 인자로 제한할 수 있게 된다면 이 문제를 해결할 수 있다.

### 특정 타입으로 제한 (T extends Class)
```java title="특정 타입으로 제한 예제 1"
public class AnimalHospitalV3<T extends Animal> {  
  private T animal;  
  
  public void set(T animal) {  
    this.animal = animal;  
  }  
  
  public void checkUp() {  
     System.out.println("동물 이름: " + animal.getName());  
     System.out.println("동물 사이즈: " + animal.getSize());  
  }  
  
  public T bigger(T target) {  
    return animal.getSize() > target.getSize() ? animal : target;  
  }  
}
```

타입 매개변수를 특정 타입으로만 제한을 두는 것은 `extends` 키워드로 한다. 위 코드를 살펴보면 `<T extends Animal>`로 작성되었다. 위에서 얘기했듯 최소한 `Animal` 클래스나 그 자식을 타입 매개변수로써 받을 수 있게 된 것이다.

이렇게 되면 자바 컴파일러도 `T`의 유형을 추론할 수 있기 때문에, `Animal` 클래스의 메서드를 사용할 수 있게 된다.

## 제네릭 메서드 (Generic Method)
제네릭 메서드는 제네릭 타입과 달리 메서드 스코프 내에서 사용할 수 있는 제네릭이다. 즉 특정 메서드 내에서만 사용된다.

- 제네릭 메서드를 정의할 때는 반환 타입 왼쪽에 다이아몬드 기호(<>)를 사용해서 타입 매개변수를 적어준다.
- 제네릭 메서드를 사용할 때는 실제 호출 시점에 다이아몬드 기호(<>)를 사용해서 `<Integer>`와 같이 타입을 정하고 호출한다.

```java title="제네릭 메서드 정의 예제 1"
public class GenericMethod {  
  public static Object objectMethod(Object obj) {  
    System.out.println("Object print: " + obj);  
    return obj;  
  }  


  // 제네릭 메서드
  public static <T> T genericMethod(T obj) {  
    System.out.println("Generic print: " + obj);  
    return obj;  
  }  
}
```

마찬가지로 타입 매개변수 제한도 가능하다.

```java title="제네릭 메서드 타입 매개변수 제한 예제 1"
public static <T extends Number> T numberMethod(T t) {
	System.out.println("bound print: " + t);
	return t;
}
```

```java title="제네릭 메서드 사용 예제 1"
public static void main(String[] args) {  
  Integer i = 10;  
  Object object = GenericMethod.objectMethod(i);  
  
  System.out.println("명시적 타입 인자 전달");  
  Integer result = GenericMethod.<Integer>genericMethod(i);  
  Integer itegerValue = GenericMethod.<Integer>numberMethod(20);  
  Double doubleValue = GenericMethod.<Double>numberMethod(2.0);  

  System.out.println("타입 추론");
  Integer intValue = GenericMethod.numberMethod(1);  
}
```
제네릭 메서드를 사용할 때 마다, 매번 타입 인자를 전달하는 것은 불편하다. 변수의 타입을 통하여 컴파일러가 타입 추론이 가능하기 때문에 대부분 타입 추론을 사용한다.

참고로 제네릭 타입은 `static` 메서드에 타입 매개변수를 사용할 수 없다. 제네릭 타입은 객체를 생성하는 시점에 타입이 정해지기 때문이다.

그런데 `static` 메서드는 인스턴스 단위가 아니라 클래스 단위로 작동하기 때문에 제네릭 타입과는 무관하다. 따라서 `static` 메서드에 제네릭을 도입하려면 제네릭 메서드를 사용해야 한다.

```java
class Box<T> {
	T instanceMethod(T t) { ... } // 가능
	static T staticMethod(T t) { ... } // 제네릭 타입의 타입 매개변수 T 사용 불가능
}
```


실행 시점의 [[자바의 메모리 구조#메서드 영역|메서드 영역]]과 [[자바의 메모리 구조#힙 영역|힙 영역]]의 차이를 생각해보면 된다.

## 와일드카드 (Wildcard)
제네릭 타입을 조금 더 편리하게 사용 할 수 있는 와일드카드에 대해서 알아보자.


---
References: 김영한의 실전 자바 - 중급 2편

Links to this page: [[자바의 메모리 구조]]