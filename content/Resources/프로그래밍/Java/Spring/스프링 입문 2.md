---
title: 
tags:
  - java
  - programming
  - spring
publish: true
date: 2024-11-14
---
## H2 데이터베이스 설치
이 전 강의까지는 메모리에 회원의 정보를 저장해놓아서 서버가 재시작되면 모든 회원이 사라지는 문제가 발생했다. 이 문제를 해결하기 위해 데이터베이스를 사용한다.

H2 데이터베이스는 개발이나 테스트 용도로 가볍고 편리한 데이터베이스이고, 웹 화면도 제공한다.

H2 데이터베이스 설치 및 설정은 이 문서에서 설명 하지 않는다.

```sql
drop table if exists member CASCADE;
create table member (
id bigint generated by default as identity,
name varchar(255),
primary key (id)
);
```
설치와 설정이 모두 끝나면 위의 SQL문을 사용해서 멤버 테이블을 생성한다.

## 순수 JDBC
> [!warning]
> 이렇게 `JDBC API`로 직접 코딩하는 것은 20년 전 이야기이다. 따라서 고대 개발자들이 이렇게 고생하고 살았구나 생각하고 얼마나 힘들었는지 체험해보기 위한 과정이다. 정신건강을 위해 참고만 하고 넘어가자.

### 환경 설정
먼저 `build.gradle`에 `jdbc`와 `h2` 데이터베이스 관련 라이브러리를 추가해야 한다.

```
implementation 'org.springframework.boot:spring-boot-starter-jdbc'
runtimeOnly 'com.h2database:h2'
```

위 두 줄을 `build.gradle` 내의 `dependencies`에 추가한다. 그 후에 `resources/application.properties` 파일에 아래 내용을 추가한다. 아마 `properties` 파일이 `Node.js`에서 자주 사용했던 `.env`와 비슷한 환경변수 제공 파일인 것 같다.

```
spring.datasource.url=jdbc:h2:tcp://localhost/~/test  
spring.datasource.driver-class-name=org.h2.Driver  
spring.datasource.username=sa
```

마지막으로 새로운 라이브러리와 설정을 적용하려면 `gradle`을 다시 로드 해야한다.

### JDBC API로 MemberRepository 구현
앞서 `MemberRepository` 인터페이스를 작성해놓았으므로 해당 인터페이스를 구현하는 `JdbcMemberRepository` 클래스를 작성 해야한다.

강의에선 코드 작성 시간이 너무 오래걸리고, 구현 시간이 아까우므로 그냥 소스코드를 복사 붙여넣기 해서 설명한다.

```java title=""
@Override  
public Member save(Member member) {  
    String sql = "insert into member(name) values(?)";  
    Connection conn = null;  
    PreparedStatement pstmt = null;  
    ResultSet rs = null;  
    try {  
        conn = getConnection();  
        pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);  
        pstmt.setString(1, member.getName());  
        pstmt.executeUpdate();  
        rs = pstmt.getGeneratedKeys();  
        if (rs.next()) {  
            member.setId(rs.getLong(1));  
        } else {  
            throw new SQLException("id 조회 실패");  
        }  
        return member;  
    } catch (Exception e) {  
        throw new IllegalStateException(e);  
    } finally {  
        close(conn, pstmt, rs);  
    }  
}
```

단순히 저장만 하는 `save()`의 코드가 너무 장황하고, 너무나 많은 `Exception`을 던진다. 그리고 사용한 리소스들도 필수로 반환해야 한다.

다음은 `SpringConfig`을 수정한다. 현재 프로젝트는 직접 [[스프링 입문 1#직접 스프링 빈 등록|스프링 빈 등록]] 하는 방식으로 되어있다. 따라서 구현체가 변경되었기 때문에 `JdbcMemberRepository`로 변경해주어야 한다.

```java title="SpringConfig.java"
@Configuration  
public class SpringConfig {  
  
    private DataSource dataSource;  
  
    @Autowired  
    public SpringConfig(DataSource dataSource) {  
        this.dataSource = dataSource;  
    }  
  
    @Bean  
    public MemberRepository memberRepository() {  
        return new JdbcMemberRepository(dataSource);  
    }

	...
	
}
```

`DataSource`는 데이터베이스 커넥션을 획득할 때 사용하는 객체다. 스프링 부트는 데이터베이스 커넥션 정보를 바탕으로 `DataSource`를 생성하고 스프링 빈으로 만들어둔다. 따라서 `SpringConfig`에서 `@Autowired` 어노테이션으로 생성자 주입 받을 수 있게 된다.

![[spring-start-2.png]]

> [!note] 스프링을 사용하는 이유
> 방금과 같은 사례에서, 객체지향 설계의 장점을 보았다. 다형성을 활용해서 인터페이스를 두고 구현체만 변경하면 다른 코드들을 변경하지 않아도 된다.
> 
> 스프링은 개발자의 편의를 위해 이를 스프링 컨테이너로 지원한다. 소위 말하는 의존성 주입(Dependencies Injection) 덕분에 굉장히 편리하게 사용할 수 있게 한다.
> 
> 다형성을 활용하고, 스프링의 DI를 사용하면 기존 코드를 전혀 손대지 않고, 설정만으로 구현 클래스를 변경하는 것이다.
> 
> 마치 레고 블록을 조립하는 것과 비슷하다.

### 스프링 통합 테스트 작성
현재 작성된 테스트는 개별적인 유닛 테스트로 작성되어 있다. 스프링과 전혀 관련이 없다. 순수한 자바 코드와 메모리만을 이용하는 `MemoryMemberRepository`를 기반으로 되어있다. 

스프링 컨테이너와 H2 데이터베이스까지 연결한 통합 테스트를 작성한다.

```java
@SpringBootTest  
@Transactional  
class MemberServiceIntegrationTest {  
    @Autowired MemberService memberService;  
    @Autowired MemberRepository memberRepository;  
  
    @Test  
    void 회원가입() {  
        // Given  
        Member member = new Member();  
        member.setName("spring");  
  
        // When  
        Long saveId = memberService.join(member);  
  
        // Then  
        Member one = memberService.findOne(member.getId()).get();  
        assertThat(member.getName()).isEqualTo(one.getName());  
    }
    
    ...
}
```

- `@SpringBootTest`: 이 어노테이션을 적용하면 스프링 컨테이너와 테스트를 함께 실행한다.
- `@Transactional`: 테스트 케이스에 이 어노테이션을 적용하면, 테스트 시작 전에 트랜잭션을 시작하고 테스트 완료 후에 롤백한다. 이렇게하면 데이터베이스에 데이터가 남지 않으므로 다음 테스트에 영향을 주지 않는다.

데이터베이스를 수정하는 작업(추가, 수정, 삭제)을 할 때, 기본적으로 여러 단계가 존재한다.

---
References: 김영한의 스프링 입문

Links to this page: 