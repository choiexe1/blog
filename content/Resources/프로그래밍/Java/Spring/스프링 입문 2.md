---
title: 
tags:
  - java
  - programming
  - spring
publish: true
date: 2024-11-14
---
## H2 데이터베이스 설치
이 전 강의까지는 메모리에 회원의 정보를 저장해놓아서 서버가 재시작되면 모든 회원이 사라지는 문제가 발생했다. 이 문제를 해결하기 위해 데이터베이스를 사용한다.

H2 데이터베이스는 개발이나 테스트 용도로 가볍고 편리한 데이터베이스이고, 웹 화면도 제공한다.

H2 데이터베이스 설치 및 설정은 이 문서에서 설명 하지 않는다.

```sql
drop table if exists member CASCADE;
create table member (
id bigint generated by default as identity,
name varchar(255),
primary key (id)
);
```
설치와 설정이 모두 끝나면 위의 SQL문을 사용해서 멤버 테이블을 생성한다.

##  JDBC
> [!warning]
> 이렇게 `JDBC API`로 직접 코딩하는 것은 20년 전 이야기이다. 따라서 고대 개발자들이 이렇게 고생하고 살았구나 생각하고 얼마나 힘들었는지 체험해보기 위한 과정이다. 정신건강을 위해 참고만 하고 넘어가자.

### 환경 설정
먼저 `build.gradle`에 `jdbc`와 `h2` 데이터베이스 관련 라이브러리를 추가해야 한다.

```
implementation 'org.springframework.boot:spring-boot-starter-jdbc'
runtimeOnly 'com.h2database:h2'
```

위 두 줄을 `build.gradle` 내의 `dependencies`에 추가한다. 그 후에 `resources/application.properties` 파일에 아래 내용을 추가한다. 아마 `properties` 파일이 `Node.js`에서 자주 사용했던 `.env`와 비슷한 환경변수 제공 파일인 것 같다.

```
spring.datasource.url=jdbc:h2:tcp://localhost/~/test  
spring.datasource.driver-class-name=org.h2.Driver  
spring.datasource.username=sa
```

마지막으로 새로운 라이브러리와 설정을 적용하려면 `gradle`을 다시 로드 해야한다.

### 순수 JDBC API로 MemberRepository 구현
앞서 `MemberRepository` 인터페이스를 작성해놓았으므로 해당 인터페이스를 구현하는 `JdbcMemberRepository` 클래스를 작성 해야한다.

강의에선 코드 작성 시간이 너무 오래걸리고, 구현 시간이 아까우므로 그냥 소스코드를 복사 붙여넣기 해서 설명한다.

```java title=""
@Override  
public Member save(Member member) {  
    String sql = "insert into member(name) values(?)";  
    Connection conn = null;  
    PreparedStatement pstmt = null;  
    ResultSet rs = null;  
    try {  
        conn = getConnection();  
        pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);  
        pstmt.setString(1, member.getName());  
        pstmt.executeUpdate();  
        rs = pstmt.getGeneratedKeys();  
        if (rs.next()) {  
            member.setId(rs.getLong(1));  
        } else {  
            throw new SQLException("id 조회 실패");  
        }  
        return member;  
    } catch (Exception e) {  
        throw new IllegalStateException(e);  
    } finally {  
        close(conn, pstmt, rs);  
    }  
}
```

단순히 저장만 하는 `save()`의 코드가 너무 장황하고, 너무나 많은 `Exception`을 던진다. 그리고 사용한 리소스들도 필수로 반환해야 한다.

다음은 `SpringConfig`을 수정한다. 현재 프로젝트는 직접 [[스프링 입문 1#직접 스프링 빈 등록|스프링 빈 등록]] 하는 방식으로 되어있다. 따라서 구현체가 변경되었기 때문에 `JdbcMemberRepository`로 변경해주어야 한다.

```java title="SpringConfig.java"
@Configuration  
public class SpringConfig {  
  
    private DataSource dataSource;  
  
    @Autowired  
    public SpringConfig(DataSource dataSource) {  
        this.dataSource = dataSource;  
    }  
  
    @Bean  
    public MemberRepository memberRepository() {  
        return new JdbcMemberRepository(dataSource);  
    }

	...
	
}
```

`DataSource`는 데이터베이스 커넥션을 획득할 때 사용하는 객체다. 스프링 부트는 데이터베이스 커넥션 정보를 바탕으로 `DataSource`를 생성하고 스프링 빈으로 만들어둔다. 따라서 `SpringConfig`에서 `@Autowired` 어노테이션으로 생성자 주입 받을 수 있게 된다.

![[spring-start-2.png]]

> [!note] 스프링을 사용하는 이유
> 방금과 같은 사례에서, 객체지향 설계의 장점을 보았다. 다형성을 활용해서 인터페이스를 두고 구현체만 변경하면 다른 코드들을 변경하지 않아도 된다.
> 
> 스프링은 개발자의 편의를 위해 이를 스프링 컨테이너로 지원한다. 소위 말하는 의존성 주입(Dependencies Injection) 덕분에 굉장히 편리하게 사용할 수 있게 한다.
> 
> 다형성을 활용하고, 스프링의 DI를 사용하면 기존 코드를 전혀 손대지 않고, 설정만으로 구현 클래스를 변경하는 것이다.
> 
> 마치 레고 블록을 조립하는 것과 비슷하다.

### 스프링 통합 테스트 작성
현재 작성된 테스트는 개별적인 유닛 테스트로 작성되어 있다. 스프링과 전혀 관련이 없다. 순수한 자바 코드와 메모리만을 이용하는 `MemoryMemberRepository`를 기반으로 되어있다. 

스프링 컨테이너와 H2 데이터베이스까지 연결한 통합 테스트를 작성한다.

```java
@SpringBootTest  
@Transactional  
class MemberServiceIntegrationTest {  
    @Autowired MemberService memberService;  
    @Autowired MemberRepository memberRepository;  
  
    @Test  
    void 회원가입() {  
        // Given  
        Member member = new Member();  
        member.setName("spring");  
  
        // When  
        Long saveId = memberService.join(member);  
  
        // Then  
        Member one = memberService.findOne(member.getId()).get();  
        assertThat(member.getName()).isEqualTo(one.getName());  
    }
    
    ...
}
```

- `@SpringBootTest`: 이 어노테이션을 적용하면 스프링 컨테이너와 테스트를 함께 실행한다.
- `@Transactional`: 테스트 케이스에 이 어노테이션을 적용하면, 테스트 시작 전에 트랜잭션을 시작하고 테스트 완료 후에 항상 롤백한다. 테스트 메서드 하나 하나마다 롤백 되는 것이다. 이렇게하면 데이터베이스에 데이터가 남지 않으므로 다음 테스트에 영향을 주지 않으므로 반복 실행이 가능해진다.

데이터베이스는 수정하는 작업(추가, 수정, 삭제)을 할 때 수정되기 전 `COMMIT`이라는 단계가 존재한다. 수정하는 작업을 완료하기 전에 `COMMIT`을 하지 않으면 데이터베이스에 적용이 되지 않는다.

### 스프링 JdbcTemplate
스프링 `JdbcTemplate`과 `MyBatis`같은 라이브러리는 `JDBC API`에서 본 반복 코드를 대부분 제거해준다. 하지만 `SQL`은 직접 작성해야 한다.

```java
public class JdbcTemplateMemberRepository implements MemberRepository {  
    private final JdbcTemplate jdbcTemplate;  
  
    public JdbcTemplateMemberRepository(DataSource dataSource) {  
        this.jdbcTemplate = new JdbcTemplate(dataSource);  
    }  
  
    @Override  
    public Optional<Member> findById(Long id) {  
        List<Member> result = jdbcTemplate.query("select * from member where id = ?", memberRowMapper());  
  
        return result.stream().findAny();  
    }  
  
    private RowMapper<Member> memberRowMapper() {  
        return (rs, rowNum) -> {  
            Member member = new Member();  
            member.setId(rs.getLong("id"));  
            member.setName(rs.getString("name"));  
  
            return member;  
        };  
    }
    
    ...
}
```

- 생성자가 하나일 경우, 의존성 주입 어노테이션인 `@Autowired`를 생략할 수 있다.

이 전의 `JdbcMemberRepository`에 비해서 코드가 엄청나게 줄어든 것을 확인했다. `JdbcTemplate`는 디자인 패턴 중 템플릿 메서드 패턴을 이용했다고 한다. 

`memberRowMapper()`는 결과인 `row` 값들을 멤버 객체로 변환하고 맵핑해주는 메서드다. 줄이고 줄였으나 그래도 `ORM`이 그립다.

## JPA (Java Persistence API)
앞서 순수한 `JDBC`의 코드, `JDBC Template`를 사용한 코드 두 가지를 모두 살펴보았다. `JPA`는 두 가지가 가진 반복 코드나 `SQL` 작성등의 문제를 모두 해결하여 `SQL`과 데이터 중심의 설계에서 객체 중심의 설계로 패러다임을 전환한다.

이 `JPA`를 사용하면 개발 생산성을 크게 높일 수 있다.

> [!tip] Java Persistence API
> - JPA는 자바 ORM 기술에 대한 표준 명세로, JAVA에서 제공하는 API이다. 스프링에서 제공하는것이 아니다.
> - 자바 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스다.
> - 여기서 중요한건 JPA는 말 그대로 인터페이스이다.
> - ORM을 사용하기 위한 인터페이스를 모아둔 것이며, JPA를 사용하기 위해서는 JPA를 구현한 Hibernate 같은 ORM 프레임워크를 사용해야한다.

### 환경 설정 
JPA를 사용하기 위해서는 `build.gradle`의 `dependencies`에 라이브러리를 추가해야 한다.

```
implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
```

그리고 이 전에 추가했던 `implementation 'org.springframework.boot:spring-boot-starter-jdbc'`는 지운다. 추가한 `JPA` 라이브러리에 포함되어 있는 라이브러리이기 때문이다.

그 후에 `application.properties`에 `JPA` 관련 설정을 해주어야 한다.

```
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=none
```

- `spring.jpa.show-sql=true`: `JPA`가 생성하는 SQL을 출력한다.
- `spring.jpa.hibernate.ddl-auto=none`: `JPA`는 테이블을 자동으로 생성하는 기능을 제공하는데, `none` 을 사용하면 해당 기능을 끈다.
	- `create`를 사용하면 엔티티 정보를 바탕으로 테이블도 직접 생성해준다.

### 엔티티 맵핑


---
References: 김영한의 스프링 입문

Links to this page: 