---
title: 
tags:
  - java
  - programming
  - spring
  - test
  - database
publish: true
date: 2024-12-15
---
## 테스트 - 데이터베이스 연동
데이터 접근 기술에 대해서 더 알아보기 전에 데이터베이스에 연동하는 테스트에 대해서 알아본다. 데이터 접근 기술은 실제 데이터베이스에 접근해서 데이터를 잘 저장하고 조회할 수 있는지 확인하는 것이 필요하다.

지금부터 테스트를 실행할 때 실제 데이터베이스를 연동해서 진행해본다. 앞서 개발한 `ItemRepositoryTest`를 통해서 테스트를 진행한다.

테스트를 실행하기 전에 먼저 지금까지 설정한 `application.properties`를 확인해보자.

```properties title="main/application.properties"
spring.profiles.active=local  
spring.datasource.url=jdbc:h2:tcp://localhost/~/test  
spring.datasource.username=sa  
spring.datasource.password=  
logging.level.org.springframework.jdbc=debug
```

다음으로 `test/application.properties`를 확인해본다.

```properties title="test/application.properties"
spring.profiles.active=test
```

테스트 케이스는 `src/test` 경로에 있기 때문에 실행하면 `src/test`에 있는 `application.properties` 파일이 우선 순위를 가지고 실행된다.

그런데 문제는 테스트용 설정에는 `spring.datasource.url`과 같은 데이터베이스 연결 설정이 없다는 점이다. 테스트 케이스에서도 데이터베이스에 접속할 수 있게 `test/application.properties`를 다음과 같이 수정하자.

```properties title="test/application.properties"
spring.profiles.active=test  
spring.datasource.url=jdbc:h2:tcp://localhost/~/test  
spring.datasource.username=sa  
spring.datasource.password=  
logging.level.org.springframework.jdbc=debug
```

## 테스트 실행 - 로컬 DB
`ItemRepositoryTest` 테스트 코드를 확인해보자.

```java
@SpringBootTest  
class ItemRepositoryTest {
```

`ItemRepositoryTest`는 `@SpringBootTest`를 사용한다. `@SpringBootTest`는 `@SpringBootApplication`을 찾아서 설정으로 사용한다.

예를 들면 현재는 다음과 같은 `@SpringBootApplication`을 사용한다.

```java title="ItemServiceApplication.java"
@Import(JdbcTemplateV3Configure.class)  
@SpringBootApplication(scanBasePackages = "hello.itemservice.web")  
public class ItemServiceApplication {  
  
    public static void main(String[] args) {  
        SpringApplication.run(ItemServiceApplication.class, args);  
    }  
  
    @Bean  
    @Profile("local")  
    public TestDataInit testDataInit(ItemRepository itemRepository) {  
        return new TestDataInit(itemRepository);  
    }  
}
```

따라서 현재 테스트를 실행하면, `ItemServiceApplication`에 적용된 설정을 가지고, 테스트를 실행하게 된다. 따라서 테스트도 현재 설정에 따라서 `JdbcTemplate`을 통해 실제 데이터베이스를 호출하게 된다.

먼저 테스트 코드 전체를 실행해본다.

```java
@SpringBootTest  
class ItemRepositoryTest {  
  
    @Autowired  
    ItemRepository itemRepository;  
  
    @AfterEach  
    void afterEach() {  
        //MemoryItemRepository 의 경우 제한적으로 사용  
        if (itemRepository instanceof MemoryItemRepository) {  
            ((MemoryItemRepository) itemRepository).clearStore();  
        }  
    }  
  
    @Test  
    void save() {  
        //given  
        Item item = new Item("itemA", 10000, 10);  
  
        //when  
        Item savedItem = itemRepository.save(item);  
  
        //then  
        Item findItem = itemRepository.findById(item.getId()).get();  
        assertThat(findItem).isEqualTo(savedItem);  
    }  
  
    @Test  
    void updateItem() {  
        //given  
        Item item = new Item("item1", 10000, 10);  
        Item savedItem = itemRepository.save(item);  
        Long itemId = savedItem.getId();  
  
        //when  
        ItemUpdateDto updateParam = new ItemUpdateDto("item2", 20000, 30);  
        itemRepository.update(itemId, updateParam);  
  
        //then  
        Item findItem = itemRepository.findById(itemId).get();  
        assertThat(findItem.getItemName()).isEqualTo(updateParam.getItemName());  
        assertThat(findItem.getPrice()).isEqualTo(updateParam.getPrice());  
        assertThat(findItem.getQuantity()).isEqualTo(updateParam.getQuantity());  
    }  
  
    @Test  
    void findItems() {  
        //given  
        Item item1 = new Item("itemA-1", 10000, 10);  
        Item item2 = new Item("itemA-2", 20000, 20);  
        Item item3 = new Item("itemB-1", 30000, 30);  
  
        itemRepository.save(item1);  
        itemRepository.save(item2);  
        itemRepository.save(item3);  
  
        //둘 다 없음 검증  
        test(null, null, item1, item2, item3);  
        test("", null, item1, item2, item3);  
  
        //itemName 검증  
        test("itemA", null, item1, item2);  
        test("temA", null, item1, item2);  
        test("itemB", null, item3);  
  
        //maxPrice 검증  
        test(null, 10000, item1);  
  
        //둘 다 있음 검증  
        test("itemA", 10000, item1);  
    }  
  
    void test(String itemName, Integer maxPrice, Item... items) {  
        List<Item> result = itemRepository.findAll(new ItemSearchCond(itemName, maxPrice));  
        assertThat(result).containsExactly(items);  
    }  
}
```

테스트 코드를 실행해보면 `updateItem()`, `save()`는 테스트에 통과하지만 `findItems()`는 실패한다. 

**실패 원인**

왜 이런 문제가 발생하는 것일까?

혹시 테스트를 실행할 때 `TestDataInit`이 실행되는 것은 아닐까? 이 문제는 아니다. `TestDataInit`은 프로필이 `local`일 때만 동작한다.

문제는 H2 데이터베이스가 이미 과거에 서버를 실행하면서 저장했던 데이터가 보관되어 있기 때문이다. 이 데이터가 현재 테스트에 영향을 주고 있다.

## 테스트 - 데이터베이스 분리
로컬에서 사용하는 어플리케이션 서버와 테스트에서 같은 데이터베이스를 사용하고 있으므로 테스트에서 문제가 발생한다.

이런 문제를 해결하려면 테스트를 다른 환경과 철저하게 분리해야 한다.

가장 간단한 방법은 테스트 전용 데이터베이스를 별도로 운영하는 것이다.
- `jdbc:h2:tcp://localhost/~/test` local에서 접근하는 서버 전용 데이터베이스
- `jdbc:h2:tcp://localhost/~/testcase` test 케이스에서 사용하는 전용 데이터베이스

H2로 `testcase` 서버를 생성하고 다음의 SQL을 실행해 `item` 테이블을 생성한다.

```sql
DROP TABLE IF EXISTS item CASCADE;
CREATE TABLE item
(
	id bigint GENERATED BY DEFAULT AS IDENTITY,
	item_name varchar(10),
	price integer,
	quantity integer,
	PRIMARY KEY (id)
);
```

이제 앞서 설정했던 접속 정보를 변경한다. 참고로 `test`에 있는 `application.properties`만 변경해야 한다.

```properties title="test/application.properties"
spring.profiles.active=test  
spring.datasource.url=jdbc:h2:tcp://localhost/~/testcase  
spring.datasource.username=sa  
spring.datasource.password=  
logging.level.org.springframework.jdbc=debug
```

그런데 가장 중요한 이유로 이렇게까지 하는 이유가 무엇일까?

테스트에서 매우 중요한 원칙은 다음과 같다.

- 테스트는 다른 테스트와 격리되어 실행되어야 한다.
- 테스트는 반복해서 실행할 수 있어야 한다.

물론 테스트가 끝날 때 마다 추가한 데이터에 삭제 SQL을 사용해도 되겠지만, 이 방법도 궁극적인 해결책은 아니다. 만약 테스트 과정에서 이미 데이터를 추가 했는데, 테스트가 실행되는 도중에 예외가 발생하거나 어플리케이션이 종료되어 버려서 테스트 종료 시점에 삭제 SQL을 실행하지 못할 수도 있다.

이런 문제를 어떻게 해결할 수 있을까?

## 테스트 - 데이터 롤백
이 때 도움이 되는 것이 바로 [[3. 트랜잭션 이해|트랜잭션]]이다. 테스트가 끝나고 나서 트랜잭션을 강제로 롤백해버리면 데이터가 깔끔하게 제거된다.

테스트를 하면서 이미 데이터를 저장했는데, 중간에 테스트가 실패해서 롤백을 호출하지 못해도 괜찮다. 트랜잭션을 커밋하지 않았기 때문에 데이터베이스에 해당 데이터가 반영되지 않는다.

이렇게 트랜잭션을 활용하면 테스트가 끝나고 나서 데이터를 깔끔하게 원래 상태로 되돌릴 수 있다.

예를 들어서 다음 순서와 같이 각각의 테스트 실행 직전에 트랜잭션을 시작하고, 테스트 실행 직후 트랜잭션을 롤백해야 한다. 그래야 다음 테스트에 데이터로 인한 영향을 주지 않는다.

```mermaid
graph
1["트랜잭션 시작"]
2[테스트 A 실행]
```


---
References: 김영한의 스프링 DB 2편

Links to this page: [[3. 트랜잭션 이해]]