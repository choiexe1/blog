---
title: 
tags:
  - java
  - programming
  - spring
  - test
  - database
publish: true
date: 2024-12-15
---
## 테스트 - 데이터베이스 연동
데이터 접근 기술에 대해서 더 알아보기 전에 데이터베이스에 연동하는 테스트에 대해서 알아본다. 데이터 접근 기술은 실제 데이터베이스에 접근해서 데이터를 잘 저장하고 조회할 수 있는지 확인하는 것이 필요하다.

지금부터 테스트를 실행할 때 실제 데이터베이스를 연동해서 진행해본다. 앞서 개발한 `ItemRepositoryTest`를 통해서 테스트를 진행한다.

테스트를 실행하기 전에 먼저 지금까지 설정한 `application.properties`를 확인해보자.

```properties title="main/application.properties"
spring.profiles.active=local  
spring.datasource.url=jdbc:h2:tcp://localhost/~/test  
spring.datasource.username=sa  
spring.datasource.password=  
logging.level.org.springframework.jdbc=debug
```

다음으로 `test/application.properties`를 확인해본다.

```properties title="test/application.properties"
spring.profiles.active=test
```

테스트 케이스는 `src/test` 경로에 있기 때문에 실행하면 `src/test`에 있는 `application.properties` 파일이 우선 순위를 가지고 실행된다.

그런데 문제는 테스트용 설정에는 `spring.datasource.url`과 같은 데이터베이스 연결 설정이 없다는 점이다. 테스트 케이스에서도 데이터베이스에 접속할 수 있게 `test/application.properties`를 다음과 같이 수정하자.

```properties title="test/application.properties"
spring.profiles.active=test  
spring.datasource.url=jdbc:h2:tcp://localhost/~/test  
spring.datasource.username=sa  
spring.datasource.password=  
logging.level.org.springframework.jdbc=debug
```

## 테스트 실행 - 로컬 DB
`ItemRepositoryTest` 테스트 코드를 확인해보자.

```java
@SpringBootTest  
class ItemRepositoryTest {
```

`ItemRepositoryTest`는 `@SpringBootTest`를 사용한다. `@SpringBootTest`는 `@SpringBootApplication`을 찾아서 설정으로 사용한다.

예를 들면 현재는 다음과 같은 `@SpringBootApplication`을 사용한다.

```java title="ItemServiceApplication.java"
@Import(JdbcTemplateV3Configure.class)  
@SpringBootApplication(scanBasePackages = "hello.itemservice.web")  
public class ItemServiceApplication {  
  
    public static void main(String[] args) {  
        SpringApplication.run(ItemServiceApplication.class, args);  
    }  
  
    @Bean  
    @Profile("local")  
    public TestDataInit testDataInit(ItemRepository itemRepository) {  
        return new TestDataInit(itemRepository);  
    }  
}
```

따라서 현재 테스트를 실행하면, `ItemServiceApplication`에 적용된 설정을 가지고, 테스트를 실행하게 된다. 따라서 테스트도 현재 설정에 따라서 `JdbcTemplate`을 통해 실제 데이터베이스를 호출하게 된다.

먼저 테스트 코드 전체를 실행해본다.

```java
@SpringBootTest  
class ItemRepositoryTest {  
  
    @Autowired  
    ItemRepository itemRepository;  
  
    @AfterEach  
    void afterEach() {  
        //MemoryItemRepository 의 경우 제한적으로 사용  
        if (itemRepository instanceof MemoryItemRepository) {  
            ((MemoryItemRepository) itemRepository).clearStore();  
        }  
    }  
  
    @Test  
    void save() {  
        //given  
        Item item = new Item("itemA", 10000, 10);  
  
        //when  
        Item savedItem = itemRepository.save(item);  
  
        //then  
        Item findItem = itemRepository.findById(item.getId()).get();  
        assertThat(findItem).isEqualTo(savedItem);  
    }  
  
    @Test  
    void updateItem() {  
        //given  
        Item item = new Item("item1", 10000, 10);  
        Item savedItem = itemRepository.save(item);  
        Long itemId = savedItem.getId();  
  
        //when  
        ItemUpdateDto updateParam = new ItemUpdateDto("item2", 20000, 30);  
        itemRepository.update(itemId, updateParam);  
  
        //then  
        Item findItem = itemRepository.findById(itemId).get();  
        assertThat(findItem.getItemName()).isEqualTo(updateParam.getItemName());  
        assertThat(findItem.getPrice()).isEqualTo(updateParam.getPrice());  
        assertThat(findItem.getQuantity()).isEqualTo(updateParam.getQuantity());  
    }  
  
    @Test  
    void findItems() {  
        //given  
        Item item1 = new Item("itemA-1", 10000, 10);  
        Item item2 = new Item("itemA-2", 20000, 20);  
        Item item3 = new Item("itemB-1", 30000, 30);  
  
        itemRepository.save(item1);  
        itemRepository.save(item2);  
        itemRepository.save(item3);  
  
        //둘 다 없음 검증  
        test(null, null, item1, item2, item3);  
        test("", null, item1, item2, item3);  
  
        //itemName 검증  
        test("itemA", null, item1, item2);  
        test("temA", null, item1, item2);  
        test("itemB", null, item3);  
  
        //maxPrice 검증  
        test(null, 10000, item1);  
  
        //둘 다 있음 검증  
        test("itemA", 10000, item1);  
    }  
  
    void test(String itemName, Integer maxPrice, Item... items) {  
        List<Item> result = itemRepository.findAll(new ItemSearchCond(itemName, maxPrice));  
        assertThat(result).containsExactly(items);  
    }  
}
```

테스트 코드를 실행해보면 `updateItem()`, `save()`는 테스트에 통과하지만 `findItems()`는 실패한다. 

**실패 원인**

왜 이런 문제가 발생하는 것일까?

혹시 테스트를 실행할 때 `TestDataInit`이 실행되는 것은 아닐까? 이 문제는 아니다. `TestDataInit`은 프로필이 `local`일 때만 동작한다.

문제는 H2 데이터베이스가 이미 과거에 서버를 실행하면서 저장했던 데이터가 보관되어 있기 때문이다. 이 데이터가 현재 테스트에 영향을 주고 있다.

## 테스트 - 데이터베이스 분리
로컬에서 사용하는 어플리케이션 서버와 테스트에서 같은 데이터

---
References: 김영한의 스프링 DB 2편

Links to this page: 