---
title: 
tags:
  - java
  - spring
  - database
  - spring-data-jpa
  - jpa
publish: true
date: 2024-12-26
---
## 스프링 데이터 JPA 예제와 트레이드 오프

다시 [[6. 스프링 데이터 JPA]]를 되돌아보면, 다음과 같이 `jpaItemRepositoryV2`가 어댑터 역할을 해준 덕분에 `itemService`의 코드 변경 없이 구현체를 변경할 수 있었다.

```mermaid
graph LR

ItemService --> jpaItemRepositoryV2 --> ProxySpringDataJPA
```

- 문제는 이런 구조를 맞추기 위해서(서비스 레이어가 외부 의존성을 갖지  않기 위해서) 중간에 어댑터가 들어가면서 전체 구조가 복잡해지고, 사용하는 클래스도 많아지는 단점이 생겼다.
- 실제 이 코드를 구현해야 하는 개발자 입장에서 보면 중간에 어댑터도 만들고, 실제 코드까지 만들어야 하는 불편함이 생긴다.
- 유지보수적 관점에서 `ItemService`를 변경하지 않고 `ItemRepository`의 구현체를 변경할 수 있는 장점이 있다. 그러니까 DI, OCP 원칙을 지킬 수 있다는 좋은 점은 있지만 반대로 구조가 복잡해지면서 어댑터 코드와 실제 코드까지 함께 유지보수 해야 하는 어려움도 발생한다.

쉽게 말해서 다음과 같은 트레이드 오프가 존재한다.
- 어댑터 패턴을 활용해서 `itemService` 코드의 변경 없이 사용하지만, 어플리케이션 구조가 복잡해진다. (유지보수가 어려워짐)
- `itemService`가 직접적으로 `jpaItemRepositoryV2`를 의존하고 코드도 변경해야 하지만, 어플리케이션 구조가 단순해진다. (유지보수가 쉬워짐)

어플리케이션 구조의 안정성 vs 단순한 구조와 개발의 편리성 사이의 선택이다. 이 둘 중에 어느 것 하나가 정답이라고 할 순 없지만 어설픈 추상화는 오히려 독이 되는 경우가 많다. 무엇보다 추상화도 비용이 든다.

여기서 말하는 비용이란 유지보수 관점에서의 비용을 뜻한다. 이 추상화 비용을 넘어설 만큼 효과가 있을 때 추상화를 도입하는 것이 실용적이다.

## 실용적인 구조
앞서 [[7. Querydsl]]를 사용한 리포지토리는 `스프링 데이터 JPA`를 사용하지 않고 `JPA`만 사용했다. 이번에는 `스프링 데이터 JPA`의 기능은 최대한 살리면서 `Querydsl`도 편리하게 사용할 수 있는 다음과 같은 구조로 만들어본다.




---
References: 김영한의 스프링 DB 2편

Links to this page: [[6. 스프링 데이터 JPA]]