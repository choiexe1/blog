---
title: 
tags:
  - java
  - programming
  - spring
  - transaction
  - propagation
publish: true
date: 2024-12-28
---
## 트랜잭션 전파 활용 1 - 예제 프로젝트
지금까지 학습한 트랜잭션 전파에 대한 내용을 실제 예제를 통해서 이해해본다.

**비즈니스 요구사항**
- 회원을 등록하고 조회한다.
- 회원에 대한 변경 이력을 추적할 수 있도록 회원 데이터가 변경될 때 변경 이력을 DB LOG 테이블에 남겨야 한다.
	- 예제를 단순화 하기 위해 회원 등록시에만 DB LOG 테이블에 남긴다.

```java
@Entity  
@Getter  
@Setter  
public class Member {  
    @Id  
    @GeneratedValue    private Long id;  
  
    private String username;  
  
    public Member() {  
    }  
  
    public Member(String username) {  
        this.username = username;  
    }  
}

@Entity  
@Getter  
@Setter  
public class Log {  
    @Id  
    @GeneratedValue    private Long id;  
    private String message;  
  
    public Log() {  
    }  
  
    public Log(String message) {  
        this.message = message;  
    }  
}

@Slf4j  
@Repository  
@RequiredArgsConstructor  
public class MemberRepository {  
    private final EntityManager em;  
  
    @Transactional  
    public void save(Member member) {  
        log.info("Member 저장");  
        em.persist(member);  
    }  
  
    public Optional<Member> findByUsername(String username) {  
        return em.createQuery("SELECT m FROM Member m WHERE m.username = :username", Member.class)  
                .setParameter("username", username)  
                .getResultList().stream().findFirst();  
    }  
}

@Slf4j  
@Repository  
@RequiredArgsConstructor  
public class LogRepository {  
    private final EntityManager em;  
  
    @Transactional  
    public void save(Log logMessage) {  
        log.info("Log 저장");  
        em.persist(logMessage);  
  
        if (logMessage.getMessage().contains("로그예외")) {  
            log.info("Log 저장 시 예외 발생");  
            throw new RuntimeException("예외 발생");  
        }  
    }  
}
```

다음은 `MemberService`와 `MemberServiceTest`를 구현한다.

```java
@Slf4j  
@Service  
@RequiredArgsConstructor  
public class MemberService {  
    private final MemberRepository memberRepository;  
    private final LogRepository logRepository;  
  
    public void joinV1(String username) {  
	    Member member = new Member(username);  
	    Log logMessage = new Log(username);  
	  
	    log.info("== memberRepository 호출 시작 ==");  
	    memberRepository.save(member);  
	    log.info("== memberRepository 호출 종료 ==");  
	  
	    log.info("== logRepository 호출 시작 ==");  
	    logRepository.save(logMessage);  
	    log.info("== logRepository 호출 종료 ==");  
	}  
  
	public void joinV2(String username) {  
	    Member member = new Member(username);  
	    Log logMessage = new Log(username);  
	  
	    log.info("== memberRepository 호출 시작 ==");  
	    memberRepository.save(member);  
	    log.info("== memberRepository 호출 종료 ==");  
	  
	    log.info("== logRepository 호출 시작 ==");  
	    try {  
	        logRepository.save(logMessage);  
	    } catch (RuntimeException e) {  
	        log.info("Log 저장에 실패했습니다. logMessage = {}", logMessage.getMessage());  
	        log.info("정상 흐름 반환");  
	    }  
	    log.info("== logRepository 호출 종료 ==");  
	}
}
```

```java
@Slf4j  
@SpringBootTest  
class MemberServiceTest {  
    @Autowired  
    MemberService memberService;  
    @Autowired  
    MemberRepository memberRepository;  
    @Autowired  
    LogRepository logRepository;  
  
    /**  
     * @memberService @Transactional: OFF  
     * @memberRepository @Transactional: ON  
     * @logRepository @Transactional: ON  
     */    
    @Test  
    void outerTxOff_success() {  
        // GIVEN  
        String username = "outerTxOff_success";  
  
        // WHEN  
        memberService.joinV1(username);  
  
        // THEN: 모든 데이터가 정상 저장된다.  
        Assertions.assertTrue(memberRepository.findByUsername(username).isPresent());  
        Assertions.assertTrue(logRepository.findMessage(username).isPresent());  
    }  
}
```

`memberService`에는 현재 트랜잭션이 별도로 설정되어 있지 않고 의존하고 있는 리포지토리에 `@Transactional`이 설정되어 있다. 따라서 독립적인 트랜잭션을 수행하고 정상적으로 커밋된다.

```java
/**  
 * @memberService @Transactional: OFF  
 * @memberRepository @Transactional: ON  
 * @logRepository @Transactional: ON Exception  
 */
@Test  
void outerTxOff_fail() {  
    // GIVEN  
    String username = "로그예외_outerTxOff_fail";  
  
    // WHEN  
    assertThatThrownBy(() -> memberService.joinV1(username))  
            .isInstanceOf(RuntimeException.class);  
  
    // THEN: 멤버는 저장되고, 로그는 저장되지 않는다.  
    assertTrue(memberRepository.findByUsername(username).isPresent());  
    assertTrue(logRepository.findMessage(username).isEmpty());  
}
```
`logRepository.save()`는 `로그예외`라는 문자가 전달받는 `logMessage`에 포함되어 있으면 런타임 예외를 던진다. 따라서 `logRepository`에 사용된 트랜잭션은 롤백되고, `memberRepository`에 트랜잭션은 커밋되서 멤버만 저장된다.

이 경우 회원은 저장되지만 로그가 저장되지 않아서 데이터 정합성에 문제가 발생할 수 있다. 이 예제를 하나의 물리 트랜잭션으로 묶어서 사용해보자.

## 트랜잭션 하나만 사용하기
회원 리포지토리와 로그 리포지토리를 하나의 물리 트랜잭션으로 묶는 가장 간단한 방법은 이 둘을 호출하는 멤버 서비스에만 트랜잭션을 사용하는 것이다.

이렇게 하기 위해서는 먼저 `LogRepository`와 `MemberRepository`의 `save()`에 적용된 `@Transactional`을 주석 처리하고, `MemberService`의 호출부에서 `@Transactional`을 적용해야한다.

```java
/**  
 * @memberService @Transactional: ON  
 * @memberRepository @Transactional: OFF  
 * @logRepository @Transactional: OFF  
 */ 
@Test  
void singleTx() {  
    // GIVEN  
    String username = "outerTxOff_success";  
  
    // WHEN  
    memberService.joinV1(username);  
  
    // THEN: 모든 데이터가 정상 저장된다.  
    assertTrue(memberRepository.findByUsername(username).isPresent());  
    assertTrue(logRepository.findMessage(username).isPresent());  
}
```

이렇게 하면 `MemberService`를 시작할 때 부터 종료할 때 까지 모든 로직을 하나의 트랜잭션으로 묶을 수 있다. `MemberService`만 트랜잭션을 처리하기 때문에 앞서 배운 `논리 트랜잭션`, `물리 트랜잭션`, `외부 트랜잭션`, `내부 트랜잭션`, `rollback-only`, `신규 트랜잭션`, `트랜잭션 전파`와 같은 복잡한 것을 고민할 필요가 없다. 아주 단순하고 깔끔하게 트랜잭션을 묶을 수 있다.

## 별도의 트랜잭션이 필요한 상황
다음의 그림과 같이 각각 트랜잭션이 필요하면 어떻게 해야할까?

![[spring-transaction-propagation-4.png]]

위 그림에서 `클라이언트 B`와 `클라이언트 C`는 멤버 서비스를 통해서 리포지토리를 호출하는 것이 아니고, 직접 호출해서 사용하고 싶어하고, 트랜잭션도 사용하고 싶어한다. 

그럼 `@Transactional`을 리포지토리에도 적용해야한다. 이런 경우 [[11. 스프링 트랜잭션 전파|트랜잭션 전파]] 옵션이 없었다면 정말 골치 아팠을 것이다.

![[spring-transaction-propagation-5.png]]

위의 경우에는 `클라이언트 Z`가 호출하는 `OrderService`에도 트랜잭션을 시작할 수 있어야 하고, `클라이언트 A`가 호출하는 `MemberService`에서도 트랜잭션을 시작할 수 있어야 한다. 이런 복잡한 상황이 발생할 수도 있다. 

결국 이런 문제를 해결하기 위해 **트랜잭션 전파**가 필요한 것이다.

## 트랜잭션 전파 활용 - 전파 커밋
스프링은 `@Transactional`이 적용되어 있으면 기본으로 `REQUIRED`라는 전파 옵션을 사용한다. 이 옵션은 기존 트랜잭션이 없으면 트랜잭션을 생성하고, 기존 트랜잭션이 있으면 기존 트랜잭션에 참여한다.

이제 다음 테스트를 실행해보기에 앞서 `LogRepository`와 `MemberRepository`에 주석 처리 했던 `@Transactional`을 다시 복구하자.

```java
/**  
 * @memberService @Transactional: ON  
 * @memberRepository @Transactional: ON  
 * @logRepository @Transactional: ON  
 */
@Test  
void outerTxOn() {  
    // GIVEN  
    String username = "outerTxOn_success";  
  
    // WHEN  
    memberService.joinV1(username);  
  
    // THEN: 모든 데이터가 정상 저장된다.  
    assertTrue(memberRepository.findByUsername(username).isPresent());  
    assertTrue(logRepository.findMessage(username).isPresent());  
}
```

앞서 이야기한대로, `@Transactional`의 기본 전파 옵션은 `REQUIRED`이다. 기존 트랜잭션이 있으면 참여한다. 따라서 `MemberService`를 통한 호출을 하든, 직접적인 리포지토리를 통한 호출을 하든 트랜잭션을 수행한다.


---
References: 김영한의 스프링 DB

Links to this page: 