---
title: 
tags:
  - java
  - programming
  - spring
  - database
publish: true
date: 2024-12-14
---
## 데이터 접근 기술 진행 방식 소개
앞으로 실무에 주로 사용하는 다음과 같은 다양한 데이터 접근 기술들을 학습한다.

#### 적용 데이터 접근 기술

데이터 접근 기술은 다양하지만 크게 살펴보면 다음과 같이 `SQL Mapper`와 `ORM`으로 구분할 수 있다.

- `SQL Mapper`
	- `JdbcTemplate`
	- `MyBatis`
- `ORM`
	- `JPA`, `Hibernate`
	- `Spring Data JPA`
	- `Querydsl`

#### SQL Mapper 주요 기능
- 개발자는 `SQL`만 작성하면 해당 `SQL`의 결과를 객체로 편리하게 매핑해준다.
- `JDBC`를 직접 사용할 때 발생하는 여러가지 중복을 제거해주고, 기타 개발자에게 여러가지 편리한 기능을 제공한다.

#### ORM 주요 기능
- `JdbcTemplate`이나 `MyBatis`같은 `SQL Mapper` 기술은 `SQL`을 개발자가 직접 작성해야 하지만 `ORM`을 사용하면 기본적인 SQL은 `ORM`이 대신 SQL을 작성하고 처리한다.
- 개발자는 저장하고 싶은 객체를 마치 자바 컬렉션에 저장하고 조회하듯이 사용하면 `ORM`이 데이터베이스에 해당 객체를 저장하고 조회해준다.
- `JPA`는 자바 진영의 `ORM` 표준이고, `Hibernate`는 `JPA`에서 가장 많이 사용하는 구현체이다. 자바에서 `ORM`을 사용할 때는 `JPA` 인터페이스를 사용하고, 그 구현체로 하이버네이트를 사용한다고 생각하면 된다.
- `Spring Data JPA`, `Querydsl`은 `JPA`를 더 편리하게 사용할 수 있게 도와주는 프로젝트이다. 실무에서는 `JPA`를 사용하면 이 프로젝트도 반드시 함께 사용하는 것이 좋다.

#### 데이터 접근 기술 진행 방식
여기서 설명할 데이터 저장 기술들은 하나하나 별도의 책이나 강의로 다루어야 할 정도로 내용이 방대하다. 특히 `JPA`의 경우 스프링과 학습 분량이 거의 비슷할 정도로 공부해야 될 내용이 많다.

그래서 세세한 기능을 설명하기 보다는 주로 해당 기술이 왜 필요한지, 각 기술의 장단점은 무엇인지 설명하는데 초점을 맞춘다.

추후 필요할 때 해당 데이터 저장 기술을 스스로 학습할 수 있도록 돕는 것이 이번 장의 목표이다.

**이번 강의의 목표**
- 데이터 접근 기술에 대한 기본 이해와 전체 큰 그림을 그린다.
- 각 기술들의 핵심 기능 위주로 학습한다.
- 각 기술들을 점진적으로 도입하는 과정을 통해서 각 기술의 특징과 장단점을 자연스럽게 이해할 수 있다.

먼저 메모리 기반으로 완성되어 있는 프로젝트를 확인하고, 이 프로젝트에 데이터 접근 기술을 하나씩 추가해본다.

## 프로젝트 구조

프로젝트는 다음과 같은 구조로 구현되어 있다. 다음 형태는 `tree` 명령어를 통해서 추출했다.

```
./hello
└── itemservice
    ├── ItemServiceApplication.java
    ├── TestDataInit.java
    ├── config
    │   └── MemoryConfig.java
    ├── domain
    │   └── Item.java
    ├── repository
    │   ├── ItemRepository.java
    │   ├── ItemSearchCond.java
    │   ├── ItemUpdateDto.java
    │   └── memory
    │       └── MemoryItemRepository.java
    ├── service
    │   ├── ItemService.java
    │   └── ItemServiceV1.java
    └── web
        ├── HomeController.java
        └── ItemController.java
```

전체 코드 내용을 업로드하기에는 무리가 있다. 따라서 익숙한 코드는 프로젝트를 진행하면서 하나 하나씩 확인하고, 익숙하지 않은 코드들만 살펴본다.

```java title="TestDataInit.java"
@Slf4j  
@RequiredArgsConstructor  
public class TestDataInit {  
    private final ItemRepository itemRepository;  
  
    @EventListener(ApplicationReadyEvent.class)  
    public void initData() {  
        log.info("test data init");  
        itemRepository.save(new Item("itemA", 10000, 10));  
        itemRepository.save(new Item("itemB", 20000, 20));  
    }  
  
}
```

현재 프로젝트는 메모리 기반으로 동작하기 때문에 프로젝트 시작 시 데이터가 존재하지 않는다. 그 데이터를 이 `TestDataInit` 클래스에서 추가한다.

`@EventListener(ApplicationReadyEvent.class)` 어노테이션을 위와 같이 메서드에 사용하면, 스프링 컨테이너가 완전히 초기화를 다 끝내고 실행 준비가 되었을 때 해당 메서드를 실행한다.

참고로 이 기능 대신 `PostConstruct`를 사용할 경우 스프링 AOP 같은 부분이 아직 다 처리되지 않은 시점에 호출될 수 있기 때문에 간혹 문제가 발생할 수 있다. 예를 들어서 `@Transactional`과 관련된 AOP가 적용되지 않은 상태로 호출될 수 있다.

```java title="ItemServiceApplication.java"
@Import(MemoryConfig.class)  
@SpringBootApplication(scanBasePackages = "hello.itemservice.web")  
public class ItemServiceApplication {  
  
    public static void main(String[] args) {  
        SpringApplication.run(ItemServiceApplication.class, args);  
    }  
  
    @Bean  
    @Profile("local")  
    public TestDataInit testDataInit(ItemRepository itemRepository) {  
        return new TestDataInit(itemRepository);  
    }  
  
}
```

`@Import(MemoryConfig.class)`는 `MemoryConfig` 클래스를 스프링 설정 정보 파일로 이용한다는 어노테이션이다.

`scanBasePackages = "hello.itemservice.web"` 여기서는 컨트롤러만 컴포넌트 스캔을 사용하고, 나머지는 직접 수동 등록한다. 그래서 컴포넌트 스캔 경로를 `hello.itemservice.web` 하위로 지정했다.

`@Profile("local")` 특정 프로필의 경우에만 해당 스프링 빈을 등록한다. 여기서는 `local`이라는 이름의 프로필이 사용되는 경우에만 `testDataInit`이라는 스프링 빈을 등록한다. 이 빈은 앞서 살펴봤는데, 편의상 초기 데이터를 만들어서 저장하는 빈이다.

#### 프로필
스프링은 로딩 시점에 `application.properties`의 `spring.profiles.active` 속성을 읽어서 프로필로 사용한다.

이 프로필은 로컬, 운영 환경, 테스트 실행 등 다양한 환경에 따라서 다른 설정을 할 때 사용하는 정보이다. ()

---
References: 김영한의 스프링 DB 2편

Links to this page: 