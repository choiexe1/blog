---
title: 
tags:
  - java
  - programming
  - spring
  - jdbc
  - database
publish: true
date: 2024-12-15
---
## JdbcTemplate 소개와 설정
SQL을 직접 사용하는 경우에 스프링이 제공하는 `JdbcTemplate`는 아주 좋은 선택지다. `JdbcTemplate`는 `JDBC`를 매우 편리하게 사용할 수 있게 도와준다.

**설정의 편리함**

- `JdbcTemplate`은 `spring-jdbc` 라이브러리에 포함되어 있는데, 이 라이브러리는 스프링으로 `JDBC`를 사용할 때 기본으로 사용되는 라이브러리이다. 그리고 별도의 복잡한 설정 없이 바로 사용할 수 있다.

**반복 문제 해결**
- `JdbcTemplate`은 템플릿 콜백 패턴을 사용해서, `JDBC`를 직접 사용할 때 발생하는 대부분의 반복 작업을 대신 처리해준다.
- 개발자는 SQL을 작성하고, 전달할 파라미터를 정의하고, 응답 값을 매핑하기만 하면 된다.
- 이 부분은 앞서 [[10. JdbcTemplate]]에서 학습했다.


**단점**
- 동적 SQL을 해결하기 어렵다.

## JdbcTemplate 설정

```gradle title="build.gradle"
dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-jdbc'
	runtimeOnly 'com.h2database:h2'
}
```

위의 두 의존성을 프로젝트에 추가한다. 여기서는 H2 데이터베이스에 접속해야 하기 때문에 H2 데이터베이스의 클라이언트 라이브러리도 추가했다.

## JdbcTemplate 적용 1 - 기본
이제부터 본격적으로 메모리에 사용하던 데이터를 데이터베이스에 저장해본다. 

`ItemRepository` 인터페이스가 이미 작성되어 있으므로 해당 인터페이스를 기반으로 `JdbcTemplate`을 사용하는 새로운 구현체를 개발한다.

```java
public class JdbcTemplateItemRepositoryV1 implements ItemRepository {  
    private final JdbcTemplate template;  
  
    public JdbcTemplateItemRepositoryV1(DataSource dataSource) {  
        this.template = new JdbcTemplate(dataSource);  
    }
```

먼저 `JdbcTemplate`를 사용하려면 `JdbcTemplate`에 데이터 소스를 주입 해야한다. 당연한 소리지만 데이터소스를 기반으로 해당 데이터베이스에 대한 커넥션을 획득해야 데이터베이스와 관련된 작업을 수행할 수 있기 때문이다.

이 데이터소스는 수동으로 직접 주입 받아서 생성자에서 `new JdbcTemplate(dataSource)`를 통해 초기화한다.

스프링 부트는 기본적으로 `HikariCP`를 사용한다. 따라서 위 코드에서 주입 받는 `DataSource` 인터페이스를 `HikariDataSource`로 변경 해도 잘 작동한다. 

그러나 구현체에 의존하는 것은 좋지 않으므로 `DataSource`를 그대로 사용하자.

이에 대한 내용은 [[7. 스프링 부트의 자동 리소스 등록]]에서 찾아볼 수 있다.

```java
@Override
public Item save(Item item) {  
    String sql = "INSERT INTO item (item_name, price, quantity) VALUES (?, ?, ?)";  
    KeyHolder keyHolder = new GeneratedKeyHolder();  
    template.update(connection -> {  
        // 자동 증가 키  
        PreparedStatement ps = connection.prepareStatement(sql, new String[]{"id"});  
        ps.setString(1, item.getItemName());  
        ps.setInt(2, item.getPrice());  
        ps.setInt(3, item.getQuantity());  
        return ps;  
    }, keyHolder);  
  
    long key = keyHolder.getKey().longValue();  
    item.setId(key);  
  
    return item;  
}
```

앞서 메모리 기반으로 어플리케이션이 동작할 때는 직접 `Item` 객체의 `id`를 증가시키면서 설정했지만 이제는 기본 키 생성을 H2 데이터베이스에 위임하고 있다. 

따라서 PK인 `id` 값을 개발자가 직접 지정하는 것이 아니라 비워두고 저장해야 한다. 문제는 이렇게 데이터베이스가 대신 생성해주는 PK `id` 값은 데이터베이스가 생성하기 때문에, 데이터베이스에 `INSERT`가 완료 되어야 생성된 PK를 확인할 수 있다.

`KeyHolder`와 `PreparedStatement ps = connection.prepareStatement(sql, new String[]`를 사용해서 `id`를 지정해주면 `INSERT` 쿼리 실행 이후에 데이터베이스에서 생성된 `id` 값을 조회할 수 있다.

> 뒤에서 `JdbcTemplate`이 제공하는 `SimpleJdbcInsert`라는 훨씬 편리한 기능이 있으므로 대략 이렇게 사용한다 정도로만 알아두면 된다.



```java
@Override  
public void update(Long itemId, ItemUpdateDto updateParam) {  
    String sql = "UPDATE item SET item_name = ?, price = ?, quantity = ? WHERE id = ?";  
      
    template.update(sql,  
            updateParam.getItemName(),  
            updateParam.getPrice(),  
            updateParam.getQuantity(),  
            itemId  
    );  
}
```

기존 아이템을 변경하는 `update`는 위와 같이 단순하다. SQL을 넘기고 파라미터를 입력한다.

```java
@Override  
public Optional<Item> findById(Long id) {  
    String sql = "SELECT id, item_name, price, quantity FROM item WHERE id = ?";  
    try {  
        Item item = template.queryForObject(sql, itemRowMapper(), id);  
        return Optional.of(item);  
    } catch (EmptyResultDataAccessException e) {  
        return Optional.empty();  
    }  
}
```

`template.queryForObject()` SQL의 결과 로우가 하나일 때 사용한다. 여기서 반환되는 로우를 `itemRowMapper()`라는 콜백 함수를 이용해서 자바 객체로 매핑할 수 있다.

- 결과가 없으면 `EmptyResultDataAccessException`이 발생한다는 것이다.
- 결과 로우가 하나가 아니라 둘 이상이면 `IncorrectResultSizeDataAccessException` 예외가 발생한다.

`ItemRepository.findById()` 인터페이스는 결과가 없을 때 `Optional`을 반환해야 한다. 따라서 결과가 없으면 예외를 잡아서 `Optional.empty`를 대신 반환하면 된다.

```java
@Override  
public List<Item> findAll(ItemSearchCond cond) {  
    String itemName = cond.getItemName();  
    Integer maxPrice = cond.getMaxPrice();  
    String sql = "select id, item_name, price, quantity from item";  
  
    //동적 쿼리  
    if (StringUtils.hasText(itemName) || maxPrice != null) {  
        sql += " where";  
    }  
    boolean andFlag = false;  
    List<Object> param = new ArrayList<>();  
    if (StringUtils.hasText(itemName)) {  
        sql += " item_name like concat('%',?,'%')";  
        param.add(itemName);  
        andFlag = true;  
    }  
    if (maxPrice != null) {  
        if (andFlag) {  
            sql += " and";  
        }  
        sql += " price <= ?";  
        param.add(maxPrice);  
    }  
    log.info("sql={}", sql);  
    return template.query(sql, itemRowMapper(), param.toArray());  
}
```

위 코드를 살펴보면 동적으로 쿼리를 생성해야 하기 때문에 각 파라미터의 조건에 따라서 문자열을 추가하거나 빼고 있다는 것을 알 수 있다.

첫 회사에서도 express로 이런 비슷한 쿼리를 자주 작성 했었다.

`template.query`는 결과가 하나 이상 일때 사용한다. 여기서 사용되는 `itemRowMapper()`는 `JdbcTemplate`가 다음과 같은 루프를 돌려준다는 점이다. 따라서 개발자는 RowMapper만 구현하면 된다.

```java
while(resultSet 이 끝날 때 까지) {
	rowMapper(rs, rowNum)
}
```

## JdbcTemplate 적용 - 동적 쿼리 문제
결과를 검색하는 `findAll()`에서 어려운 부분은, 사용자가 검색하는 값에 따라서 실행하는 SQL이 동적으로 달라져야 한다는 점이다. 예를 들어서 다음과 같은 케이스들이 존재한다.

- 검색 조건이 없음
- 상품명으로 검색
- 최대 가격으로 검색
- 상품명과 최대 가격으로 검색

각 파라미터의 유무에 따라 실제 전달되는 SQL이 달라져야 한다. 각 케이스에 따른 SQL은 다음과 같다.

```sql
-- 검색 조건이 없음
SELECT id, item_name, price, quantity
FROM item;

-- 상품명(itemName)으로 검색
SELECT id, item_name, price, quantity
FROM item
WHERE item_name LIKE CONCAT('%', ?, '%');

-- 최대 가격(maxPrice)로 검색
SELECT id, item_name, price, quantity
FROM item
WHERE price <= ?;

-- 상품명(itemName), 최대 가격(maxPrice) 둘 다 검색
SELECT id, item_name, price, quantity
FROM item
WHERE item_name LIKE CONCAT('%', ?, '%') AND price <= ?;
```

따라서 개발자는 파라미터의 유무를 확인하고 위의 네 가지 케이스에 대한 SQL 문자열 생성을 모두 개발해야하는 것이다.

단순히 숫자만 계산해봐도 조건이 N개 있을 때 조합 가능한 경우의 수는 2의 N승이다. 조건이 4개만 되어도 16가지 케이스의 동적 문자열 생성 로직을 개발해야 하는 것이다.

물론 영한님이 동적 쿼리 생성하는 부분의 로직을 너무 오버해서 작성한 감이 있긴 하지만.. 어쨌든 개발 하는것 뿐만이 문제가 아니라 유지보수 하기가 복잡해진다.




---
References: 김영한의 스프링 DB 2편

Links to this page: [[10. JdbcTemplate]], [[7. 스프링 부트의 자동 리소스 등록]]