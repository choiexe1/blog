---
title: 
tags:
  - java
  - programming
  - spring
  - jdbc
  - database
publish: true
date: 2024-12-15
---
## JdbcTemplate 소개와 설정
SQL을 직접 사용하는 경우에 스프링이 제공하는 `JdbcTemplate`는 아주 좋은 선택지다. `JdbcTemplate`는 `JDBC`를 매우 편리하게 사용할 수 있게 도와준다.

**설정의 편리함**

- `JdbcTemplate`은 `spring-jdbc` 라이브러리에 포함되어 있는데, 이 라이브러리는 스프링으로 `JDBC`를 사용할 때 기본으로 사용되는 라이브러리이다. 그리고 별도의 복잡한 설정 없이 바로 사용할 수 있다.

**반복 문제 해결**
- `JdbcTemplate`은 템플릿 콜백 패턴을 사용해서, `JDBC`를 직접 사용할 때 발생하는 대부분의 반복 작업을 대신 처리해준다.
- 개발자는 SQL을 작성하고, 전달할 파라미터를 정의하고, 응답 값을 매핑하기만 하면 된다.
- 이 부분은 앞서 [[10. JdbcTemplate]]에서 학습했다.


**단점**
- 동적 SQL을 해결하기 어렵다.

## JdbcTemplate 설정

```gradle title="build.gradle"
dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-jdbc'
	runtimeOnly 'com.h2database:h2'
}
```

위의 두 의존성을 프로젝트에 추가한다. 여기서는 H2 데이터베이스에 접속해야 하기 때문에 H2 데이터베이스의 클라이언트 라이브러리도 추가했다.

## JdbcTemplate 적용 1 - 기본
이제부터 본격적으로 메모리에 사용하던 데이터를 데이터베이스에 저장해본다. 

`ItemRepository` 인터페이스가 이미 작성되어 있으므로 해당 인터페이스를 기반으로 `JdbcTemplate`을 사용하는 새로운 구현체를 개발한다.

```java
public class JdbcTemplateItemRepositoryV1 implements ItemRepository {  
    private final JdbcTemplate template;  
  
    public JdbcTemplateItemRepositoryV1(DataSource dataSource) {  
        this.template = new JdbcTemplate(dataSource);  
    }
```

먼저 `JdbcTemplate`를 사용하려면 `JdbcTemplate`에 데이터 소스를 주입 해야한다. 당연한 소리지만 데이터소스를 기반으로 해당 데이터베이스에 대한 커넥션을 획득해야 데이터베이스와 관련된 작업을 수행할 수 있기 때문이다.

`JdbcTemplate` 객체를 생성하기 위해서는 `DataSource`가 필요하다. 이 데이터소스는 수동으로 직접 주입할 수도 있지만 스프링 부트가 자동으로 등록해준 데이터소스를 스프링 컨테이너를 통해 주입 받아서 생성자에서 `new JdbcTemplate(dataSource)`를 통해 초기화한다.

스프링 부트는 기본적으로 `HikariCP`를 사용한다. 따라서 위 코드에서 주입 받는 `DataSource` 인터페이스를 `HikariDataSource`로 변경 해도 잘 작동한다. 

그러나 구현체에 의존하는 것은 좋지 않으므로 `DataSource`를 그대로 사용하자.

이에 대한 내용은 [[7. 스프링 부트의 자동 리소스 등록]]에서 찾아볼 수 있다.

```java
@Override
public Item save(Item item) {  
    String sql = "INSERT INTO item (item_name, price, quantity) VALUES (?, ?, ?)";  
    KeyHolder keyHolder = new GeneratedKeyHolder();  
    template.update(connection -> {  
        // 자동 증가 키  
        PreparedStatement ps = connection.prepareStatement(sql, new String[]{"id"});  
        ps.setString(1, item.getItemName());  
        ps.setInt(2, item.getPrice());  
        ps.setInt(3, item.getQuantity());  
        return ps;  
    }, keyHolder);  
  
    long key = keyHolder.getKey().longValue();  
    item.setId(key);  
  
    return item;  
}
```

앞서 메모리 기반으로 어플리케이션이 동작할 때는 직접 `Item` 객체의 `id`를 증가시키면서 설정했지만 이제는 기본 키 생성을 H2 데이터베이스에 위임하고 있다. 

따라서 PK인 `id` 값을 개발자가 직접 지정하는 것이 아니라 비워두고 저장해야 한다. 문제는 이렇게 데이터베이스가 대신 생성해주는 PK `id` 값은 데이터베이스가 생성하기 때문에, 데이터베이스에 `INSERT`가 완료 되어야 생성된 PK를 확인할 수 있다.

`KeyHolder`와 `PreparedStatement ps = connection.prepareStatement(sql, new String[]`를 사용해서 `id`를 지정해주면 `INSERT` 쿼리 실행 이후에 데이터베이스에서 생성된 `id` 값을 조회할 수 있다.

> 뒤에서 `JdbcTemplate`이 제공하는 `SimpleJdbcInsert`라는 훨씬 편리한 기능이 있으므로 대략 이렇게 사용한다 정도로만 알아두면 된다.



```java
@Override  
public void update(Long itemId, ItemUpdateDto updateParam) {  
    String sql = "UPDATE item SET item_name = ?, price = ?, quantity = ? WHERE id = ?";  
      
    template.update(sql,  
            updateParam.getItemName(),  
            updateParam.getPrice(),  
            updateParam.getQuantity(),  
            itemId  
    );  
}
```

기존 아이템을 변경하는 `update`는 위와 같이 단순하다. SQL을 넘기고 파라미터를 입력한다.

```java
@Override  
public Optional<Item> findById(Long id) {  
    String sql = "SELECT id, item_name, price, quantity WHERE id = ?";  
    try {  
        Item item = template.queryForObject(sql, itemRowMapper(), id);  
        return Optional.of(item);  
    } catch (EmptyResultDataAccessException e) {  
        return Optional.empty();  
    }  
}
```

`template.queryForObject()` SQL의 결과 로우가 하나일 때 사용한다. 여기서 반환되는 로우를 `itemRowMapper()`라는 콜백 함수를 이용해서 자바 객체로 매핑할 수 있다.

- 주의 할 점은 결과가 없으면 `EmptyResultDataAccessException`이 발생한다는 것이다.
- 결과 로우가 하나가 아니라 둘 이상이면 `Incorren`



---
References: 김영한의 스프링 DB 2편

Links to this page: [[10. JdbcTemplate]], [[7. 스프링 부트의 자동 리소스 등록]]