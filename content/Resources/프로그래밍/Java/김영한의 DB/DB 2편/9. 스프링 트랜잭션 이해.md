---
title: 
tags:
  - java
  - programming
  - spring
  - transaction
publish: true
date: 2024-12-26
---
## 스프링 트랜잭션
먼저 본격적인 기능 설명에 앞서서, 지금까지 학습한 스프링 트랜잭션을 간략히 복습한다.

#### 스프링 트랜잭션 추상화
[[5. 스프링과 문제 해결 - 트랜잭션#트랜잭션 추상화|트랜잭션 추상화]]에서 학습했다. 각 데이터 기술들은 트랜잭션을 처리하는 방식에 차이가 있다. 예를 들어 `JDBC`와 `JPA`는 트랜잭션을 사용하는 코드 자체가 다르다.

- `JDBC`는 `setAutoCommit(false)`를 통해 트랜잭션을 시작한다.
- `JPA`는 `getTransaction()`을 통해 트랜잭션 기능을 획득하고 `begin()`, `commit()`, `rollback()`, `close()` 등의 메서드를 이용해 트랜잭션을 다룬다.

따라서 `JDBC`를 사용하다가 `JPA`를 사용하게 되면 트랜잭션을 사용하는 코드도 모두 함께 변경해야한다. 스프링은 이런 문제를 해결하기 위해 트랜잭션을 추상화했다.
트랜잭션을 사용하는 입장에서는 스프링 트랜잭션 추상화를 통해 둘을 동일한 방식으로 사용하게 되는 것이다.

스프링은 `PlatformTransactionManager`라는 인터페이스를 통해 트랜잭션을 추상화한다.

![[transaction-10.png]]

- 스프링은 트랜잭션을 추상화해서 제공할 뿐만 아니라, 실무에서 주로 사용하는 데이터 접근 기술에 대한 트랜잭션 매니저의 구현체도 제공한다. 개발자는 필요한 구현체를 스프링 빈으로 등록하고 주입 받아서 사용하기만 하면 되는 것이다.
- 여기에 더해서 스프링 부트는 어떤 데이터 접근 기술을 사용하는지를 자동으로 인식(라이브러리 인식)해서 적절한 트랜잭션 매니저를 선택해서 스프링 빈으로 등록해준다. 따라서 트랜잭션 매니저를 선택하고 등록하는 과정마저 생략할 수 있다.
- 예를 들어 `JdbcTemplate`이나 `MyBatis`를 사용하면 `DataSourceTransactionManager(JdbcTransactionManager)`를 스프링 빈으로 등록하고, JPA를 사용하면 `JpaTransactionManager`를 스프링 빈으로 등록해준다.

#### 스프링 트랜잭션 사용 방식

**선언적 트랜잭션 관리**
- `@Transactional` 어노테이션 하나만으로 매우 편리하게 트랜잭션을 적용한다.

**프로그래밍 방식 트랜잭션 관리**
- 트랜잭션 매니저 또는 트랜잭션 템플릿등을 이용해서 트랜잭션 관련 코드를 직접 작성하는 것을 프로그래밍 방식의 트랜잭션 관리라 한다.
- 이렇게 되면 어플리케이션 코드가 트랜잭션이라는 기술과 강하게 결합된다.

#### 선언적 트랜잭션과 AOP
`@Transactional`을 통한 선언적 트랜잭션 관리 방식을 사용하게 되면 기본적으로 프록시 방식의 AOP가 적용된다. 이는 앞서 [[6. 트랜잭션 문제 해결 - 트랜잭션 AOP 이해#스프링이 제공하는 트랜잭션 AOP|트랜잭션 AOP 이해]]에서 학습했다.

## 트랜잭션 적용 확인 
`@Transactional`을 통해 선언적 트랜잭션을 사용하면, 단순히 어노테이션 하나로 트랜잭션을 적용할 수 있다. 그렇지만 AOP를 기반으로 트랜잭션이 동작하기 때문에 실제로 트랜잭션이 적용되고 있는지 확인하기가 어렵다.

다음과 같이 테스트 코드를 작성해서, 트랜잭션이 적용 되었는지 확인해본다.

```java
@Slf4j  
@SpringBootTest  
public class TxBasicTest {  
    @Autowired  
    BasicService basicService;  
  
    @Test  
    void proxyCheck() {  
        log.info("aop class = {}", basicService.getClass());  
        assertThat(AopUtils.isAopProxy(basicService)).isTrue();  
    }  
  
    @Test  
    void txTest() {  
        basicService.tx();  
        basicService.nonTx();  
    }  
  
    @TestConfiguration  
    static class TxApplyBasicConfig {  
        @Bean  
        BasicService basicService() {  
            return new BasicService();  
        }  
    }  
  
    @Slf4j  
    static class BasicService {  
        @Transactional  
        public void tx() {  
            log.info("call tx");  
            boolean active = TransactionSynchronizationManager.isActualTransactionActive();  
            log.info("tx active = {}", active);  
        }  
  
        public void nonTx() {  
            log.info("call nonTx");  
            boolean active = TransactionSynchronizationManager.isActualTransactionActive();  
            log.info("tx active = {}", active);  
        }  
    }  
}
```

- `AopUtils.isAopProxy()`는 해당 객체가 프록시 객체인지 확인하는 메서드이다. 해당 테스트는 통과한다.
- `txTest()`에서 `basicService`의 메서드들을 호출하는데, 여기서 트랜잭션이 적용된 `tx()` 메서드는 결과가 `true`이다. 트랜잭션이 수행되고 있다는 의미다.
- `nonTx()`는 결과가 `false`기 때문에, 트랜잭션이 수행되지 않고 있다.

![[tx-1.png]]
- `@Transactional` 어노테이션이 특정 클래스나 메서드에 하나라도 있으면 트랜잭션 AOP는 프록시를 만들어서 스프링 컨테이너에 등록한다.
- 실제 객체인 `basicService` 대신에 프록시인 `basicService$$CGLIB`을 등록하는 것이다. 그리고 이 프록시 객체는 내부에 실제 `basicService`를 참조하게 된다. 여기서 핵심은 실제 객체 대신에 프록시가 스프링 컨테이너에 등록되었다는 점이다.
- 클라이언트인 `txBasicTest`는 스프링 컨테이너에 `@Autowired BasicService basicService`로 의존 관계 주입을 요청한다. 스프링 컨테이너에는 실제 객체인 `basicService` 대신에 프록시가 스프링 빈으로 등록되어 있기 때문에 프록시를 주입한다.
- 프록시 객체는 `BasicService`를 상속 받은 자식 타입이기 때문에 다형성을 활용해서 프록시인 `BasicService$$CGLIB`을 주입할 수 있다.

```properties title="application.properties"
logging.level.org.springframework.transaction.interceptor=TRACE
```

위 설정을 추가하면 트랜잭션 프록시가 호출하는 트랜잭션의 시작과 종료를 로그로 확인할 수 있다.

```
[springtx] [    Test worker] o.s.t.i.TransactionInterceptor           : Getting transaction for [hello.springtx.apply.TxBasicTest$BasicService.tx]
[springtx] [    Test worker] h.s.apply.TxBasicTest$BasicService       : call tx
[springtx] [    Test worker] h.s.apply.TxBasicTest$BasicService       : tx active = true
[springtx] [    Test worker] o.s.t.i.TransactionInterceptor           : Completing transaction for [hello.springtx.apply.TxBasicTest$BasicService.tx]
[springtx] [    Test worker] h.s.apply.TxBasicTest$BasicService       : call nonTx
[springtx] [    Test worker] h.s.apply.TxBasicTest$BasicService       : tx active = false
```

- `TransactionSynchronizationManager.isActualTransactionActive()`: 현재 쓰레드에 트랜잭션이 적용되어 있는지 확인할 수 있는 기능이다. 결과가 `true`면 트랜잭션이 적용되어 있는 것이다. 트랜잭션 적용 여부를 가장 확실하게 확인할 수 있다.

**트랜잭션 적용 흐름**

1. 클라이언트가 `basicService.tx()`를 호출하면 프록시 객체의 `tx()`가 호출된다. 여기서 프록시는 `tx()`메서드가 트랜잭션 적용 대상인지 확인한다.
2. 트랜잭션 적용 대상이기 때문에 트랜잭션을 시작한 다음에 참조하고 있는 실제 `basicService.tx()`를 호출한다.
3. 호출이 끝나서 프록시로 제어가 돌아오면 프록시는 트랜잭션 로직을 커밋하거나 롤백해서 트랜잭션을 종료한다.

> 위에서 tx()는 `@Transactional`이 적용된 트랜잭션 적용 대상이고, nonTx()는 트랜잭션 적용 대상이 아니다. 따라서 tx()만 트랜잭션이 적용된다.

## 트랜잭션 적용 위치
스프링에서 우선 순위는 **항상 더 구체적이고 자세한 것이 높은 우선순위를 가진다.** 다음의 예를 살펴보자.

- 메서드와 클래스에 어노테이션을 붙일 수 있다면 더 구체적인 메서드가 더 높은 우선순위를 가진다.
- 인터페이스와 해당 인터페이스를 구현한 클래스에 어노테이션을 붙일 수 있다면 더 구체적인 클래스가 더 높은 우선 순위를 가진다.

```java
@SpringBootTest  
public class TxLevelTest {  
    @Autowired  
    LevelService service;  
  
    @Test  
    void orderTest() {  
        service.write();  
        service.read();  
    }  
  
    @TestConfiguration  
    static class TxApplyLevelConfig {  
        @Bean  
        LevelService levelService() {  
            return new LevelService();  
        }  
    }  
  
    @Slf4j  
    @Transactional(readOnly = true)  
    static class LevelService {  
        @Transactional(readOnly = false)  
        public void write() {  
            log.info("call write");  
            printTxInfo();  
        }  
  
        public void read() {  
            log.info("call read");  
            printTxInfo();  
        }  
  
        private void printTxInfo() {  
            boolean txActive =  
                    TransactionSynchronizationManager.isActualTransactionActive();  
            log.info("tx active={}", txActive);  
            boolean readOnly =  
                    TransactionSynchronizationManager.isCurrentTransactionReadOnly();  
            log.info("tx readOnly={}", readOnly);  
        }  
    }  
}
```

트랜잭션이 적용된 우선 순위를 로그를 통해 확인해보자. `orderTest()`를 실행하면 다음과 같은 결과가 출력된다. 

```
2024-12-26T20:41:13.600+09:00  INFO 10306 --- [springtx] [    Test worker] h.s.apply.TxLevelTest$LevelService       : tx active=true
2024-12-26T20:41:13.601+09:00  INFO 10306 --- [springtx] [    Test worker] h.s.apply.TxLevelTest$LevelService       : tx readOnly=false
2024-12-26T20:41:13.601+09:00 TRACE 10306 --- [springtx] [    Test worker] o.s.t.i.TransactionInterceptor           : Completing transaction for [hello.springtx.apply.TxLevelTest$LevelService.write]
2024-12-26T20:41:13.602+09:00 TRACE 10306 --- [springtx] [    Test worker] o.s.t.i.TransactionInterceptor           : Getting transaction for [hello.springtx.apply.TxLevelTest$LevelService.read]
2024-12-26T20:41:13.602+09:00  INFO 10306 --- [springtx] [    Test worker] h.s.apply.TxLevelTest$LevelService       : call read
2024-12-26T20:41:13.602+09:00  INFO 10306 --- [springtx] [    Test worker] h.s.apply.TxLevelTest$LevelService       : tx active=true
2024-12-26T20:41:13.602+09:00  INFO 10306 --- [springtx] [    Test worker] h.s.apply.TxLevelTest$LevelService       : tx readOnly=true
2024-12-26T20:41:13.602+09:00 TRACE 10306 --- [springtx] [    Test worker] o.s.t.i.TransactionInterceptor           : Completing transaction for [hello.springtx.apply.TxLevelTest$LevelService.read]
```

- 첫 번째 `write()` 호출에서는 `@Transactional(readOnly = false)`가 적용되어 있다. 따라서 더욱 구체적인 메서드의 어노테이션이 우선 순위가 높다.
- 두 번째 `read()` 호출에서는 메서드에 적용된 `@Transactional` 어노테이션이 없으므로 클래스 레벨에 적용된 어노테이션을 적용시킨다. `readOnly`가 `true`로 출력된다.

> 참고로`@Transactional`의 `readOnly` 옵션은 `false`가 기본 옵션이다.


#### 인터페이스에 @Transactional 적용
인터페이스에도 `@Transactional`을 적용할 수 있다. 이 경우 동일하게 구체적인 것이 더 높은 우선순위를 가진다. 다음 예시에서는 `1`이 가장 높은 우선순위이다.

1. 클래스의 메서드
2. 클래스의 타입(클래스 레벨에 있는지)
3. 인터페이스의 메서드
4. 인터페이스의 타입

그런데 인터페이스에 `@Transactional`을 사용하는 것은 스프링 공식 메뉴얼에서 권장하지 않는 방법이다. AOP를 적용하는 방식에 따라서 인터페이스에 어노테이션을 두면 AOP가 적용되지 않는 경우도 있기 때문이다. 따라서 가급적 구체 클래스에 `@Transactional`을 사용하자.

## 트랜잭션 AOP 주의 사항 - 프록시 내부 호출 1
`@Transactional`을 사용하면 스프링 트랜잭션 AOP가 적용된다. 트랜잭션 AOP는 기본적으로 프록시 방식의 AOP를 사용한다. 앞서 배운 것 처럼 `@Transactional`을 적용하면 프록시 객체가 요청을 먼저 받아서 트랜잭션을 처리하고, 실제 객체를 호출해준다.

따라서 트랜잭션을 적용하려면 항상 프록시를 통해서 대상 객체(Target)을 호출해야 한다. 이렇게 해야 프록시에서 먼저 트랜잭션을 적용하고 이후에 대상 객체를 호출하게 된다. 만약 프록시를 거치지 않고 **대상 객체를 직접 호출하게 되면 당연한 결과지만 AOP가 적용되지 않고, 트랜잭션도 적용되지 않는다.**

> 핵심은 트랜잭션은 AOP를 통해서 프록시 객체가 만들어지고, 스프링 컨테이너에 생성된 프록시 객체를 실제 객체 대신 등록한다. 스프링 컨테이너에 등록된 프록시 객체가 타겟을 호출해야 트랜잭션이 정상적으로 적용 된다는 점이다. 꼭 기억하자.

> [!error] 타겟에서의 내부 호출
> 
> AOP를 적용하면 스프링은 대상 객체 대신 프록시를 스프링 빈으로 등록한다. 따라서 스프링은 의존관계 주입 시에 항상 실제 객체 대신 프록시 객체를 주입한다. 프록시 객체가 주입 되기 때문에 대상 객체를 직접 호출하는 문제는 일반적으로 발생하지 않는다. 하지만 **대상 객체의 내부에서 메서드 호출이 발생하면 프록시를 거치지 않고 대상 객체를 직접 호출하는 문제가 발생한다.** 이렇게 되면 `@Transactional`이 있어도 트랜잭션이 적용되지 않는다.

다음과 같은 테스트 코드를 작성해서 내부 호출 예시를 살펴보자.

```java
@Slf4j  
@SpringBootTest  
public class InternalCallV1Test {  
    @Autowired  
    CallService callService;  
  
    @Test  
    void printProxy() {  
        log.info("callService class = {}", callService.getClass());  
    }  
  
    @Test  
    void internalCall() {  
        callService.internal();  
    }
    
	@Test  
	void externalCall() {  
	    callService.external();  
	}
  
    @TestConfiguration  
    static class InternalCallV1TestConfig {  
  
        @Bean  
        CallService callService() {  
            return new CallService();  
        }  
    }  
  
  
    @Slf4j  
    static class CallService {  
        public void external() {  
            log.info("call external");  
            printTxInfo();  
            internal();  
        }  
  
        @Transactional  
        public void internal() {  
            log.info("call internal");  
            printTxInfo();  
        }  
  
        private void printTxInfo() {  
            boolean txActive =  
                    TransactionSynchronizationManager.isActualTransactionActive();  
            log.info("tx active={}", txActive);  
            boolean readOnly =  
                    TransactionSynchronizationManager.isCurrentTransactionReadOnly();  
            log.info("tx readOnly={}", readOnly);  
        }  
    }  
}
```

- `internalCall()` 테스트 메서드에서는 `callService.internal()`을 호출한다. 트랜잭션 정보를 확인해보면 프록시를 통한 호출이라 트랜잭션이 적용된다.
- `externalCall()` 테스트 메서드를 실행하고 트랜잭션 정보 로그를 확인해보면 트랜잭션이 적용되지 않음을 알 수 있다.
- `CallService`에 있는 `external()` 메서드를 확인해보면 이 메서드에는 트랜잭션 어노테이션이 없으므로 트랜잭션이 당연히 적용되지 않는다.
- 그런데 `external()` 내부에서 `internal()`을 **직접 호출**한다. 이는 프록시 객체가 실제 참조하고 있는 타겟의 `internal()`을 호출하는 것과 다르다.


**흐름**
1. 프록시 객체가 `external()`이 트랜잭션 적용 대상인지 확인한다.
2. 트랜잭션 적용 대상이 아니므로 트랜잭션을 시작하지 않는다.
3. `external()`의 마지막에 `internal()`을 호출한다. 그런데 이 호출은 프록시 객체가 호출한 것이 아닌 현재 제어중인 자기 자신(`CallService`)의 인스턴스를 가르킨다.
4. 따라서 `internal()`도 트랜잭션이 적용되지 않는다.

---
References: 김영한의 스프링 DB 2편

Links to this page: [[5. 스프링과 문제 해결 - 트랜잭션]]