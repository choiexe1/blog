---
title: 
tags:
  - java
  - programming
  - transaction
  - exception
publish: true
date: 2024-12-27
---
## 예외와 트랜잭션 커밋, 롤백 - 기본

예외가 발생했는데, 내부에서 예외를 처리하지 못하고 트랜잭션 범위 밖(`@Transactional이 적용된 AOP`)으로 예외를 던지면 어떻게 될까?

![[transaction-exception-1.png]]

예외 발생 시 스프링 트랜잭션 AOP는 예외의 종류에 따라 트랜잭션을 커밋하거나 롤백한다.
- 언체크 예외인 `RuntimeException`, `Error`와 그 하위 예외가 발생하면 트랜잭션을 롤백한다.
- 체크 예외인 `Exception`과 그 하위 예외가 발생하면 트랜잭션을 커밋한다.

먼저 예제 코드를 작성하기 전에 트랜잭션의 작동을 로그로 확인하기 위해 다음 설정을 추가한다.
```properties title="application.properties"
logging.level.org.springframework.transaction.interceptor=TRACE  
logging.level.org.springframework.jdbc.datasource.DataSourceTransactionManager=DEBUG  
#JPA log  
logging.level.org.springframework.orm.jpa.JpaTransactionManager=DEBUG  
logging.level.org.hibernate.resource.transaction=DEBUG
```


```java
@SpringBootTest  
public class RollbackTest {  
  
    @Autowired  
    RollbackService service;  
  
    @Test  
    void runtimeException() {  
        Assertions.assertThatThrownBy(() -> service.runtimeException())  
                .isInstanceOf(RuntimeException.class);  
    }  
  
    @Test  
    void checkedException() {  
        Assertions.assertThatThrownBy(() -> service.checkedException())  
                .isInstanceOf(MyException.class);  
    }  
  
    @Test  
    void rollbackFor() {  
        Assertions.assertThatThrownBy(() -> service.rollbackFor())  
                .isInstanceOf(MyException.class);  
    }  
  
    @TestConfiguration  
    static class RollbackTestConfig {  
        @Bean  
        RollbackService rollbackService() {  
            return new RollbackService();  
        }  
    }  
  
  
    @Slf4j  
    static class RollbackService {  
        // 런타임 예외 발생 -> 롤백  
        @Transactional  
        public void runtimeException() {  
            log.info("call runtimeException");  
            throw new RuntimeException();  
        }  
  
        // 체크 예외 발생 -> 커밋  
        @Transactional  
        public void checkedException() throws Exception {  
            log.info("call checkedException");  
            throw new MyException();  
        }  
  
        // 체크 예외 발생 -> rollbackFor -> 롤백  
        @Transactional(rollbackFor = MyException.class)  
        public void rollbackFor() throws Exception {  
            log.info("call rollbackFor");  
            throw new MyException();  
        }  
    }  
  
    static class MyException extends Exception {  
    }  
}
```

테스트를 하나씩 실행해보면 앞서 학습한 대로, 다음과 같이 동작한다.
- `runtimeException()`: 롤백
- `checkedException()`: 커밋
- `rollbackFor()`: 롤백

## 예외와 트랜잭션 커밋, 롤백 - 활용
스프링은 도대체 왜 체크 예외는 커밋하고, 언체크 예외는 롤백할까? 스프링은 기본적으로 **체크 예외는 비즈니스 의미가 있을 때 사용**하고, **런타임 예외는 복구 불가능한 예외**로 가정한다. 참고로 꼭 이런 정책을 따를 필요는 없다.

그런데 비즈니스 의미가 있는 **비즈니스 예외**가 도대체 무슨 뜻일까? 비즈니스 예외를 예제로 알아본다.

**비즈니스 요구사항**

주문 시스템을 개발하는데, 상황에 따라 다음과 같이 조치한다.
- **정상**: 주문시 결제를 성공하면 주문 데이터를 저장하고 결제 상태를 완료로 처리한다.
- **시스템 예외**: 주문시 내부에 복구 불가능한 예외가 발생하면 전체 데이터를 롤백한다.
- **비즈니스 예외**: 주문시 결제 잔고가 부족하면 주문 데이터를 저장하고, 결제 상태를 대기로 처리한다.
	- 이 경우 고객에게 잔고 부족을 알리고 별도의 계좌로 입금하도록 한다.

이 때 결제 잔고가 부족하면 `NotEnoughMoneyException`이라는 체크 예외가 발생한다고 가정한다. 이 예외는 시스템에 문제가 있어서 발생하는 시스템 예외가 아니다. 시스템은 정상적으로 동작했지만 비즈니스 상황에서 문제가 되기 때문에 발생한 예외이다.

더 자세히 설명하면, 고객의 잔고가 부족한 것은 시스템에 문제가 있는 것이 아니다. 오히려 시스템은 정상 동작한 것이고 비즈니스 상황이 예외인 것이다. 이런 예외를 비즈니스 예외라 한다. 그리고 비즈니스 예외는 매우 중요하고 반드시 처리해야 하는 경우가 많으므로 체크 예외를 고려할 수 있다.


---
References: 김영한의 스프링 DB 2편

Links to this page: 