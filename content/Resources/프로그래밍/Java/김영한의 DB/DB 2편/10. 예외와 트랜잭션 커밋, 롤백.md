---
title: 
tags:
  - java
  - programming
  - transaction
  - exception
publish: true
date: 2024-12-27
---
## 예외와 트랜잭션 커밋, 롤백 - 기본

예외가 발생했는데, 내부에서 예외를 처리하지 못하고 트랜잭션 범위 밖(`@Transactional이 적용된 AOP`)으로 예외를 던지면 어떻게 될까?

![[transaction-exception-1.png]]

예외 발생 시 스프링 트랜잭션 AOP는 예외의 종류에 따라 트랜잭션을 커밋하거나 롤백한다.
- 언체크 예외인 `RuntimeException`, `Error`와 그 하위 예외가 발생하면 트랜잭션을 롤백한다.
- 체크 예외인 `Exception`과 그 하위 예외가 발생하면 트랜잭션을 커밋한다.

먼저 예제 코드를 작성하기 전에 트랜잭션의 작동을 로그로 확인하기 위해 다음 설정을 추가한다.
```properties title="application.properties"
logging.level.org.springframework.transaction.interceptor=TRACE  
logging.level.org.springframework.jdbc.datasource.DataSourceTransactionManager=DEBUG  
#JPA log  
logging.level.org.springframework.orm.jpa.JpaTransactionManager=DEBUG  
logging.level.org.hibernate.resource.transaction=DEBUG
```


```java
@SpringBootTest  
public class RollbackTest {  
  
    @Autowired  
    RollbackService service;  
  
    @Test  
    void runtimeException() {  
        Assertions.assertThatThrownBy(() -> service.runtimeException())  
                .isInstanceOf(RuntimeException.class);  
    }  
  
    @Test  
    void checkedException() {  
        Assertions.assertThatThrownBy(() -> service.checkedException())  
                .isInstanceOf(MyException.class);  
    }  
  
    @Test  
    void rollbackFor() {  
        Assertions.assertThatThrownBy(() -> service.rollbackFor())  
                .isInstanceOf(MyException.class);  
    }  
  
    @TestConfiguration  
    static class RollbackTestConfig {  
        @Bean  
        RollbackService rollbackService() {  
            return new RollbackService();  
        }  
    }  
  
  
    @Slf4j  
    static class RollbackService {  
        // 런타임 예외 발생 -> 롤백  
        @Transactional  
        public void runtimeException() {  
            log.info("call runtimeException");  
            throw new RuntimeException();  
        }  
  
        // 체크 예외 발생 -> 커밋  
        @Transactional  
        public void checkedException() throws Exception {  
            log.info("call checkedException");  
            throw new MyException();  
        }  
  
        // 체크 예외 발생 -> rollbackFor -> 롤백  
        @Transactional(rollbackFor = MyException.class)  
        public void rollbackFor() throws Exception {  
            log.info("call rollbackFor");  
            throw new MyException();  
        }  
    }  
  
    static class MyException extends Exception {  
    }  
}
```

테스트를 하나씩 실행해보면 앞서 학습한 대로, 다음과 같이 동작한다.
- `runtimeException()`: 롤백
- `checkedException()`: 커밋
- `rollbackFor()`: 롤백

## 예외와 트랜잭션 커밋, 롤백 - 활용
스프링은 도대체 왜 체크 예외는 커밋하고, 언체크 예외는 롤백할까? 스프링은 기본적으로 **체크 예외는 비즈니스 의미가 있을 때 사용**하고, **런타임 예외는 복구 불가능한 예외**로 가정한다. 참고로 꼭 이런 정책을 따를 필요는 없다.

그런데 비즈니스 의미가 있는 **비즈니스 예외**가 도대체 무슨 뜻일까?




---
References: 김영한의 스프링 DB 2편

Links to this page: 