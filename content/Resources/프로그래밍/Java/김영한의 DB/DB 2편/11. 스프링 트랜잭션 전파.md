---
title: 
tags:
  - java
  - programming
  - spring
  - transaction
  - propagation
publish: true
date: 2024-12-27
---
## 스프링 트랜잭션 전파 1 - 커밋, 롤백
트랜잭션이 둘 이상 있을 때는 어떻게 동작하는 지 알아보고, 스프링이 제공하는 트랜잭션 전파(propagation)라는 개념도 알아본다. 트랜잭션 전파를 이해하는 과정을 통해서 스프링 트랜잭션의 동작 과정도 좀 더 심도 있게 이해하는 것이 목표다.

먼저 간단한 스프링 트랜잭션 코드를 통해 기본 원리를 학습하고, 실제 예제를 통해 활용법을 학습한다.

```java
@SpringBootTest  
@Slf4j  
public class BasicTxTest {  
    @Autowired  
    PlatformTransactionManager txManager;  
  
    @TestConfiguration  
    static class Config {  
        @Bean  
        PlatformTransactionManager platformTransactionManager(DataSource dataSource) {  
            return new DataSourceTransactionManager(dataSource);  
        }  
    }  
  
    @Test  
    void commit() {  
        log.info("트랜잭션 시작");  
        TransactionStatus status = txManager.getTransaction(new DefaultTransactionAttribute());  
  
        log.info("트랜잭션 커밋 시작");  
        txManager.commit(status);  
        log.info("트랜잭션 커밋 완료");  
    }  
  
    @Test  
    void rollback() {  
        log.info("트랜잭션 시작");  
        TransactionStatus status = txManager.getTransaction(new DefaultTransactionAttribute());  
          
        log.info("트랜잭션 롤백 시작");  
        txManager.rollback(status);  
        log.info("트랜잭션 롤백 완료");  
    }  
}
```

위 코드는 단순히 스프링이 기본 등록하는 트랜잭션 매니저 대신 `DataSourceTransactionManager`를 빈으로 등록하고 사용한다. 커밋과 롤백이 정상적으로 작동하는지 확인하는 과정이고, 결과는 의도한대로 동작한다.

#### 트랜잭션 두 번 사용
이 예제는 트랜잭션1이 완전히 끝나고 나서 트랜잭션 2를 수행한다.

```java
@Test  
void double_commit() {  
    log.info("트랜잭션1 시작");  
    TransactionStatus tx1 = txManager.getTransaction(new DefaultTransactionAttribute());  
    log.info("트랜잭션1 커밋");  
    txManager.commit(tx1);  
  
    log.info("트랜잭션2 시작");  
    TransactionStatus tx2 = txManager.getTransaction(new DefaultTransactionAttribute());  
    log.info("트랜잭션2 커밋");  
    txManager.commit(tx2);  
}
```

`double_commit()`의 출력 결과를 살펴보면 다음과 같다.

```
2024-12-27T20:58:57.910+09:00  INFO 3513 --- [springtx] [    Test worker] hello.springtx.propagation.BasicTxTest   : 트랜잭션1 시작
2024-12-27T20:58:57.911+09:00 DEBUG 3513 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Creating new transaction with name [null]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
2024-12-27T20:58:57.913+09:00 DEBUG 3513 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Acquired Connection [HikariProxyConnection@903167192 wrapping conn0: url=jdbc:h2:mem:a298ca63-c14c-4b29-9f7d-bd7f7dcc42f5 user=SA] for JDBC transaction
2024-12-27T20:58:57.914+09:00 DEBUG 3513 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Switching JDBC Connection [HikariProxyConnection@903167192 wrapping conn0: url=jdbc:h2:mem:a298ca63-c14c-4b29-9f7d-bd7f7dcc42f5 user=SA] to manual commit
2024-12-27T20:58:57.914+09:00  INFO 3513 --- [springtx] [    Test worker] hello.springtx.propagation.BasicTxTest   : 트랜잭션1 커밋
2024-12-27T20:58:57.914+09:00 DEBUG 3513 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Initiating transaction commit
2024-12-27T20:58:57.914+09:00 DEBUG 3513 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Committing JDBC transaction on Connection [HikariProxyConnection@903167192 wrapping conn0: url=jdbc:h2:mem:a298ca63-c14c-4b29-9f7d-bd7f7dcc42f5 user=SA]
2024-12-27T20:58:57.915+09:00 DEBUG 3513 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection [HikariProxyConnection@903167192 wrapping conn0: url=jdbc:h2:mem:a298ca63-c14c-4b29-9f7d-bd7f7dcc42f5 user=SA] after transaction
2024-12-27T20:58:57.915+09:00  INFO 3513 --- [springtx] [    Test worker] hello.springtx.propagation.BasicTxTest   : 트랜잭션2 시작
2024-12-27T20:58:57.915+09:00 DEBUG 3513 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Creating new transaction with name [null]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
2024-12-27T20:58:57.915+09:00 DEBUG 3513 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Acquired Connection [HikariProxyConnection@1834816004 wrapping conn0: url=jdbc:h2:mem:a298ca63-c14c-4b29-9f7d-bd7f7dcc42f5 user=SA] for JDBC transaction
2024-12-27T20:58:57.915+09:00 DEBUG 3513 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Switching JDBC Connection [HikariProxyConnection@1834816004 wrapping conn0: url=jdbc:h2:mem:a298ca63-c14c-4b29-9f7d-bd7f7dcc42f5 user=SA] to manual commit
2024-12-27T20:58:57.915+09:00  INFO 3513 --- [springtx] [    Test worker] hello.springtx.propagation.BasicTxTest   : 트랜잭션2 커밋
2024-12-27T20:58:57.915+09:00 DEBUG 3513 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Initiating transaction commit
2024-12-27T20:58:57.915+09:00 DEBUG 3513 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Committing JDBC transaction on Connection [HikariProxyConnection@1834816004 wrapping conn0: url=jdbc:h2:mem:a298ca63-c14c-4b29-9f7d-bd7f7dcc42f5 user=SA]
2024-12-27T20:58:57.915+09:00 DEBUG 3513 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection [HikariProxyConnection@1834816004 wrapping conn0: url=jdbc:h2:mem:a298ca63-c14c-4b29-9f7d-bd7f7dcc42f5 user=SA] after transaction
```

트랜잭션을 시작하면 커넥션 풀에서 `tx1`과 `tx2`가 동일한 커넥션을 획득하고, 커밋하고 반납하는 정상적인 흐름이다. 

```
Acquired Connection [HikariProxyConnection@903167192 wrapping conn0: url=jdbc:h2:mem:a298ca63-c14c-4b29-9f7d-bd7f7dcc42f5 user=SA] for JDBC transaction
Acquired Connection [HikariProxyConnection@1834816004 wrapping conn0: url=jdbc:h2:mem:a298ca63-c14c-4b29-9f7d-bd7f7dcc42f5 user=SA] for JDBC transaction
```

- **트랜잭션1**: HikariProxyConnection@903167192
- **트랜잭션2**: HikariProxyConnection@1834816004

로그를 살펴보면 이 두 커넥션은 물리적으로는 동일한 커넥션이지만, 다르게 보인다. 히카리 커넥션 풀이 반환해주는 커넥션을 다루는 프록시인 `HikariProxyConnection`의 객체 주소가 다른 것이다. 결과적으로 동일한 `conn0` 커넥션을 사용한 것이다.

- 쉽게 말해서, 히카리 커넥션 풀에서 커넥션을 획득하게 되면 커넥션을 온전히 획득하는 것이 아니라, `HikariProxyConnection`이라는 객체로 한번 래핑해서 반환한다.
- 따라서 `HikariProxyConnection`의 주소는 달라지지만 결과적으로 동일한 커넥션을 재사용 한 것이다.

위에 이야기한대로 동일한 커넥션을 재사용 한 것이지만, `트랜잭션1`과 `트랜잭션2`는 서로 완전히 독립되어 있다. 다음의 그림을 참고하자.

![[propagation-1.png]]
- 트랜잭션이 각각 수행되면서 사용되는 DB 커넥션도 각각 다르다.
- 이 경우 트랜잭션을 각자 관리하기 때문에 전체 트랜잭션을 묶을 수 없다. 
	- 예: `트랜잭션1`이 커밋하고, `트랜잭션2`가 롤백하는 경우 `트랜잭션1`에서 저장한 데이터는 커밋, `트랜잭션2`에서 저장한 데이터는 롤백된다.

다음의 예제를 실행하고 그 결과를 확인해보자.

```java
@Test  
void double_commit_rollback() {  
    log.info("트랜잭션1 시작");  
    TransactionStatus tx1 = txManager.getTransaction(new DefaultTransactionAttribute());  
    log.info("트랜잭션1 커밋");  
    txManager.commit(tx1);  
  
    log.info("트랜잭션2 시작");  
    TransactionStatus tx2 = txManager.getTransaction(new DefaultTransactionAttribute());  
    log.info("트랜잭션2 롤백");  
    txManager.rollback(tx2);  
}
```

이 예제 메서드 `double_commit_rollback()`의 `트랜잭션1`은 커밋되고 `트랜잭션2`는 롤백된다.

```
2024-12-27T21:12:53.841+09:00  INFO 3864 --- [springtx] [    Test worker] hello.springtx.propagation.BasicTxTest   : 트랜잭션1 시작
2024-12-27T21:12:53.842+09:00 DEBUG 3864 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Creating new transaction with name [null]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
2024-12-27T21:12:53.843+09:00 DEBUG 3864 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Acquired Connection [HikariProxyConnection@1660678061 wrapping conn0: url=jdbc:h2:mem:2e71a48f-441e-4b52-aeb7-d9d2677d872f user=SA] for JDBC transaction
2024-12-27T21:12:53.844+09:00 DEBUG 3864 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Switching JDBC Connection [HikariProxyConnection@1660678061 wrapping conn0: url=jdbc:h2:mem:2e71a48f-441e-4b52-aeb7-d9d2677d872f user=SA] to manual commit
2024-12-27T21:12:53.844+09:00  INFO 3864 --- [springtx] [    Test worker] hello.springtx.propagation.BasicTxTest   : 트랜잭션1 커밋
2024-12-27T21:12:53.845+09:00 DEBUG 3864 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Initiating transaction commit
2024-12-27T21:12:53.845+09:00 DEBUG 3864 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Committing JDBC transaction on Connection [HikariProxyConnection@1660678061 wrapping conn0: url=jdbc:h2:mem:2e71a48f-441e-4b52-aeb7-d9d2677d872f user=SA]
2024-12-27T21:12:53.846+09:00 DEBUG 3864 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection [HikariProxyConnection@1660678061 wrapping conn0: url=jdbc:h2:mem:2e71a48f-441e-4b52-aeb7-d9d2677d872f user=SA] after transaction
2024-12-27T21:12:53.846+09:00  INFO 3864 --- [springtx] [    Test worker] hello.springtx.propagation.BasicTxTest   : 트랜잭션2 시작
2024-12-27T21:12:53.846+09:00 DEBUG 3864 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Creating new transaction with name [null]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
2024-12-27T21:12:53.846+09:00 DEBUG 3864 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Acquired Connection [HikariProxyConnection@1399108737 wrapping conn0: url=jdbc:h2:mem:2e71a48f-441e-4b52-aeb7-d9d2677d872f user=SA] for JDBC transaction
2024-12-27T21:12:53.846+09:00 DEBUG 3864 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Switching JDBC Connection [HikariProxyConnection@1399108737 wrapping conn0: url=jdbc:h2:mem:2e71a48f-441e-4b52-aeb7-d9d2677d872f user=SA] to manual commit
2024-12-27T21:12:53.846+09:00  INFO 3864 --- [springtx] [    Test worker] hello.springtx.propagation.BasicTxTest   : 트랜잭션2 롤백
2024-12-27T21:12:53.846+09:00 DEBUG 3864 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Initiating transaction rollback
2024-12-27T21:12:53.846+09:00 DEBUG 3864 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Rolling back JDBC transaction on Connection [HikariProxyConnection@1399108737 wrapping conn0: url=jdbc:h2:mem:2e71a48f-441e-4b52-aeb7-d9d2677d872f user=SA]
2024-12-27T21:12:53.846+09:00 DEBUG 3864 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection [HikariProxyConnection@1399108737 wrapping conn0: url=jdbc:h2:mem:2e71a48f-441e-4b52-aeb7-d9d2677d872f user=SA] after transaction
```

커넥션 풀에서 획득한 커넥션은 물리적으로 동일한 커넥션 `conn0`이지만, `트랜잭션1`이 종료되고 반납 후에 `트랜잭션2`에서 다시 획득하여 사용하기 때문에 논리적으로는 독립적인 커넥션이라고 이해하는 것이 쉽다. 따라서 데이터베이스 입장에서 본다면 서로 다른 커넥션이라 서로간에 어떤 영향을 주거나 받지 않는다. 당연한 사실이다.

---
References: 김영한 스프링 DB 2편

Links to this page: 