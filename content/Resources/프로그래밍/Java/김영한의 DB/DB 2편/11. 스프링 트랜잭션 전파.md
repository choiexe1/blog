---
title: 
tags:
  - java
  - programming
  - spring
  - transaction
  - propagation
publish: true
date: 2024-12-27
---
## 스프링 트랜잭션 전파 1 - 커밋, 롤백
트랜잭션이 둘 이상 있을 때는 어떻게 동작하는 지 알아보고, 스프링이 제공하는 트랜잭션 전파(propagation)라는 개념도 알아본다. 트랜잭션 전파를 이해하는 과정을 통해서 스프링 트랜잭션의 동작 과정도 좀 더 심도 있게 이해하는 것이 목표다.

먼저 간단한 스프링 트랜잭션 코드를 통해 기본 원리를 학습하고, 실제 예제를 통해 활용법을 학습한다.

```java
@SpringBootTest  
@Slf4j  
public class BasicTxTest {  
    @Autowired  
    PlatformTransactionManager txManager;  
  
    @TestConfiguration  
    static class Config {  
        @Bean  
        PlatformTransactionManager platformTransactionManager(DataSource dataSource) {  
            return new DataSourceTransactionManager(dataSource);  
        }  
    }  
  
    @Test  
    void commit() {  
        log.info("트랜잭션 시작");  
        TransactionStatus status = txManager.getTransaction(new DefaultTransactionAttribute());  
  
        log.info("트랜잭션 커밋 시작");  
        txManager.commit(status);  
        log.info("트랜잭션 커밋 완료");  
    }  
  
    @Test  
    void rollback() {  
        log.info("트랜잭션 시작");  
        TransactionStatus status = txManager.getTransaction(new DefaultTransactionAttribute());  
          
        log.info("트랜잭션 롤백 시작");  
        txManager.rollback(status);  
        log.info("트랜잭션 롤백 완료");  
    }  
}
```

위 코드는 단순히 스프링이 기본 등록하는 트랜잭션 매니저 대신 `DataSourceTransactionManager`를 빈으로 등록하고 사용한다. 커밋과 롤백이 정상적으로 작동하는지 확인하는 과정이고, 결과는 의도한대로 동작한다.

#### 트랜잭션 두 번 사용
이 예제는 트랜잭션1이 완전히 끝나고 나서 트랜잭션 2를 수행한다.

```java
@Test  
void double_commit() {  
    log.info("트랜잭션1 시작");  
    TransactionStatus tx1 = txManager.getTransaction(new DefaultTransactionAttribute());  
    log.info("트랜잭션1 커밋");  
    txManager.commit(tx1);  
  
    log.info("트랜잭션2 시작");  
    TransactionStatus tx2 = txManager.getTransaction(new DefaultTransactionAttribute());  
    log.info("트랜잭션2 커밋");  
    txManager.commit(tx2);  
}
```

`double_commit()`의 출력 결과를 살펴보면 다음과 같다.

```
2024-12-27T20:58:57.910+09:00  INFO 3513 --- [springtx] [    Test worker] hello.springtx.propagation.BasicTxTest   : 트랜잭션1 시작
2024-12-27T20:58:57.911+09:00 DEBUG 3513 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Creating new transaction with name [null]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
2024-12-27T20:58:57.913+09:00 DEBUG 3513 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Acquired Connection [HikariProxyConnection@903167192 wrapping conn0: url=jdbc:h2:mem:a298ca63-c14c-4b29-9f7d-bd7f7dcc42f5 user=SA] for JDBC transaction
2024-12-27T20:58:57.914+09:00 DEBUG 3513 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Switching JDBC Connection [HikariProxyConnection@903167192 wrapping conn0: url=jdbc:h2:mem:a298ca63-c14c-4b29-9f7d-bd7f7dcc42f5 user=SA] to manual commit
2024-12-27T20:58:57.914+09:00  INFO 3513 --- [springtx] [    Test worker] hello.springtx.propagation.BasicTxTest   : 트랜잭션1 커밋
2024-12-27T20:58:57.914+09:00 DEBUG 3513 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Initiating transaction commit
2024-12-27T20:58:57.914+09:00 DEBUG 3513 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Committing JDBC transaction on Connection [HikariProxyConnection@903167192 wrapping conn0: url=jdbc:h2:mem:a298ca63-c14c-4b29-9f7d-bd7f7dcc42f5 user=SA]
2024-12-27T20:58:57.915+09:00 DEBUG 3513 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection [HikariProxyConnection@903167192 wrapping conn0: url=jdbc:h2:mem:a298ca63-c14c-4b29-9f7d-bd7f7dcc42f5 user=SA] after transaction
2024-12-27T20:58:57.915+09:00  INFO 3513 --- [springtx] [    Test worker] hello.springtx.propagation.BasicTxTest   : 트랜잭션2 시작
2024-12-27T20:58:57.915+09:00 DEBUG 3513 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Creating new transaction with name [null]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
2024-12-27T20:58:57.915+09:00 DEBUG 3513 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Acquired Connection [HikariProxyConnection@1834816004 wrapping conn0: url=jdbc:h2:mem:a298ca63-c14c-4b29-9f7d-bd7f7dcc42f5 user=SA] for JDBC transaction
2024-12-27T20:58:57.915+09:00 DEBUG 3513 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Switching JDBC Connection [HikariProxyConnection@1834816004 wrapping conn0: url=jdbc:h2:mem:a298ca63-c14c-4b29-9f7d-bd7f7dcc42f5 user=SA] to manual commit
2024-12-27T20:58:57.915+09:00  INFO 3513 --- [springtx] [    Test worker] hello.springtx.propagation.BasicTxTest   : 트랜잭션2 커밋
2024-12-27T20:58:57.915+09:00 DEBUG 3513 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Initiating transaction commit
2024-12-27T20:58:57.915+09:00 DEBUG 3513 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Committing JDBC transaction on Connection [HikariProxyConnection@1834816004 wrapping conn0: url=jdbc:h2:mem:a298ca63-c14c-4b29-9f7d-bd7f7dcc42f5 user=SA]
2024-12-27T20:58:57.915+09:00 DEBUG 3513 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection [HikariProxyConnection@1834816004 wrapping conn0: url=jdbc:h2:mem:a298ca63-c14c-4b29-9f7d-bd7f7dcc42f5 user=SA] after transaction
```

트랜잭션을 시작하면 커넥션 풀에서 `tx1`과 `tx2`가 동일한 커넥션을 획득하고, 커밋하고 반납하는 정상적인 흐름이다. 

```
Acquired Connection [HikariProxyConnection@903167192 wrapping conn0: url=jdbc:h2:mem:a298ca63-c14c-4b29-9f7d-bd7f7dcc42f5 user=SA] for JDBC transaction
Acquired Connection [HikariProxyConnection@1834816004 wrapping conn0: url=jdbc:h2:mem:a298ca63-c14c-4b29-9f7d-bd7f7dcc42f5 user=SA] for JDBC transaction
```

- **트랜잭션1**: HikariProxyConnection@903167192
- **트랜잭션2**: HikariProxyConnection@1834816004

로그를 살펴보면 이 두 커넥션은 물리적으로는 동일한 커넥션이지만, 다르게 보인다. 히카리 커넥션 풀이 반환해주는 커넥션을 다루는 프록시인 `HikariProxyConnection`의 객체 주소가 다른 것이다. 결과적으로 동일한 `conn0` 커넥션을 사용한 것이다.

- 쉽게 말해서, 히카리 커넥션 풀에서 커넥션을 획득하게 되면 커넥션을 온전히 획득하는 것이 아니라, `HikariProxyConnection`이라는 객체로 한번 래핑해서 반환한다.
- 따라서 `HikariProxyConnection`의 주소는 달라지지만 결과적으로 동일한 커넥션을 재사용 한 것이다.

위에 이야기한대로 동일한 커넥션을 재사용 한 것이지만, `트랜잭션1`과 `트랜잭션2`는 서로 완전히 독립되어 있다. 다음의 그림을 참고하자.

![[propagation-1.png]]
- 트랜잭션이 각각 수행되면서 사용되는 DB 커넥션도 각각 다르다.
- 이 경우 트랜잭션을 각자 관리하기 때문에 전체 트랜잭션을 묶을 수 없다. 
	- 예: `트랜잭션1`이 커밋하고, `트랜잭션2`가 롤백하는 경우 `트랜잭션1`에서 저장한 데이터는 커밋, `트랜잭션2`에서 저장한 데이터는 롤백된다.

다음의 예제를 실행하고 그 결과를 확인해보자.

```java
@Test  
void double_commit_rollback() {  
    log.info("트랜잭션1 시작");  
    TransactionStatus tx1 = txManager.getTransaction(new DefaultTransactionAttribute());  
    log.info("트랜잭션1 커밋");  
    txManager.commit(tx1);  
  
    log.info("트랜잭션2 시작");  
    TransactionStatus tx2 = txManager.getTransaction(new DefaultTransactionAttribute());  
    log.info("트랜잭션2 롤백");  
    txManager.rollback(tx2);  
}
```

이 예제 메서드 `double_commit_rollback()`의 `트랜잭션1`은 커밋되고 `트랜잭션2`는 롤백된다.

```
2024-12-27T21:12:53.841+09:00  INFO 3864 --- [springtx] [    Test worker] hello.springtx.propagation.BasicTxTest   : 트랜잭션1 시작
2024-12-27T21:12:53.842+09:00 DEBUG 3864 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Creating new transaction with name [null]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
2024-12-27T21:12:53.843+09:00 DEBUG 3864 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Acquired Connection [HikariProxyConnection@1660678061 wrapping conn0: url=jdbc:h2:mem:2e71a48f-441e-4b52-aeb7-d9d2677d872f user=SA] for JDBC transaction
2024-12-27T21:12:53.844+09:00 DEBUG 3864 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Switching JDBC Connection [HikariProxyConnection@1660678061 wrapping conn0: url=jdbc:h2:mem:2e71a48f-441e-4b52-aeb7-d9d2677d872f user=SA] to manual commit
2024-12-27T21:12:53.844+09:00  INFO 3864 --- [springtx] [    Test worker] hello.springtx.propagation.BasicTxTest   : 트랜잭션1 커밋
2024-12-27T21:12:53.845+09:00 DEBUG 3864 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Initiating transaction commit
2024-12-27T21:12:53.845+09:00 DEBUG 3864 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Committing JDBC transaction on Connection [HikariProxyConnection@1660678061 wrapping conn0: url=jdbc:h2:mem:2e71a48f-441e-4b52-aeb7-d9d2677d872f user=SA]
2024-12-27T21:12:53.846+09:00 DEBUG 3864 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection [HikariProxyConnection@1660678061 wrapping conn0: url=jdbc:h2:mem:2e71a48f-441e-4b52-aeb7-d9d2677d872f user=SA] after transaction
2024-12-27T21:12:53.846+09:00  INFO 3864 --- [springtx] [    Test worker] hello.springtx.propagation.BasicTxTest   : 트랜잭션2 시작
2024-12-27T21:12:53.846+09:00 DEBUG 3864 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Creating new transaction with name [null]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
2024-12-27T21:12:53.846+09:00 DEBUG 3864 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Acquired Connection [HikariProxyConnection@1399108737 wrapping conn0: url=jdbc:h2:mem:2e71a48f-441e-4b52-aeb7-d9d2677d872f user=SA] for JDBC transaction
2024-12-27T21:12:53.846+09:00 DEBUG 3864 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Switching JDBC Connection [HikariProxyConnection@1399108737 wrapping conn0: url=jdbc:h2:mem:2e71a48f-441e-4b52-aeb7-d9d2677d872f user=SA] to manual commit
2024-12-27T21:12:53.846+09:00  INFO 3864 --- [springtx] [    Test worker] hello.springtx.propagation.BasicTxTest   : 트랜잭션2 롤백
2024-12-27T21:12:53.846+09:00 DEBUG 3864 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Initiating transaction rollback
2024-12-27T21:12:53.846+09:00 DEBUG 3864 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Rolling back JDBC transaction on Connection [HikariProxyConnection@1399108737 wrapping conn0: url=jdbc:h2:mem:2e71a48f-441e-4b52-aeb7-d9d2677d872f user=SA]
2024-12-27T21:12:53.846+09:00 DEBUG 3864 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection [HikariProxyConnection@1399108737 wrapping conn0: url=jdbc:h2:mem:2e71a48f-441e-4b52-aeb7-d9d2677d872f user=SA] after transaction
```

커넥션 풀에서 획득한 커넥션은 물리적으로 동일한 커넥션 `conn0`이지만, `트랜잭션1`이 종료되고 반납 후에 `트랜잭션2`에서 다시 획득하여 사용하기 때문에 논리적으로는 독립적인 커넥션이라고 이해하는 것이 쉽다. 따라서 데이터베이스 입장에서 본다면 서로 다른 커넥션이라 서로간에 어떤 영향을 주거나 받지 않는다. 당연한 사실이다.

## 스프링 트랜잭션 전파 - 전파 기본

![[스프링 트랜잭션 전파.png]]

마인드맵 형태로 정리한 핵심 내용이다. 다음은 예제를 작성하고 실행해본다.

```java
@Test  
void inner_commit() {  
    log.info("외부 트랜잭션 시작");  
    TransactionStatus outer = txManager.getTransaction(new DefaultTransactionAttribute());  
    log.info("outer.isNewTransaction() = {}", outer.isNewTransaction());  
  
    log.info("내부 트랜잭션 시작");  
    TransactionStatus inner = txManager.getTransaction(new DefaultTransactionAttribute());  
    log.info("inner.isNewTransaction() = {}", inner.isNewTransaction());  
    log.info("내부 트랜잭션 커밋");  
    txManager.commit(inner);  
  
    log.info("외부 트랜잭션 커밋");  
    txManager.commit(outer);  
}
```

로그를 살펴보면 다음과 같다.

```
2024-12-28T20:29:34.982+09:00  INFO 2820 --- [springtx] [    Test worker] hello.springtx.propagation.BasicTxTest   : 외부 트랜잭션 시작
2024-12-28T20:29:34.983+09:00 DEBUG 2820 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Creating new transaction with name [null]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
2024-12-28T20:29:34.984+09:00 DEBUG 2820 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Acquired Connection [HikariProxyConnection@48550482 wrapping conn0: url=jdbc:h2:mem:ae6f759f-e42f-4ec4-9fb2-071304a8ea3f user=SA] for JDBC transaction
2024-12-28T20:29:34.984+09:00 DEBUG 2820 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Switching JDBC Connection [HikariProxyConnection@48550482 wrapping conn0: url=jdbc:h2:mem:ae6f759f-e42f-4ec4-9fb2-071304a8ea3f user=SA] to manual commit
2024-12-28T20:29:34.985+09:00  INFO 2820 --- [springtx] [    Test worker] hello.springtx.propagation.BasicTxTest   : outer.isNewTransaction() = true
2024-12-28T20:29:34.985+09:00  INFO 2820 --- [springtx] [    Test worker] hello.springtx.propagation.BasicTxTest   : 내부 트랜잭션 시작
2024-12-28T20:29:34.985+09:00 DEBUG 2820 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Participating in existing transaction
2024-12-28T20:29:34.985+09:00  INFO 2820 --- [springtx] [    Test worker] hello.springtx.propagation.BasicTxTest   : inner.isNewTransaction() = false
2024-12-28T20:29:34.985+09:00  INFO 2820 --- [springtx] [    Test worker] hello.springtx.propagation.BasicTxTest   : 내부 트랜잭션 커밋
2024-12-28T20:29:34.985+09:00  INFO 2820 --- [springtx] [    Test worker] hello.springtx.propagation.BasicTxTest   : 외부 트랜잭션 커밋
2024-12-28T20:29:34.986+09:00 DEBUG 2820 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Initiating transaction commit
2024-12-28T20:29:34.986+09:00 DEBUG 2820 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Committing JDBC transaction on Connection [HikariProxyConnection@48550482 wrapping conn0: url=jdbc:h2:mem:ae6f759f-e42f-4ec4-9fb2-071304a8ea3f user=SA]
2024-12-28T20:29:34.986+09:00 DEBUG 2820 --- [springtx] [    Test worker] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection [HikariProxyConnection@48550482 wrapping conn0: url=jdbc:h2:mem:ae6f759f-e42f-4ec4-9fb2-071304a8ea3f user=SA] after transaction
```

트랜잭션 전파 원칙처럼, 외부 트랜잭션이 시작되고 내부 트랜잭션이 시작되면 하나의 물리 트랜잭션으로 동작한다. 즉, 내부 트랜잭션 `inner`가 외부 트랜잭션 `outer`의 트랜잭션에 참여한 것이다.

- 외부 트랜잭션 `outer`는 `isNewTransaction()`이 `true`이다. 처음 수행된 신규 트랜잭션이라는 의미다.
- 내부 트랜잭션 `innter`는 `isNewTransaction()`이 `false`이다. 이 경우 신규 트랜잭션이 아니다.

위 예제 코드를 다시 살펴보면 `txManager.commit()`이 두 번 호출된 것을 알 수 있다. 이처럼 스프링은 어떻게 두 논리 트랜잭션을 묶어서 하나의 물리 트랜잭션으로 동작하게 하는지 자세히 알아보자.

먼저 출력된 로그를 한 줄씩 천천히 살펴보면 `Participating in existing transaction`라는 로그가 있다. 기존 트랜잭션에 참여한다는 로그다. 그 이후에 내부 트랜잭션을 커밋했는데, 커밋되지 않았음을 알 수 있다. 그러니까 실제로 내부 트랜잭션에서는 커밋하지 않고 아무것도 하지 않는다.

스프링은 이렇게 여러 트랜잭션이 함께 사용 되는 경우, **처음 트랜잭션을 시작한 외부 트랜잭션이 실제 물리 트랜잭션을 관리**하도록 한다. 쉽게 이야기 하면 외부 트랜잭션이 커밋해야만 커밋된다는 것이다.

![[spring-transaction-propagation-1.png]]

그림으로 살펴보면 조금 복잡해보이지만 핵심은 외부 트랜잭션 `outer`에서 트랜잭션을 시작하면, 해당 트랜잭션을 수행중인 커넥션을 가지고 계속 사용하는 것이다.

쉽게 말해서 내부 트랜잭션 `inner`에서는 트랜잭션 매니저를 통해, 기존 트랜잭션이 존재하는지 확인하고 이 경우에는 기존 트랜잭션이 존재하므로 해당 트랜잭션에 참여한다. 즉, 참여는 기존 트랜잭션을 이용한다는 의미다. 이렇게 두 논리 트랜잭션이 물리 트랜잭션으로 묶일 수 있게 된다.

내부 트랜잭션 `inner`에서 커밋을 호출해도 실제 커밋을 호출하지 않는다. 왜냐하면 내부 트랜잭션에서 커밋을 호출하게되면 결과적으로 물리 트랜잭션이 모두 끝나버리기 때문이다.

> [!summary] 예제 핵심 정리
> 처음 트랜잭션을 시작한 외부 트랜잭션은 `isNewTransaction()`이 `true`이다.
> 
> 스프링은 트랜잭션을 시작한 외부 트랜잭션 `outer`가 물리 트랜잭션을 관리하도록 하므로 이 경우 `commit()`을 호출하면 물리 커밋 된다. (실제 데이터베이스에 커밋) 그러나 해당 트랜잭션에 참여하는 내부 트랜잭션 `inner`는 신규 트랜잭션이 아니므로 `isNewTransaction()`이 `false`다. 
> 
> 따라서 `commit()`을 호출해도 실제 커밋을 호출하지는 않는다.

#### 외부 트랜잭션 롤백 케이스

```java
@Test  
void outer_rollabck() {  
    log.info("외부 트랜잭션 시작");  
    TransactionStatus outer = txManager.getTransaction(new DefaultTransactionAttribute());  
    log.info("outer.isNewTransaction() = {}", outer.isNewTransaction());  
  
    log.info("내부 트랜잭션 시작");  
    TransactionStatus inner = txManager.getTransaction(new DefaultTransactionAttribute());  
    log.info("inner.isNewTransaction() = {}", inner.isNewTransaction());  
    log.info("내부 트랜잭션 커밋");  
    txManager.commit(inner);  
  
    log.info("외부 트랜잭션 롤백");  
    txManager.rollback(outer);  
}
```

이 경우에 당연하게도 내부 트랜잭션도 모두 롤백된다. 그냥 물리 트랜잭션 단위 하나가 롤백되는 것이다. 단순하다.


---
References: 김영한 스프링 DB 2편

Links to this page: 