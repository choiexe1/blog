---
title: 
tags:
  - programming
  - sql
  - database
  - lock
  - transaction
  - java
  - spring
publish: true
date: 2024-12-12
---
## 트랜잭션 적용 1
이전 [[3. 트랜잭션 이해]]에선 트랜잭션에 대한 개념과 오토 커밋, 수동 커밋의 차이 그리고 DB 락에 대해 학습했다.

이번엔 실제 어플리케이션에서 DB 트랜잭션을 사용해서 계좌이체 같이 원자성이 중요한 비즈니스 로직을 어떻게 구현하는지 알아본다.

먼저 트랜잭션 없이 단순하게 계좌이체 비즈니스 로직만 구현해본다.

```java title="MemberServiceV1.java"
@RequiredArgsConstructor  
public class MemberServiceV1 {  
    private final MemberRepositoryV1 memberRepository;  
  
    public void transfer(String fromId, String toId, int money) throws SQLException {  
        Member fromMember = memberRepository.findById(fromId);  
        Member toMember = memberRepository.findById(toId);  
  
        memberRepository.update(fromId, fromMember.getMoney() - money);  
        validation(toMember);  
        memberRepository.update(toId, toMember.getMoney() + money);  
    }  
  
    private static void validation(Member toMember) {  
        if (toMember.getMemberId().equals("ex")) {  
            throw new IllegalStateException("이체 중 예외 발생");  
        }  
    }  
}
```

`transfer()`는 `fromId`의 회원을 조회해서 `toId`의 회원에게 `money`만큼의 돈을 이체하는 로직이다. 예외 상황을 테스트 해보기 위해 `toId`가 `ex`인 경우 예외를 발생 시킨다.

```java title="MemberServiceV1Test.java"
/**  
 * 기본 동작, 트랜잭션이 없어서 문제 발생  
 */  
class MemberServiceV1Test {  
    public static final String MEMBER_A = "memberA";  
    public static final String MEMBER_B = "memberB";  
    public static final String MEMBER_EX = "ex";  
  
    private MemberRepositoryV1 memberRepositoryV1;  
    private MemberServiceV1 memberServiceV1;  
  
    @BeforeEach  
    void beforeEach() {  
        DriverManagerDataSource dataSource = new DriverManagerDataSource(URL, USERNAME, PASSWORD);  
        memberRepositoryV1 = new MemberRepositoryV1(dataSource);  
        memberServiceV1 = new MemberServiceV1(memberRepositoryV1);  
    }

	@AfterEach  
	void afterEach() throws SQLException {  
	    memberRepositoryV1.delete(MEMBER_A);  
	    memberRepositoryV1.delete(MEMBER_B);  
	    memberRepositoryV1.delete(MEMBER_EX);  
	}
  
    @Test  
    @DisplayName("정상 이체")  
    void transfer() throws SQLException {  
        // GIVEN  
        Member memberA = new Member(MEMBER_A, 10000);  
        Member memberB = new Member(MEMBER_B, 10000);  
  
        memberRepositoryV1.save(memberA);  
        memberRepositoryV1.save(memberB);  
  
        // WHEN  
        memberServiceV1.transfer(memberA.getMemberId(), memberB.getMemberId(), 2000);  
  
        // THEN  
        Member findMemberA = memberRepositoryV1.findById(memberA.getMemberId());  
        Member findMemberB = memberRepositoryV1.findById(memberB.getMemberId());  
  
        Assertions.assertThat(findMemberA.getMoney()).isEqualTo(8000);  
        Assertions.assertThat(findMemberB.getMoney()).isEqualTo(12000);  
    }  
}
```

정상 이체 흐름의 테스트 코드는 잘 작동한다. 트랜잭션은 다음과 같이 트랜잭션 처리 중 예외가 발생할 때 진가를 발휘한다.

```java
@Test  
@DisplayName("이체중 예외 발생")  
void transferToEx() throws SQLException {  
    // GIVEN  
    Member memberA = new Member(MEMBER_A, 10000);  
    Member memberEx = new Member(MEMBER_EX, 10000);  
  
    memberRepositoryV1.save(memberA);  
    memberRepositoryV1.save(memberEx);  
  
    // WHEN  
    Assertions  
            .assertThatThrownBy(  
                    () -> memberServiceV1.transfer(memberA.getMemberId(), memberEx.getMemberId(), 2000))  
            .isInstanceOf(IllegalStateException.class);  
  
    // THEN  
    Member findMemberA = memberRepositoryV1.findById(memberA.getMemberId());  
    Member findMemberB = memberRepositoryV1.findById(memberEx.getMemberId());  
  
    Assertions.assertThat(findMemberA.getMoney()).isEqualTo(8000);  
    Assertions.assertThat(findMemberB.getMoney()).isEqualTo(10000);  
}
```

이 테스트는 이체 중에 예외가 발생해서 `memberA`의 돈만 2000원 감소하는 케이스를 테스트한다. 정확히 `memberA`의 돈만 줄어들고 예외가 발생한다.

## 트랜잭션 적용 2
이번에는 트랜잭션을 사용해서 발생한 문제점을 해결해본다. 그런데 어플리케이션에서 트랜잭션을 어떤 계층에 걸어야 할까?

쉽게 이야기해서 트랜잭션을 어디에서 시작하고, 어디에서 커밋해야 할까?

![[transaction-5.png]]
- 트랜잭션은 비즈니스 로직이 있는 **서비스 계층**에서 시작해야 한다. 비즈니스 로직이 잘못되면 해당 비즈니스 로직으로 인해 문제가 되는 부분을 함께 롤백해야 하기 때문이다.
- 그런데 트랜잭션을 시작하려면 커넥션이 필요하다. 결국 서비스 계층에서 커넥션을 만들고, 트랜잭션 커밋 이후에 커넥션을 종료해야 한다.
- 어플리케이션에서 DB 트랜잭션을 사용하려면 **트랜잭션을 사용하는 동안 같은 커넥션을 유지**해야 한다. 그래야 같은 세션을 사용할 수 있다.

---
References: 김영한의 스프링 DB 1편

Links to this page: [[3. 트랜잭션 이해]]