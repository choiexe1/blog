---
title: 
tags:
  - programming
  - sql
  - database
  - lock
  - transaction
  - java
  - spring
publish: true
date: 2024-12-12
---
## 트랜잭션 적용 1
이전 [[3. 트랜잭션 이해]]에선 트랜잭션에 대한 개념과 오토 커밋, 수동 커밋의 차이 그리고 DB 락에 대해 학습했다.

이번엔 실제 어플리케이션에서 DB 트랜잭션을 사용해서 계좌이체 같이 원자성이 중요한 비즈니스 로직을 어떻게 구현하는지 알아본다.

먼저 트랜잭션 없이 단순하게 계좌이체 비즈니스 로직만 구현해본다.

```java title="MemberServiceV1.java"
@RequiredArgsConstructor  
public class MemberServiceV1 {  
    private final MemberRepositoryV1 memberRepository;  
  
    public void transfer(String fromId, String toId, int money) throws SQLException {  
        Member fromMember = memberRepository.findById(fromId);  
        Member toMember = memberRepository.findById(toId);  
  
        memberRepository.update(fromId, fromMember.getMoney() - money);  
        validation(toMember);  
        memberRepository.update(toId, toMember.getMoney() + money);  
    }  
  
    private static void validation(Member toMember) {  
        if (toMember.getMemberId().equals("ex")) {  
            throw new IllegalStateException("이체 중 예외 발생");  
        }  
    }  
}
```

`transfer()`는 `fromId`의 회원을 조회해서 `toId`의 회원에게 `money`만큼의 돈을 이체하는 로직이다. 예외 상황을 테스트 해보기 위해 `toId`가 `ex`인 경우 예외를 발생 시킨다.

```java title="MemberServiceV1Test.java"
/**  
 * 기본 동작, 트랜잭션이 없어서 문제 발생  
 */  
class MemberServiceV1Test {  
    public static final String MEMBER_A = "memberA";  
    public static final String MEMBER_B = "memberB";  
    public static final String MEMBER_EX = "ex";  
  
    private MemberRepositoryV1 memberRepositoryV1;  
    private MemberServiceV1 memberServiceV1;  
  
    @BeforeEach  
    void beforeEach() {  
        DriverManagerDataSource dataSource = new DriverManagerDataSource(URL, USERNAME, PASSWORD);  
        memberRepositoryV1 = new MemberRepositoryV1(dataSource);  
        memberServiceV1 = new MemberServiceV1(memberRepositoryV1);  
    }

	@AfterEach  
	void afterEach() throws SQLException {  
	    memberRepositoryV1.delete(MEMBER_A);  
	    memberRepositoryV1.delete(MEMBER_B);  
	    memberRepositoryV1.delete(MEMBER_EX);  
	}
  
    @Test  
    @DisplayName("정상 이체")  
    void transfer() throws SQLException {  
        // GIVEN  
        Member memberA = new Member(MEMBER_A, 10000);  
        Member memberB = new Member(MEMBER_B, 10000);  
  
        memberRepositoryV1.save(memberA);  
        memberRepositoryV1.save(memberB);  
  
        // WHEN  
        memberServiceV1.transfer(memberA.getMemberId(), memberB.getMemberId(), 2000);  
  
        // THEN  
        Member findMemberA = memberRepositoryV1.findById(memberA.getMemberId());  
        Member findMemberB = memberRepositoryV1.findById(memberB.getMemberId());  
  
        Assertions.assertThat(findMemberA.getMoney()).isEqualTo(8000);  
        Assertions.assertThat(findMemberB.getMoney()).isEqualTo(12000);  
    }  
}
```

정상 이체 흐름의 테스트 코드는 잘 작동한다. 트랜잭션은 다음과 같이 트랜잭션 처리 중 예외가 발생할 때 진가를 발휘한다.

```java
@Test  
@DisplayName("이체중 예외 발생")  
void transferToEx() throws SQLException {  
    // GIVEN  
    Member memberA = new Member(MEMBER_A, 10000);  
    Member memberEx = new Member(MEMBER_EX, 10000);  
  
    memberRepositoryV1.save(memberA);  
    memberRepositoryV1.save(memberEx);  
  
    // WHEN  
    Assertions  
            .assertThatThrownBy(  
                    () -> memberServiceV1.transfer(memberA.getMemberId(), memberEx.getMemberId(), 2000))  
            .isInstanceOf(IllegalStateException.class);  
  
    // THEN  
    Member findMemberA = memberRepositoryV1.findById(memberA.getMemberId());  
    Member findMemberB = memberRepositoryV1.findById(memberEx.getMemberId());  
  
    Assertions.assertThat(findMemberA.getMoney()).isEqualTo(8000);  
    Assertions.assertThat(findMemberB.getMoney()).isEqualTo(10000);  
}
```

이 테스트는 이체 중에 예외가 발생해서 `memberA`의 돈만 2000원 감소하는 케이스를 테스트한다. 정확히 `memberA`의 돈만 줄어들고 예외가 발생한다.

## 트랜잭션 적용 2
이번에는 트랜잭션을 사용해서 발생한 문제점을 해결해본다. 그런데 어플리케이션에서 트랜잭션을 어떤 계층에 걸어야 할까?

쉽게 이야기해서 트랜잭션을 어디에서 시작하고, 어디에서 커밋해야 할까?

![[transaction-5.png]]
- 트랜잭션은 비즈니스 로직이 있는 **서비스 계층**에서 시작해야 한다. 비즈니스 로직이 잘못되면 해당 비즈니스 로직으로 인해 문제가 되는 부분을 함께 롤백해야 하기 때문이다.
- 그런데 트랜잭션을 시작하려면 커넥션이 필요하다. 결국 서비스 계층에서 커넥션을 만들고, 트랜잭션 커밋 이후에 커넥션을 종료해야 한다.
- 어플리케이션에서 DB 트랜잭션을 사용하려면 **트랜잭션을 사용하는 동안 같은 커넥션을 유지**해야 한다. 그래야 같은 세션을 사용할 수 있다.


![[transaction-6.png]]
어플리케이션에서 같은 커넥션을 유지하려면 어떻게 해야할까? 가장 단순한 방법은 커넥션을 파라미터로 전달해서 같은 커넥션이 사용되도록 유지하는 것이다.

먼저 리포지토리가 파라미터를 통해 같은 커넥션을 유지할 수 있도록 파라미터를 추가한 새로운 버전의 리포지토리를 구현한다.

```java title="MemberRepositoryV2.java"
public Member findById(Connection connection, String memberId) throws SQLException {  
    String sql = "SELECT * FROM member WHERE member_id = ?";  
  
    PreparedStatement statement = null;  
    ResultSet resultSet = null;  
  
    try {  
        statement = connection.prepareStatement(sql);  
        statement.setString(1, memberId);  
        resultSet = statement.executeQuery();  
  
        if (resultSet.next()) {  
            Member member = new Member();  
            member.setMemberId(resultSet.getString("member_id"));  
            member.setMoney(resultSet.getInt("money"));  
            return member;  
        } else {  
            throw new NoSuchElementException("Member not found memberId = " + memberId);  
        }  
  
    } catch (SQLException e) {  
        log.info("error", e);  
        throw e;  
    } finally {  
        // connection은 여기서 닫지 않는다.  
        JdbcUtils.closeResultSet(resultSet);  
        JdbcUtils.closeStatement(statement);  
        // JdbcUtils.closeConnection(connection);  
    }  
}

public void update(Connection connection, String memberId, int money) throws SQLException {  
    String sql = "UPDATE member SET money = ? WHERE member_id = ?";  
    PreparedStatement statement = null;  
  
    try {  
        statement = connection.prepareStatement(sql);  
        statement.setInt(1, money);  
        statement.setString(2, memberId);  
  
        int affectedRows = statement.executeUpdate();  
        log.info("affectedRows = {}", affectedRows);  
    } catch (SQLException e) {  
        log.error("db error", e);  
        throw e;  
    } finally {  
        // connection은 여기서 닫지 않는다.  
        JdbcUtils.closeStatement(statement);  
        // JdbcUtils.closeConnection(connection);  
    }  
}
```

`MemberRepositoryV2`는 기존 코드와 같고, 커넥션 유지가 필요한 다음 두 메서드가 추가 되었다. 다음 두 메서드는 계좌이체 서비스 로직에서 호출하는 메서드이다.

- `findById(Connection connection, String memberId)`
- `update(Connection connection, String memberId, int money)`

**주의 - 커넥션 종료**

- 커넥션 유지가 필요한 두 메서드는 파라미터로 넘어온 커넥션을 사용해야 한다. 따라서 `con = getConnection()`이 있으면 안된다.
- 커넥션 유지가 필요한 두 메서드는 리포지토리에서 커넥션을 닫으면 안된다. 커넥션을 전달 받은 리포지토리 뿐만 아니라 이후에도 커넥션을 계속 이어서 사용하기 때문이다. 이후 서비스 로직이 끝날 때 트랜잭션을 종료하고 닫아야 한다.

이제 새로운 리포지토리를 연동하는 새로운 버전의 서비스를 다음과 같이 구현한다.

```java title="MemberServiceV2.java"

```

---
References: 김영한의 스프링 DB 1편

Links to this page: [[3. 트랜잭션 이해]]