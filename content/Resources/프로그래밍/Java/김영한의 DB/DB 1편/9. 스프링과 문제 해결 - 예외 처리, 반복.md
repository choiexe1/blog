---
title: 
tags:
  - java
  - programming
  - spring
  - exception
publish: true
date: 2024-12-14
---
## 체크 예외와 인터페이스
서비스 계층은 가급적 특정 구현 기술에 의존하지 않고, 순수하게 유지하는 것이 좋다. 이렇게 하려면 예외에 대한 의존도 함께 해결해야 한다.

예를 들어서 서비스가 처리할 수 없는 `SQLException`에 대한 의존을 제거하려면 어떻게 해야할까?

서비스가 처리할 수 없으므로 리포지토리가 던지는 `SQLException` 체크 예외를 런타임 예외로 전환해서 서비스 계층에 던지면 서비스 계층이 해당 예외를 무시할 수 있기 때문에, 특정 구현 기술에 의존하는 부분을 제거하고 서비스 계층을 순수하게 유지할 수 있다.

### 인터페이스 도입
먼저 `MemberRepository` 인터페이스도 도입해서 구현 기술을 쉽게 변경할 수 있도록 변경한다.

```java
public interface MemberRepository {
	Member save(Member member);
	Member findById(String memberId);
	void update(String memberId, int money);
	void delete(String memberId);
}
```

그런데 앞서서 예제를 시작할 때부터 왜 이런 인터페이스를 만들지 않았을까? 바로 `SQLException`이 체크 예외이기 때문이다. 

체크 예외를 사용하려면 인터페이스에도 해당 체크 예외가 선언되어 있어야 한다. 예를 들면 다음과 같은 코드가 된다.

```java
public interface MemberRepositoryEx {
	Member save(Member member) throws SQLException;
	Member findById(String memberId) throws SQLException;
	void update(String memberId, int money) throws SQLException;
	void delete(String memberId) throws SQLException;
}
```

그런데 인터페이스가 이렇게 구현되면, 이미 인터페이스 자체가 순수하지 않고 `java.sql.SQLException` 이라는 특정 기술에 의존하게 된다.
#### 체크 예외 코드에 인터페이스 도입시 문제점 - 구현 클래스

```java
@Slf4j
public class MemberRepositoryV3 implements MemberRepositoryEx {
	public Member save(Member member) throws SQLException {
		String sql = "insert into member(member_id, money) values(?, ?)";
	}
}
```

인터페이스의 구현체가 체크 예외를 던지려면, 인터페이스 메서드에 먼저 체크 예외를 던지는 부분이 선언되어 있어야 한다. 그래야 구현 클래스의 메서드도 체크 예외를 던질 수 있다.

참고로 구현 클래스의 메서드에 선언할 수 있는 예외는 부모 타입에서 던진 예외와 같거나 하위 타입이어야 한다.

#### 특정 기술에 종속되는 인터페이스
구현 기술을 쉽게 변경하기 위해서 (OCP와 DI를 활용하기 위해서) 인터페이스를 도입하더라도 `SQLException`과 같은 특정 구현 기술에 종송적인 체크 예외를 사용하게 되면 인터페이스에도 해당 예외를 포함해야 한다.

하지만 이것은 우리가 원하던 순수한 인터페이스가 아니다. `JDBC`에 종속적인 인터페이스일 뿐이다.

인터페이스를 만드는 목적은 구현체를 쉽게 변경하기 위함인데, 이미 인터페이스가 특정 구현 기술에 오염이 되어 버렸다. 향후 `JDBC`가 아닌 다른 기술로 변경한다면 인터페이스 자체를 변경해야 한다.

#### 런타임 예외와 인터페이스
런타임 예외는 이런 부분에서 자유롭다. 인터페이스에 런타임 예외를 따로 선언하지 않아도 된다. 따라서 인터페이스가 특정 기술에 종속적일 필요가 없다.

## 런타임 예외 적용
실제 코드에 런타임 예외를 사용하도록 적용해본다.

```java
public class MyDbException extends RuntimeException {  
    public MyDbException() {  
    }  
  
    public MyDbException(String message) {  
        super(message);  
    }  
  
    public MyDbException(String message, Throwable cause) {  
        super(message, cause);  
    }  
  
    public MyDbException(Throwable cause) {  
        super(cause);  
    }  
}
```


```java title="MemberRepositoryV4_1.java"
/**  
 * 예외 누수 문제 해결  
 * 체크 예외를 런타임 예외로 변경   
* MemberRepository 인터페이스 의존  
 * throws SQLException 제거  
 */  
@Slf4j  
@RequiredArgsConstructor  
public class MemberRepositoryV4_1 implements MemberRepository {  
    private final DataSource dataSource;  
  
    @Override  
    public Member save(Member member) {  
        String sql = "INSERT INTO member(member_id, money) VALUES(?, ?)";  
  
        Connection connection = null;  
        PreparedStatement statement = null;  
  
        try {  
            connection = getConnection();  
            statement = connection.prepareStatement(sql);  
            statement.setString(1, member.getMemberId());  
            statement.setInt(2, member.getMoney());  
  
            statement.executeUpdate();  
  
            return member;  
        } catch (SQLException e) {  
            throw new MyDbException(e);  
        } finally {  
            close(connection, statement, null);  
        }  
    }  
  
    @Override  
    public void delete(String memberId) {  
        String sql = "DELETE FROM member WHERE member_id = ?";  
        Connection connection = null;  
        PreparedStatement statement = null;  
  
        try {  
            connection = getConnection();  
            statement = connection.prepareStatement(sql);  
            statement.setString(1, memberId);  
  
            int affectedRows = statement.executeUpdate();  
            log.info("affectedRows = {}", affectedRows);  
        } catch (SQLException e) {  
            throw new MyDbException(e);  
        } finally {  
            close(connection, statement, null);  
        }  
    }  
  
    @Override  
    public void update(String memberId, int money) {  
        String sql = "UPDATE member SET money = ? WHERE member_id = ?";  
        Connection connection = null;  
        PreparedStatement statement = null;  
  
        try {  
            connection = getConnection();  
            statement = connection.prepareStatement(sql);  
            statement.setInt(1, money);  
            statement.setString(2, memberId);  
  
            int affectedRows = statement.executeUpdate();  
            log.info("affectedRows = {}", affectedRows);  
        } catch (SQLException e) {  
            throw new MyDbException(e);  
        } finally {  
            close(connection, statement, null);  
        }  
    }  
  
    @Override  
    public Member findById(String memberId) {  
        String sql = "SELECT * FROM member WHERE member_id = ?";  
        Connection connection = null;  
        PreparedStatement statement = null;  
        ResultSet resultSet = null;  
  
        try {  
            connection = getConnection();  
            statement = connection.prepareStatement(sql);  
            statement.setString(1, memberId);  
            resultSet = statement.executeQuery();  
  
            if (resultSet.next()) {  
                Member member = new Member();  
                member.setMemberId(resultSet.getString("member_id"));  
                member.setMoney(resultSet.getInt("money"));  
                return member;  
            } else {  
                throw new NoSuchElementException("Member not found memberId = " + memberId);  
            }  
  
        } catch (SQLException e) {  
            throw new MyDbException(e);  
        } finally {  
            close(connection, statement, resultSet);  
        }  
    }  
  
    private void close(Connection connection, Statement statement, ResultSet resultSet) {  
        JdbcUtils.closeResultSet(resultSet);  
        JdbcUtils.closeStatement(statement);  
  
        // 주의! 트랜잭션 동기화를 사용하려면 DataSourceUtils를 사용해야 한다.  
        DataSourceUtils.releaseConnection(connection, dataSource);  
    }  
  
    private Connection getConnection() throws SQLException {  
        // 주의! 트랜잭션 동기화를 사용하려면 DataSourceUtils를 사용해야 한다.  
        Connection connection = DataSourceUtils.getConnection(dataSource);  
  
        log.info("getConnection = {}, class = {}", connection, connection.getClass());  
  
        return connection;  
    }  
}
```


---
References: 김영한의 스프링 DB 1편

Links to this page: 