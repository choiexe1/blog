---
title: 
tags:
  - java
  - programming
  - database
  - transaction
  - exception
  - spring
publish: true
date: 2024-12-14
---
## 자바 예외 이해
스프링이 제공하는 예외 추상화를 이해하기 위해서는 먼저 자바 기본 예외에 대한 이해가 필요하다.

앞서 예외에 대해 한번 학습했지만 다시 한번 예외의 기본 내용을 간단히 복습하고, 실무에 필요한 체크 예외와 언체크 예외의 차이와 활용 방안에 대해서도 알아본다.

## 예외 계층

![[예외계층.png]]

앞서 [[예외 계층]]에서 한번 학습한 내용이다.

- 예외도 객체이다. 모든 객체의 최상위 부모는 `Object`이므로 예외의 최상위 부모도 `Object`이다. 
- `Throwable`은 예외 객체 중 최상위 예외이다. 하위에 `Exception`과 `Error`가 있다.
	- `Error`는 메모리 부족이나 심각한 시스템 오류와 같이 어플리케이션에서 복구 불가능한 시스템 예외이다. 따라서 어플리케이션 개발자는 이 예외를 잡으려고 해서는 안된다.
	- 상위 예외를 `catch`로 잡게되면 그 하위 예외들도 함께 잡는다. 따라서 어플리케이션 로직에서는 `Throwable` 예외를 잡으면 안된다. 그 하위 객체인 `Error`도 함께 잡히기 때문이다. 따라서 어플리케이션 로직은 `Exception`부터 필요한 예외로 생각하고 잡으면 된다.
	- 참고로 `Error`도 언체크 예외이다.
- `Exception`은 체크 예외이고, 어플리케이션 로직에서 사용할 수 있는 실질적 최상위 예외이다.
	- `Exception`과 그 하위 예외는 모두 컴파일러가 체크하는 체크 예외이다. 단 `RuntimeException`은 언체크 예외이다.
- `RuntimeException`은 컴파일러가 체크하지 않는 언체크 예외이다.

## 예외 기본 규칙

![[예외처리.png]]

예외는 폭탄 돌리기와 같다. 잡아서 처리하거나 처리할 수 없으면 밖으로 던져야한다. 위 그림의 5번 과정에서 예외를 처리하면 이후에는 어플리케이션 로직이 정상 흐름으로 동작한다.

**예외는 다음의 두 가지 기본 규칙을 기억해야한다.**

- 예외는 반드시 잡아서 처리하거나, 던져야한다.
- 예외를 잡거나 던질 때 지정한 예외뿐만 아니라 그 예외의 자식들도 함께 처리된다.

**예외를  처리하지 못하고 계속 호출자에게 던지면?**
- 자바 `main()` 쓰레드의 경우 예외 로그를 출력하면서 시스템이 종료된다.
- 웹 어플리케이션의 경우 여러 사용자의 요청을 처리하기 때문에 하나의 예외 때문에 시스템이 종료되면 안된다. `WAS`가 해당 예외를 받아서 처리하는데, 주로 사용자에게 개발자가 지정한 오류 페이지를 보여준다.

> MVC 구조의 웹 어플리케이션에선 [[9. 예외 처리와 오류 페이지|예외 처리와 오류 페이지]]의 문서를 참고 하고, Restful API는 [[10. API 예외 처리|API 예외 처리]]를 참고하면 된다.

## 체크 예외 활용
그렇다면 언제 체크 예외를 사용하고 언제 언체크 예외를 사용하는게 좋을까?

**기본 원칙은 다음 두 가지다.**
- 기본적으로 언체크 예외를 사용
- 체크 예외는 비즈니스 로직상 의도적으로 던지는 예외에만 사용
	- 이 경우 해당 예외를 잡아서 반드시 처리해야 하는 문제일 때만 채크 예외를 사용한다.
	- 예)
		- 계좌이체 실패 예외
		- 결제시 포인트 부족 예외
		- 로그인 ID, PW 불일치 예외
	- 물론 이 경우에도 100% 체크 예외로 만들어야 하는 것은 아니다. 다만 계좌 이체 실패처럼 매우 심각한 문제는 개발자가 실수로 예외를 놓치면 안된다고 판단할 수 있다. 이 경우 체크 예외로 만들어 두면 컴파일러를 통해 놓친 예외를 인지할 수 있다.

#### 체크 예외 문제점

![[check-exception-1.png]]

- 리포지토리는 DB에 접근해서 데이터를 저장하고 관리한다. 여기서는 `SQLException` 체크 예외를 던진다.
- `NetworkClient` 는 외부 네트워크에 접속해서 어떤 기능을 처리하는 객체이다. 여기서는 `ConnectException` 체크 예외를 던진다.
- 서비스는 리포지토리와 `NetworkClient` 를 둘다 호출한다.
- 따라서 두 곳에서 올라오는 체크 예외인 `SQLException` 과 `ConnectException` 을 처리해야 한다.
- 그런데 서비스는 이 둘을 처리할 방법을 모른다. `ConnectException` 처럼 연결이 실패하거나,
- `SQLException` 처럼 데이터베이스에서 발생하는 문제처럼 심각한 문제들은 대부분 애플리케이션 로직에서 처리할 방법이 없다.
- 서비스는 `SQLException` 과 `ConnectException` 를 처리할 수 없으므로 둘다 밖으로 던진다.체크 예외이기 때문에 던질 경우 다음과 같이 선언해야 한다.
- `method() throws SQLException, ConnectException` 컨트롤러도 두 예외를 처리할 방법이 없다.

다음을 선언해서 예외를 밖으로 던진다.

`method() throws SQLException, ConnectException`

웹 애플리케이션이라면 서블릿의 오류 페이지나, 또는 스프링 MVC가 제공하는 `ControllerAdvice` 에서 이

런 예외를 공통으로 처리한다.

이런 문제들은 보통 사용자에게 어떤 문제가 발생했는지 자세히 설명하기가 어렵다. 그래서 사용자에게는

"서비스에 문제가 있습니다." 라는 일반적인 메시지를 보여준다. ("데이터베이스에 어떤 오류가 발생했어요"

라고 알려주어도 일반 사용자가 이해할 수 없다. 그리고 보안에도 문제가 될 수 있다.)

API라면 보통 HTTP 상태코드 500(내부 서버 오류)을 사용해서 응답을 내려준다.

이렇게 해결이 불가능한 공통 예외는 별도의 오류 로그를 남기고, 개발자가 오류를 빨리 인지할 수 있도록

메일, 알림(문자, 슬랙)등을 통해서 전달 받아야 한다. 예를 들어서 `SQLException` 이 잘못된 SQL을 작성

해서 발생했다면, 개발자가 해당 SQL을 수정해서 배포하기 전까지 사용자는 같은 문제를 겪게 된다.


**두 가지 문제**

지금까지 설명한 예시를 보면 대표적으로 두 가지 문제인 것을 알 수 있다.
- 복구 불가능한 예외
- 의존 관계에 대한 문제




---
References: 김영한의 스프링 DB 1편

Links to this page: [[예외 계층]], [[9. 예외 처리와 오류 페이지]], [[10. API 예외 처리]]