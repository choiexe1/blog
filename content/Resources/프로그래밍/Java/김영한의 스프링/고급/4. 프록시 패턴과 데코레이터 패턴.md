---
title: 
tags:
  - java
  - programming
  - design-pattern
  - proxy-pattern
  - decorator-pattern
  - spring
publish: true
date: 2025-01-01
---
## 예제 프로젝트 만들기 소개
이전 프로젝트를 기반으로 다양한 상황에서의 프록시 사용법을 이해하기 위해 다음과 같은 기준으로 기본 예제 프로젝트를 만들어본다. 

- **v1**: 인터페이스와 구현 클래스 - 스프링 빈으로 수동 등록
- **v2**: 인터페이스 없는 구체 클래스 - 스프링 빈으로 수동 등록
- **v3**: 컴포넌트 스캔으로 스프링 빈 자동 등록

실무에서는 스프링 빈으로 등록할 클래스는 인터페이스가 있는 경우도 있고, 없는 경우도 있다. 그리고 스프링 빈을 수동으로 직접 등록하는 경우도 있고 컴포넌트 스캔으로 등록하는 경우도 있다. 이런 다양한 케이스에 프록시를 어떻게 적용하는지 알아보기 위함이다.

## 예제 프로젝트 만들기 V1
먼저 인터페이스와 구현체로 나누어진 예제를 만들어본다.

```java title="인터페이스들"
public interface OrderRepositoryV1 {  
    void save(String itemId);  
}

public interface OrderServiceV1 {  
    void orderItem(String itemId);  
}

@RequestMapping // 스프링은 @Controller 또는 @RequestMapping 어노테이션이 있어야 스프링 컨트롤러로 인식  
@ResponseBody  
public interface OrderControllerV1 {  
  
    @GetMapping("/v1/request")  
    String reqeust(@RequestParam("itemId") String itemId);  
  
    @GetMapping("/v1/no-log")  
    String noLog();  
}
```

```java title="구현체들"
public class OrderRepositoryV1Impl implements OrderRepositoryV1 {  
    @Override  
    public void save(String itemId) {  
        if (itemId.equals("ex")) {  
            throw new IllegalStateException("예외 발생!");  
        }  
        sleep(1000);  
    }  
  
    private void sleep(int ms) {  
        try {  
            Thread.sleep(ms);  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
  
    }  
}

public class OrderServiceV1Impl implements OrderServiceV1{  
    private final OrderRepositoryV1 orderRepository;  
  
    public OrderServiceV1Impl(OrderRepositoryV1 orderRepository) {  
        this.orderRepository = orderRepository;  
    }  
  
    @Override  
    public void orderItem(String itemId) {  
        orderRepository.save(itemId);  
    }  
}

public class OrderControllerV1Impl implements OrderControllerV1{  
    private final OrderServiceV1 orderService;  
  
    public OrderControllerV1Impl(OrderServiceV1 orderService) {  
        this.orderService = orderService;  
    }  
  
    @Override  
    public String reqeust(String itemId) {  
        orderService.orderItem(itemId);  
        return "ok";  
    }  
  
    @Override  
    public String noLog() {  
        return "";  
    }  
}
```

이 구조의 예제에서 독특한 점은 컨트롤러가 인터페이스와 구현체로 나누어진다는 점이다. 다시 한번 컨트롤러 인터페이스를 살펴보면 다음과 같다.

```java
@RequestMapping  
@ResponseBody  
public interface OrderControllerV1 {  
  
    @GetMapping("/v1/request")  
    String reqeust(@RequestParam("itemId") String itemId);  
  
    @GetMapping("/v1/no-log")  
    String noLog();  
}
```

- `@RequestMapping`: 스프링 MVC는 `@Controller` 또는 `@RequestMapping` 어노테이션이 타입에 있어야 스프링 컨트롤러로 인식한다. 그리고 스프링 컨트롤러로 인식해야 `HTTP URL`이 매핑되고 동작한다. 이 어노테이션은 인터페이스에 사용해도 된다.
- `@ResponseBody`: HTTP 메시지 컨버터를 사용해서 응답한다. 이 어노테이션은 인터페이스에 사용해도 된다.
- 인터페이스에는 `@RequestParam`의 값을 생략하면 `itemId`를 컴파일 이후 자바 버전에 따라 인식하지 못할 수 있다. 인터페이스에서는 꼭 넣어줘야 한다. 클래스에서는 생략해도 대부분 잘 지원된다.

> [!warning] 스프링 부트 3.0 변경 사항
> 스프링 부트 3.0(스프링 프레임워크 6.0)부터는 클래스 레벨에 `@RequestMapping`이 있어도 스프링 컨트롤러로 인식하지 않는다. 오직 `@Controller`가 있어야 스프링 컨트롤러로 인식한다. 참고로 `@RestController`는 내부에 `@Controller` 어노테이션을 포함하므로 인식 된다.
> 
> 따라서 다음처럼 컨트롤러 인터페이스에 적용된 어노테이션을 변경해야 한다.
> `@RequestMapping` -> `@RestController`


## 예제 프로젝트 만들기 V2
이번에는 인터페이스가 없는 `Controller`, `Service`, `Repository`를 스프링 빈으로 수동 등록해본다.

```java
public class OrderRepositoryV2 {  
    public void save(String itemId) {  
        if (itemId.equals("ex")) {  
            throw new IllegalStateException("예외 발생!");  
        }  
        sleep(1000);  
    }  
  
    private void sleep(int ms) {  
        try {  
            Thread.sleep(ms);  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
    }  
}

public class OrderServiceV2 {  
    private final OrderRepositoryV2 orderRepository;  
  
    public OrderServiceV2(OrderRepositoryV2 orderRepository) {  
        this.orderRepository = orderRepository;  
    }  
  
    public void orderItem(String itemId) {  
        orderRepository.save(itemId);  
    }  
}

@Slf4j  
@RestController  
public class OrderControllerV2 {  
    private final OrderServiceV2 orderService;  
  
    public OrderControllerV2(OrderServiceV2 orderService) {  
        this.orderService = orderService;  
    }  
  
    @GetMapping("/v2/request")  
    public String reqeust(String itemId) {  
        orderService.orderItem(itemId);  
        return "ok";  
    }  
  
    @GetMapping("/v2/no-log")  
    public String noLog() {  
        return "";  
    }  
}
```

다음으로 컴포넌트 스캔을 활용한 자동 스프링 빈 등록 예제를 만들어야 한다. 그런데 V2 클래스 이름과 컨트롤러 `GetMapping` 부분만 신경써서 `V3`로 변경하면 끝이므로 코드는 올리지 않겠다.

## 요구사항 추가
지금까지 강의에서 로그 추적기를 만들어서 기존 요구사항을 모두 만족했다.

**기존 요구사항**
- 모든 PUBLIC 메서드의 호출과 응답 정보를 로그로 출력
- 애플리케이션의 흐름을 변경하면 안됨
	- 로그를 남긴다고 해서 비즈니스 로직의 동작에 영향을 주면 안됨
- 메서드 호출에 걸린 시간
- 정상 흐름과 예외 흐름 구분
	- 예외 발생시 예외 정보가 남아야 함
- 메서드 호출의 깊이 표현
- HTTP 요청을 구분
	- HTTP 요청 단위로 특정 ID를 남겨서 어떤 HTTP 요청에서 시작된 것인지 명확하게 구분이 가능해야 함
	- 트랜잭션 ID (DB 트랜잭션X)


하지만 이 요구사항을 만족하기 위해서는 기존 코드를 많이 수정해야 한다. 코드 수정을 최소화 하기 위해서 템플릿 메소드 패턴과 콜백 패턴도 사용했지만, 결과적으로 로그를 남기고 싶은 클래스 모두 고쳐야한다.

로그를 남길 때 기존 원본 코드를 변경해야 한다는 사실 그 자체가 개발자에게는 가장 큰 문제로 남는다. 따라서 기존 요구사항에 다음의 요구사항이 추가되었다.

**요구사항 추가**
- 원본 코드를 전혀 수정하지 않고, 로그 추적기를 적용해라.
- 특정 메서드는 로그를 출력하지 않는 기능
	- 보안상 일부는 로그를 출력하면 안된다.
- 다음과 같은 다양한 케이스에 적용할 수 있어야 한다.
	- v1 - 인터페이스가 있는 구현 클래스에 적용
	- v2 - 인터페이스가 없는 구체 클래스에 적용
	- v3 - 컴포넌트 스캔 대상에 기능 적용

가장 어려운 문제는 **원본 코드를 전혀 수정하지 않고 로그 추적기를 도입해야 하는 것**이다. 이 문제를 해결하려면 **프록시(Proxy)** 개념을 먼저 이해해야 한다.

## 프록시, 프록시 패턴, 데코레이터 패턴
먼저 프록시 개념을 이해하기 위해서는 일반적으로 사용하는 개념인 **클라이언트-서버** 개념을 확실히 짚고 넘어가야 한다. 이 클라이언트-서버는 소프트웨어 개발에만 접목되는 개념이 아니라 다양한 방면에 적용 될 수 있는 개념이다.

클라이언트는 요청 또는 의뢰자이며 서버는 그 요청이나 의뢰를 처리해주는 것을 의미한다. 간단한 실생활 예시로 알아보자.

#### 레스토랑 예시
- 음식 주문을 하는 손님
- 음식 주문을 받는 서버
- 주방에서 요리를 하는 요리사

손님, 서버(홀에서 주문을 받고, 요리사에게 주문 내용을 전달하는 사람), 요리사로 나뉜다.

1. 손님은 서버에게 스테이크를 주문한다.
2. 서버는 해당 요청을 처리하기 위해 주방의 요리사에게 요청을 전달한다. 
3. 요리사는 요청을 전달받고 음식을 내어준다.
4. 
5. 이 때 이 서버는 클라이언트인 손님 입장에서는 요청을 처리해주는 서버(Server)이지만 


---
References: 김영한의 스프링 핵심 원리 - 고급편

Links to this page: 