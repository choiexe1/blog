---
title: 
tags:
  - java
  - programming
  - design-pattern
  - proxy-pattern
  - decorator-pattern
  - spring
publish: true
date: 2025-01-01
---
## 예제 프로젝트 만들기 소개
이전 프로젝트를 기반으로 다양한 상황에서의 프록시 사용법을 이해하기 위해 다음과 같은 기준으로 기본 예제 프로젝트를 만들어본다. 

- **v1**: 인터페이스와 구현 클래스 - 스프링 빈으로 수동 등록
- **v2**: 인터페이스 없는 구체 클래스 - 스프링 빈으로 수동 등록
- **v3**: 컴포넌트 스캔으로 스프링 빈 자동 등록

실무에서는 스프링 빈으로 등록할 클래스는 인터페이스가 있는 경우도 있고, 없는 경우도 있다. 그리고 스프링 빈을 수동으로 직접 등록하는 경우도 있고 컴포넌트 스캔으로 등록하는 경우도 있다. 이런 다양한 케이스에 프록시를 어떻게 적용하는지 알아보기 위함이다.

## 예제 프로젝트 만들기 V1
먼저 인터페이스와 구현체로 나누어진 예제를 만들어본다.

```java title="인터페이스들"
public interface OrderRepositoryV1 {  
    void save(String itemId);  
}

public interface OrderServiceV1 {  
    void orderItem(String itemId);  
}

@RequestMapping // 스프링은 @Controller 또는 @RequestMapping 어노테이션이 있어야 스프링 컨트롤러로 인식  
@ResponseBody  
public interface OrderControllerV1 {  
  
    @GetMapping("/v1/request")  
    String reqeust(@RequestParam("itemId") String itemId);  
  
    @GetMapping("/v1/no-log")  
    String noLog();  
}
```

```java title="구현체들"
public class OrderRepositoryV1Impl implements OrderRepositoryV1 {  
    @Override  
    public void save(String itemId) {  
        if (itemId.equals("ex")) {  
            throw new IllegalStateException("예외 발생!");  
        }  
        sleep(1000);  
    }  
  
    private void sleep(int ms) {  
        try {  
            Thread.sleep(ms);  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
  
    }  
}

public class OrderServiceV1Impl implements OrderServiceV1{  
    private final OrderRepositoryV1 orderRepository;  
  
    public OrderServiceV1Impl(OrderRepositoryV1 orderRepository) {  
        this.orderRepository = orderRepository;  
    }  
  
    @Override  
    public void orderItem(String itemId) {  
        orderRepository.save(itemId);  
    }  
}

public class OrderControllerV1Impl implements OrderControllerV1{  
    private final OrderServiceV1 orderService;  
  
    public OrderControllerV1Impl(OrderServiceV1 orderService) {  
        this.orderService = orderService;  
    }  
  
    @Override  
    public String reqeust(String itemId) {  
        orderService.orderItem(itemId);  
        return "ok";  
    }  
  
    @Override  
    public String noLog() {  
        return "";  
    }  
}
```

이 구조의 예제에서 독특한 점은 컨트롤러가 인터페이스와 구현체로 나누어진다는 점이다. 다시 한번 컨트롤러 인터페이스를 살펴보면 다음과 같다.

```java
@RequestMapping  
@ResponseBody  
public interface OrderControllerV1 {  
  
    @GetMapping("/v1/request")  
    String reqeust(@RequestParam("itemId") String itemId);  
  
    @GetMapping("/v1/no-log")  
    String noLog();  
}
```

- `@RequestMapping`: 스프링 MVC는 `@Controller` 또는 `@RequestMapping` 어노테이션이 타입에 있어야 스프링 컨트롤러로 인식한다. 그리고 스프링 컨트롤러로 인식해야 `HTTP URL`이 매핑되고 동작한다. 이 어노테이션은 인터페이스에 사용해도 된다.
- `@ResponseBody`: HTTP 메시지 컨버터를 사용해서 응답한다. 이 어노테이션은 인터페이스에 사용해도 된다.
- 인터페이스에는 `@RequestParam`의 값을 생략하면 `itemId`를 컴파일 이후 자바 버전에 따라 인식하지 못할 수 있다. 인터페이스에서는 꼭 넣어줘야 한다. 클래스에서는 생략해도 대부분 잘 지원된다.

> [!warning] 스프링 부트 3.0 변경 사항
> 스프링 부트 3.0(스프링 프레임워크 6.0)부터는 클래스 레벨에 `@RequestMapping`이 있어도 스프링 컨트롤러로 인식하지 않는다. 오직 `@Controller`가 있어야 스프링 컨트롤러로 인식한다. 참고로 `@RestController`는 내부에 `@Controller` 어노테이션을 포함하므로 인식 된다.
> 
> 따라서 다음처럼 컨트롤러 인터페이스에 적용된 어노테이션을 변경해야 한다.
> `@RequestMapping` -> `@RestController`


## 예제 프로젝트 만들기 V2
이번에는 인터페이스가 없는 `Controller`, `Service`, `Repository`를 스프링 빈으로 수동 등록해본다.

```java
public class OrderRepositoryV2 {  
    public void save(String itemId) {  
        if (itemId.equals("ex")) {  
            throw new IllegalStateException("예외 발생!");  
        }  
        sleep(1000);  
    }  
  
    private void sleep(int ms) {  
        try {  
            Thread.sleep(ms);  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
    }  
}

public class OrderServiceV2 {  
    private final OrderRepositoryV2 orderRepository;  
  
    public OrderServiceV2(OrderRepositoryV2 orderRepository) {  
        this.orderRepository = orderRepository;  
    }  
  
    public void orderItem(String itemId) {  
        orderRepository.save(itemId);  
    }  
}

@Slf4j  
@RestController  
public class OrderControllerV2 {  
    private final OrderServiceV2 orderService;  
  
    public OrderControllerV2(OrderServiceV2 orderService) {  
        this.orderService = orderService;  
    }  
  
    @GetMapping("/v2/request")  
    public String reqeust(String itemId) {  
        orderService.orderItem(itemId);  
        return "ok";  
    }  
  
    @GetMapping("/v2/no-log")  
    public String noLog() {  
        return "";  
    }  
}
```

다음으로 컴포넌트 스캔을 활용한 자동 스프링 빈 등록 예제를 만들어야 한다. 그런데 V2 클래스 이름과 컨트롤러 `GetMapping` 부분만 신경써서 `V3`로 변경하면 끝이므로 코드는 올리지 않겠다.

## 요구사항 추가
지금까지 강의에서 로그 추적기를 만들어서 기존 요구사항을 모두 만족했다.

**기존 요구사항**
- 모든 PUBLIC 메서드의 호출과 응답 정보를 로그로 출력
- 애플리케이션의 흐름을 변경하면 안됨
	- 로그를 남긴다고 해서 비즈니스 로직의 동작에 영향을 주면 안됨
- 메서드 호출에 걸린 시간
- 정상 흐름과 예외 흐름 구분
	- 예외 발생시 예외 정보가 남아야 함
- 메서드 호출의 깊이 표현
- HTTP 요청을 구분
	- HTTP 요청 단위로 특정 ID를 남겨서 어떤 HTTP 요청에서 시작된 것인지 명확하게 구분이 가능해야 함
	- 트랜잭션 ID (DB 트랜잭션X)


하지만 이 요구사항을 만족하기 위해서는 기존 코드를 많이 수정해야 한다. 코드 수정을 최소화 하기 위해서 템플릿 메소드 패턴과 콜백 패턴도 사용했지만, 결과적으로 로그를 남기고 싶은 클래스 모두 고쳐야한다.

로그를 남길 때 기존 원본 코드를 변경해야 한다는 사실 그 자체가 개발자에게는 가장 큰 문제로 남는다. 따라서 기존 요구사항에 다음의 요구사항이 추가되었다.

**요구사항 추가**
- 원본 코드를 전혀 수정하지 않고, 로그 추적기를 적용해라.
- 특정 메서드는 로그를 출력하지 않는 기능
	- 보안상 일부는 로그를 출력하면 안된다.
- 다음과 같은 다양한 케이스에 적용할 수 있어야 한다.
	- v1 - 인터페이스가 있는 구현 클래스에 적용
	- v2 - 인터페이스가 없는 구체 클래스에 적용
	- v3 - 컴포넌트 스캔 대상에 기능 적용

가장 어려운 문제는 **원본 코드를 전혀 수정하지 않고 로그 추적기를 도입해야 하는 것**이다. 이 문제를 해결하려면 **프록시(Proxy)** 개념을 먼저 이해해야 한다.

## 프록시, 프록시 패턴, 데코레이터 패턴 개념
먼저 프록시 개념을 이해하기 위해서는 클라이언트-서버 개념을 확실히 알고 있어야 한다. 이 클라이언트-서버 개념은 소프트웨어 개발에만 접목되는 개념이 아니라 다양한 방면에 적용 될 수 있는 개념이다. 

클라이언트는 요청 또는 의뢰자이며 서버는 그 요청이나 의뢰를 처리해주는 것을 의미한다. 간단한 실생활 예시 클라이언트-서버 개념과 프록시를 알아보자. 

참고로 프록시(Proxy)는 대리자라는 의미이고, 클라이언트-서버의 사이에서 요청을 다룬다. 따라서 프록시가 들어가게 되면 클라이언트-프록시-서버 순으로 요청이 전달되는 것이다.
#### 실생활 예시
- 음식 주문을 하는 손님
- 음식 주문을 받는 서버 - 프록시
- 주방에서 요리를 하는 요리사

손님, 서버(홀에서 주문을 받고, 요리사에게 주문 내용을 전달하는 사람), 요리사로 나뉜다.

1. 손님은 서버에게 스테이크를 주문한다.
2. 서버는 해당 요청을 처리하기 위해 주방의 요리사에게 요청을 전달한다. 
3. 요리사는 요청을 전달받고 음식을 내어준다.
4. 서버는 음식을 클라이언트인 손님에게 반환한다.


**음식을 주문할 때**
- `클라이언트`: 손님
- `서버`: 음식 주문을 받은 서버


**주문을 주방에 전달할 때**
- `클라이언트`: 음식 주문을 받은 서버
- `서버`: 주방에서 요리하는 요리사

**전체적으로 본다면**
- `클라이언트`: 손님
- `프록시`: 음식 주문을 받은 서버
- `서버`: 주방에서 요리하는 요리사

일반적으로 레스토랑에선 손님이 주방에 곧바로 접근하여 주문하는 것을 서버를 통해 접근을 제어한다. 이 접근을 제어하는 서버가 프록시(대리자)인 것이다. 실제로 손님의 요청을 처리하는 곳은 주방이다. 사실 이 예시가 적절하지는 않지만 이렇게 이해해도 된다.

위 예시에서 알아봤듯이 클라이언트-서버 관계를 두고, 직접 클라이언트가 서버를 호출하는 것을 **직접 호출**이라고 하고 중간에 대리자를 두고 간접적으로 서버를 호출하는 것을 **간접 호출**이라 한다.

#### 간접 호출의 장점
직접 호출보다 간접 호출을 할 때 더 많은 장점이 있는데 대리자는 중간에서 다음과 같은 행위들을 수행 할 수 있기 때문이다. 물론 다음과 같은 행위만 수행하라는 룰은 없다. 대표적인 것이다.
- 접근 제어
	- 권한 체크
	- 캐싱
- 부가 기능 추가
	- 추가적인 로직 수행
- 프록시 체인
	- 대리자가 또 다른 대리자를 통해 요청 처리 등

참고로 프록시 체인은 스프링 시큐리티의 핵심 개념이다. `클라이언트-대리자1-대리자2-서버`처럼 여러 프록시가 중간에 있는 것이다.

#### 대체 가능
![[proxy-1.png]]

그런데 객체 세상에서 프록시 객체가 되려면 클라이언트는 서버에게 요청한 것인지 프록시에게 요청 한 것인지 조차 몰라야한다. 쉽게 이야기해서 서버와 프록시는 같은 인터페이스를 사용해야 하는 것이다. 

그리고 클라이언트가 사용하는 서버 객체를 프록시 객체로 변경해도 클라이언트 코드를 전혀 변경하지 않고 동작할 수 있어야 한다.

#### GOF 디자인 패턴
GOF 디자인 패턴에서는 이 프록시 개념을 적용한 디자인 패턴을 의도에 따라 다음과 같이 크게 두 가지로 구분한다.

- **프록시 패턴**: 접근 제어가 목적일 때 프록시 패턴이라 한다.
- **데코레이터 패턴**: 부가 기능 추가가 목적일 때 데코레이터 패턴이라 한다.

## 프록시 패턴 - 예제 코드 1
프록시 패턴을 이해하기 위해 예제 코드를 작성해본다. 먼저 프록시 패턴을 도입하기 전 다음의 클래스 의존 관계를 가지는 코드를 구현한다.

![[proxy-2.png]]


```java title="Subject"
public interface Subject {  
    String operation();  
}
```

```java title="RealSubject"
@Slf4j  
public class RealSubject implements Subject {  
    @Override  
    public String operation() {  
        log.info("실제 객체 호출");  
        sleep(1000);  
        return "data";  
    }  
  
    private void sleep(int ms) {  
        try {  
            Thread.sleep(ms);  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
    }  
}
```

```java title="ProxyPatternClient"
public class ProxyPatternClient {  
    private Subject subject;  
  
    public ProxyPatternClient(Subject subject) {  
        this.subject = subject;  
    }  
  
    public void execute() {  
        subject.operation();  
    }  
}
```

이제 테스트를 간단히 작성한다.

```java title="ProxyPatternTest"
public class ProxyPatternTest {  
    @Test  
    void noProxy() {  
        RealSubject realSubject = new RealSubject();  
        ProxyPatternClient client = new ProxyPatternClient(realSubject);  
  
        client.execute();  
        client.execute();  
        client.execute();  
    }  
}
```

테스트 코드를 실행해보면 `RealSubject`의 `operation`을 호출하기 때문에 `execute()` 호출 당 1초씩 소요되서 다음과 같이 총 3초가 소요된다. 
```
10:40:28.350 [main] INFO hello.proxy.pureproxy.proxy.code.RealSubject - 실제 객체 호출
10:40:29.355 [main] INFO hello.proxy.pureproxy.proxy.code.RealSubject - 실제 객체 호출
10:40:30.360 [main] INFO hello.proxy.pureproxy.proxy.code.RealSubject - 실제 객체 호출
```

그런데 이 데이터가 한번 조회했을 때 변하지 않는 데이터라면 어딘가 보관해두고 이미 조회한 데이터를 사용하는 것이 성능상 더 좋다.

이런 것을 캐시라고 한다. 프록시 패턴의 주요 기능은 접근 제어이다. 캐시도 접근 자체를 제어하는 기능 중 하나이다.

이미 개발된 로직을 전혀 수정하지 않고 프록시 객체를 통해서 캐시를 적용해보자.

## 프록시 패턴 - 예제 코드 2
![[proxy-3.png]]

프록시 패턴을 적용하기 위해서 `Subject`를 구현하는 `Proxy`를 만들고, 해당 `Proxy`가 런타임에 다음의 그림과 같이 어떤 로직을 수행하면 된다.

![[proxy-4.png]]

```java title="CacheProxy"
@Slf4j  
public class CacheProxy implements Subject {  
    private final Subject target;  
    private String cacheValue;  
  
    public CacheProxy(Subject target) {  
        this.target = target;  
    }  
  
    @Override  
    public String operation() {  
        log.info("프록시 호출");  
  
        if (cacheValue == null) {  
            cacheValue = target.operation();  
        }  
  
        return cacheValue;  
    }  
}
```

- 앞서 설명한 것 처럼 프록시는 실제 객체를 대체할 수 있어야 한다. 따라서 `Subject` 인터페이스를 구현해야 한다.
- 클라이언트가 프록시를 호출하면 프록시가 최종적으로 실제 객체를 호출해야 한다. 쉽게 말해서 프록시 객체는 타겟 객체를 알고 있어야 한다. 따라서 내부에 실제 객체의 참조를 갖도록 `private Subject target` 필드를 정의하고 생성자 호출 시점에 주입한다.
- 구현한 코드를 보면 `cacheValue`에 값이 없을 때 실제 객체를 호출해서 값을 구한다. 그리고 그 구한 값을 `cacheValue`에 보관하고 반환한다. 만약 `cacheValue`에 값이 있으면 실제 객체를 전혀 호출하지 않고 캐시 값을 그대로 반환한다. 따라서 최초 조회 이후에는 캐시(cacheValue)에서 매우 빠르게 데이터를 조회할 수 있다.

```java
@Test  
void cacheProxyTest() {  
    Subject realSubject = new RealSubject();  
    Subject cacheProxy = new CacheProxy(realSubject);  
    ProxyPatternClient client = new ProxyPatternClient(cacheProxy);  
      
    client.execute();  
    client.execute();  
    client.execute();  
}
```

`realSubject`와 `cacheProxy`를 생성하고 둘을 연결한다. 결과적으로 `cacheProxy`가 `realSubject`를 참조하는 런타임 객체 의존관계가 완성된다. 마지막으로 `client`에 `realSubject`가 아닌 `cacheProxy`를 주입한다. 이 과정을 통해서 `client -> cacheProxy -> realSubject` 런타임 객체 의존 관계가 완성된다.

테스트 코드를 실행해보면 다음과 같은 결과가 출력된다. 

```
10:58:01.573 [main] INFO hello.proxy.pureproxy.proxy.code.CacheProxy - 프록시 호출
10:58:01.574 [main] INFO hello.proxy.pureproxy.proxy.code.RealSubject - 실제 객체 호출
10:58:02.579 [main] INFO hello.proxy.pureproxy.proxy.code.CacheProxy - 프록시 호출
10:58:02.580 [main] INFO hello.proxy.pureproxy.proxy.code.CacheProxy - 프록시 호출
```

로그를 살펴보면 의도대로 잘 동작한 것을 확인할 수 있다. 흐름은 다음과 같다.

- `execute()`가 호출되면 주입된 `cacheProxy.operation()`이 실행된다.
- `cacheProxy.operation()`은 캐시된 값인 `cacheValue`가 없으면 필드 참조하고 있는 `target` 객체인 `realSubject`의 `operation()`을 호출해 값을 반환 받는다.
- 반환된 값을 `cacheValue`에 보관하고 그 값을 반환한다.
- 이 후의 요청에서는 `cacheValue`에 값이 존재하므로 실제 객체인 `realSubject`를 호출하지 않고 해당 값을 반환한다.

> [!summary] 프록시 패턴의 핵심
> 프록시 패턴의 핵심은 `RealSubject` 코드와 클라이언트 코드를 전혀 변경하지 않고, 프록시를 도입해서 접근 제어를 했다는 점이다. 그리고 클라이언트 코드의 변경 없이 자유롭게 프록시를 넣고 뺄 수 있다. 실제 클라이언트의 입장에서는 프록시 객체가 주입 되었는지, 실제 객체가 주입 되었는지 알지 못한다.

---
References: 김영한의 스프링 핵심 원리 - 고급편

Links to this page: 