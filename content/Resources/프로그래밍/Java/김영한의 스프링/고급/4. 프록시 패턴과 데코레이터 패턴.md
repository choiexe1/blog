---
title: 
tags:
  - java
  - programming
  - design-pattern
  - proxy-pattern
  - decorator-pattern
  - spring
publish: true
date: 2025-01-01
---
## 예제 프로젝트 만들기 소개
이전 프로젝트를 기반으로 다양한 상황에서의 프록시 사용법을 이해하기 위해 다음과 같은 기준으로 기본 예제 프로젝트를 만들어본다. 

- **v1**: 인터페이스와 구현 클래스 - 스프링 빈으로 수동 등록
- **v2**: 인터페이스 없는 구체 클래스 - 스프링 빈으로 수동 등록
- **v3**: 컴포넌트 스캔으로 스프링 빈 자동 등록

실무에서는 스프링 빈으로 등록할 클래스는 인터페이스가 있는 경우도 있고, 없는 경우도 있다. 그리고 스프링 빈을 수동으로 직접 등록하는 경우도 있고 컴포넌트 스캔으로 등록하는 경우도 있다. 이런 다양한 케이스에 프록시를 어떻게 적용하는지 알아보기 위함이다.

## 예제 프로젝트 만들기 v1
먼저 인터페이스와 구현체로 나누어진 예제를 만들어본다.

```java title="인터페이스들"
public interface OrderRepositoryV1 {  
    void save(String itemId);  
}

public interface OrderServiceV1 {  
    void orderItem(String itemId);  
}

@RequestMapping // 스프링은 @Controller 또는 @RequestMapping 어노테이션이 있어야 스프링 컨트롤러로 인식  
@ResponseBody  
public interface OrderControllerV1 {  
  
    @GetMapping("/v1/request")  
    String reqeust(@RequestParam("itemId") String itemId);  
  
    @GetMapping("/v1/no-log")  
    String noLog();  
}
```

```java title="구현체들"
public class OrderRepositoryV1Impl implements OrderRepositoryV1 {  
    @Override  
    public void save(String itemId) {  
        if (itemId.equals("ex")) {  
            throw new IllegalStateException("예외 발생!");  
        }  
        sleep(1000);  
    }  
  
    private void sleep(int ms) {  
        try {  
            Thread.sleep(ms);  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
  
    }  
}

public class OrderServiceV1Impl implements OrderServiceV1{  
    private final OrderRepositoryV1 orderRepository;  
  
    public OrderServiceV1Impl(OrderRepositoryV1 orderRepository) {  
        this.orderRepository = orderRepository;  
    }  
  
    @Override  
    public void orderItem(String itemId) {  
        orderRepository.save(itemId);  
    }  
}

public class OrderControllerV1Impl implements OrderControllerV1{  
    private final OrderServiceV1 orderService;  
  
    public OrderControllerV1Impl(OrderServiceV1 orderService) {  
        this.orderService = orderService;  
    }  
  
    @Override  
    public String reqeust(String itemId) {  
        orderService.orderItem(itemId);  
        return "ok";  
    }  
  
    @Override  
    public String noLog() {  
        return "";  
    }  
}
```

이 구조의 예제에서 독특한 점은 컨트롤러가 인터페이스와 구현체로 나누어진다는 점이다. 다시 한번 컨트롤러 인터페이스를 살펴보면 다음과 같다.

```java
@RequestMapping  
@ResponseBody  
public interface OrderControllerV1 {  
  
    @GetMapping("/v1/request")  
    String reqeust(@RequestParam("itemId") String itemId);  
  
    @GetMapping("/v1/no-log")  
    String noLog();  
}
```

- `@RequestMapping`: 스프링 MVC는 `@Controller` 또는 `@RequestMapping` 어노테이션이 타입에 있어야 스프링 컨트롤러로 인식한다. 그리고 스프링 컨트롤러로 인식해야 `HTTP URL`이 매핑되고 동작한다. 이 어노테이션은 인터페이스에 사용해도 된다.
- `@ResponseBody`: HTTP 메시지 컨버터를 사용해서 응답한다. 이 어노테이션은 인터페이스에 사용해도 된다.
- `@RequestParam`
---
References: 김영한의 스프링 핵심 원리 - 고급편

Links to this page: 