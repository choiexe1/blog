---
title: 
tags:
  - java
  - programming
  - proxy
  - dynamic-proxy
publish: true
date: 2025-01-03
---
## 프록시 팩토리 - 소개

**문제점**
- 인터페이스가 있는 경우에는 JDK 동적 프록시를 사용하고, 그렇지 않은 경우에는 CGLIB를 적용하려면 어떻게 해야할까?
- 두 기술을 함께 사용할 때 부가 기능을 제공하기 위해서는 JDK 동적 프록시가 제공하는 `InvocationHandler`와 CGLIB가 제공하는 `MethodInterceptor`를 각각 중복으로 만들어서 관리해야 할까?
- 특정 조건에 맞을 때 프록시 로직을 적용하는 기능도 공통으로 제공되었으면?

#### 인터페이스가 있는 경우에는 JDK 동적 프록시를 사용하고, 그렇지 않은 경우에는 CGLIB를 적용하려면 어떻게 해야할까?

스프링은 유사한 구체적인 기술들이 있을 때, 그것들을 통합해서 일관성있게 접근하고 더욱 편리하게 사용할 수 있는 추상화 된 기술을 제공한다. 스프링은 동적 프록시를 통합해서 편리하게 만들어주는 프록시 팩토리(`ProxyFactory`)라는 기능을 제공한다.

이전에는 상황에 따라서 JDK 동적 프록시를 사용하거나 CGLIB을 사용해야 했다면, 이제는 이 프록시 팩토리 하나로 편리하게 동적 프록시를 생성할 수 있다. 프록시 팩토리는 인터페이스가 있으면 JDK 동적 프록시를 사용하고, 구체 클래스만 있다면 CGLIB를 사용한다.

그리고 이 설정을 변경할 수 있다.


![[proxy-factory-1.png]]

#### 두 기술을 함께 사용할 때 JDK 동적 프록시가 제공하는 InvocationHandler와 CGLIB가 제공하는 MethodInterceptor를 각각 중복으로 따로만들어야 할까?

스프링은 이 문제를 해결하기 위해 부가 기능을 적용할 때 `Advice`라는 새로운 개념을 도입했다. 개발자는 `InvocationHandler` 나 `MethodInterceptor`를 신경쓰지 않고, `Advice`만 만들면 된다. 결과적으로 `InvocationHandler`나 `MethodInterceptor`는 `Advice`를 호출한다.

프록시 팩토리를 사용하면 `Advice`를 호출하는 전용 `InvocationHandler`, `MethodInterceptor`를 내부에서 사용한다.

![[proxy-factory-2.png]]

조금 복잡할 수도 있는데, 핵심은 결국 프록시 생성은 `ProxyFactory`로 하고 로직은 `Advice`로 구현하면 된다.

#### 특정 조건에 맞을 때 프록시 로직을 적용하는 기능도 공통으로 제공되었으면?
앞서 특정 메서드 이름의 조건에 맞을 때만 프록시 부가 기능이 적용되는 코드를 직접 만들었다. 스프링은 `Pointcut`이라는 개념을 도입해서 이 문제를 일관성 있게 해결한다.

## 프록시 팩토리 - 예제 코드 1

#### Advice 만들기
`Advice`는 프록시에 적용하는 부가 기능 로직이다. 이것은 JDK 동적 프록시가 제공하는 `InvocationHandler`나 CGLIB이 제공하는 `MethodInterceptor`의 개념과 유사하다. 둘을 개념적으로 추상화 한 것이다.

프록시 팩토리를 사용하면 둘 대신에 `Advice`를 사용하면 된다. `Advice`를 만드는 방법은 여러가지가 있지만 기본적인 방법은 다음의 인터페이스를 구현하는 것이다. CGLIB이 제공하는 `MethodInterceptor`와 이름이 동일한데, 패키지가 다른 점을 유의해서 살펴보자.

```java title="org.aopalliance.intercept.MethodInterceptor"
package org.aopalliance.intercept;

@FunctionalInterface  
public interface MethodInterceptor extends Interceptor {  
    @Nullable  
    Object invoke(@Nonnull MethodInvocation invocation) throws Throwable;  
}
```

- `invoke()` 함수의 파라미터인 `MethodInvocation invacation`의 내부에는 다음 메서드를 호출하는 방법, 현재 프록시 객체 인스턴스, `args`, 메서드 정보들이 포함되어 있다. 기존에 파라미터로 제공되는 부분들이 합쳐졌다고 생각하면 된다.
- `MethodInterceptor`는 `Interceptor`를 상속하고 `Interceptor`는 `Advice` 인터페이스를 상속한다. 그래서 `Advice`라고 하는 것이다.

```java
@Slf4j  
public class TimeAdvice implements MethodInterceptor {  
    @Override  
    public Object invoke(MethodInvocation invocation) throws Throwable {  
        log.info("TimeAdvice 실행");  
        long startTime = System.currentTimeMillis();  
  
        Object result = invocation.proceed();  
  
        long endTime = System.currentTimeMillis();  
        long resultTime = endTime - startTime;  
  
        log.info("TimeAdvice 종료. resultTime = {}", resultTime);  
        return result;  
    }  
}
```

- `TimeAdvice`는 앞서 살펴본 `MethodInteceptor` 인터페이스를 구현한다.
- `Object result = invocation.proceed()`
	- `invocation.proceed()`를 호출하면 `target` 클래스를 호출하고 그 결과를 받는다.
	- 그런데 기존에 보았던 프록시들과 다르게 `target` 클래스의 정보가 보이지 않는다. `target` 클래스 정보는 `MethodInvocation invocation`안에 모두 포함에 되어 잇다.
	- 그 이유는 프록시 팩토리로 프록시를 생성하는 단계에서 이미 `target` 정보를 파라미터로 전달받기 때문이다.

#### 프록시 팩토리 사용
```java
@Test  
@DisplayName("인터페이스가 있으면 JDK 동적 프록시 사용")  
void interfaceProxy() {  
    ServiceInterface target = new ServiceImpl();  
    ProxyFactory proxyFactory = new ProxyFactory(target);  
    proxyFactory.addAdvice(new TimeAdvice());  
    ServiceInterface proxy = (ServiceInterface) proxyFactory.getProxy();  
  
    log.info("targetClass = {}", target.getClass());  
    log.info("proxyClass = {}", proxy.getClass());  
}
```

---
References: 김영한의 스프링 핵심 원리 - 고급편

Links to this page: 