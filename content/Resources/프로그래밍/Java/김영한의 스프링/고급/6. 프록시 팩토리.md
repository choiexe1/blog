---
title: 
tags:
  - java
  - programming
  - proxy
  - dynamic-proxy
  - proxy-factory
  - advice
  - pointcut
  - advisor
  - proxy-pattern
  - design-pattern
  - decorator-pattern
publish: true
date: 2025-01-03
---
## 프록시 팩토리 - 소개

**문제점**
- 인터페이스가 있는 경우에는 JDK 동적 프록시를 사용하고, 그렇지 않은 경우에는 CGLIB를 적용하려면 어떻게 해야할까?
- 두 기술을 함께 사용할 때 부가 기능을 제공하기 위해서는 JDK 동적 프록시가 제공하는 `InvocationHandler`와 CGLIB가 제공하는 `MethodInterceptor`를 각각 중복으로 만들어서 관리해야 할까?
- 특정 조건에 맞을 때 프록시 로직을 적용하는 기능도 공통으로 제공되었으면?

#### 인터페이스가 있는 경우에는 JDK 동적 프록시를 사용하고, 그렇지 않은 경우에는 CGLIB를 적용하려면 어떻게 해야할까?

스프링은 유사한 구체적인 기술들이 있을 때, 그것들을 통합해서 일관성있게 접근하고 더욱 편리하게 사용할 수 있는 추상화 된 기술을 제공한다. 스프링은 동적 프록시를 통합해서 편리하게 만들어주는 프록시 팩토리(`ProxyFactory`)라는 기능을 제공한다.

이전에는 상황에 따라서 JDK 동적 프록시를 사용하거나 CGLIB을 사용해야 했다면, 이제는 이 프록시 팩토리 하나로 편리하게 동적 프록시를 생성할 수 있다. 프록시 팩토리는 인터페이스가 있으면 JDK 동적 프록시를 사용하고, 구체 클래스만 있다면 CGLIB를 사용한다.

그리고 이 설정을 변경할 수 있다.


![[proxy-factory-1.png]]

#### 두 기술을 함께 사용할 때 JDK 동적 프록시가 제공하는 InvocationHandler와 CGLIB가 제공하는 MethodInterceptor를 각각 중복으로 따로만들어야 할까?

스프링은 이 문제를 해결하기 위해 부가 기능을 적용할 때 `Advice`라는 새로운 개념을 도입했다. 개발자는 `InvocationHandler` 나 `MethodInterceptor`를 신경쓰지 않고, `Advice`만 만들면 된다. 결과적으로 `InvocationHandler`나 `MethodInterceptor`는 `Advice`를 호출한다.

프록시 팩토리를 사용하면 `Advice`를 호출하는 전용 `InvocationHandler`, `MethodInterceptor`를 내부에서 사용한다.

![[proxy-factory-2.png]]

조금 복잡할 수도 있는데, 핵심은 결국 프록시 생성은 `ProxyFactory`로 하고 로직은 `Advice`로 구현하면 된다.

#### 특정 조건에 맞을 때 프록시 로직을 적용하는 기능도 공통으로 제공되었으면?
앞서 특정 메서드 이름의 조건에 맞을 때만 프록시 부가 기능이 적용되는 코드를 직접 만들었다. 스프링은 `Pointcut`이라는 개념을 도입해서 이 문제를 일관성 있게 해결한다.

## 프록시 팩토리 - 예제 코드 1

#### Advice 만들기
`Advice`는 프록시에 적용하는 부가 기능 로직이다. 이것은 JDK 동적 프록시가 제공하는 `InvocationHandler`나 CGLIB이 제공하는 `MethodInterceptor`의 개념과 유사하다. 둘을 개념적으로 추상화 한 것이다.

프록시 팩토리를 사용하면 둘 대신에 `Advice`를 사용하면 된다. `Advice`를 만드는 방법은 여러가지가 있지만 기본적인 방법은 다음의 인터페이스를 구현하는 것이다. CGLIB이 제공하는 `MethodInterceptor`와 이름이 동일한데, 패키지가 다른 점을 유의해서 살펴보자.

```java title="org.aopalliance.intercept.MethodInterceptor"
package org.aopalliance.intercept;

@FunctionalInterface  
public interface MethodInterceptor extends Interceptor {  
    @Nullable  
    Object invoke(@Nonnull MethodInvocation invocation) throws Throwable;  
}
```

- `invoke()` 함수의 파라미터인 `MethodInvocation invacation`의 내부에는 다음 메서드를 호출하는 방법, 현재 프록시 객체 인스턴스, `args`, 메서드 정보들이 포함되어 있다. 기존에 파라미터로 제공되는 부분들이 합쳐졌다고 생각하면 된다.
- `MethodInterceptor`는 `Interceptor`를 상속하고 `Interceptor`는 `Advice` 인터페이스를 상속한다. 그래서 `Advice`라고 하는 것이다.

```java
@Slf4j  
public class TimeAdvice implements MethodInterceptor {  
    @Override  
    public Object invoke(MethodInvocation invocation) throws Throwable {  
        log.info("TimeAdvice 실행");  
        long startTime = System.currentTimeMillis();  
  
        Object result = invocation.proceed();  
  
        long endTime = System.currentTimeMillis();  
        long resultTime = endTime - startTime;  
  
        log.info("TimeAdvice 종료. resultTime = {}", resultTime);  
        return result;  
    }  
}
```

- `TimeAdvice`는 앞서 살펴본 `MethodInteceptor` 인터페이스를 구현한다.
- `Object result = invocation.proceed()`
	- `invocation.proceed()`를 호출하면 `target` 클래스를 호출하고 그 결과를 받는다.
	- 그런데 기존에 보았던 프록시들과 다르게 `target` 클래스의 정보가 보이지 않는다. `target` 클래스 정보는 `MethodInvocation invocation`안에 모두 포함에 되어 잇다.
	- 그 이유는 프록시 팩토리로 프록시를 생성하는 단계에서 이미 `target` 정보를 파라미터로 전달받기 때문이다.

#### 프록시 팩토리 사용 - JDK 동적 프록시
```java
@Test  
@DisplayName("인터페이스가 있으면 JDK 동적 프록시 사용")  
void interfaceProxy() {  
    ServiceInterface target = new ServiceImpl();  
    ProxyFactory proxyFactory = new ProxyFactory(target);  
    proxyFactory.addAdvice(new TimeAdvice());  
    ServiceInterface proxy = (ServiceInterface) proxyFactory.getProxy();  
  
    log.info("targetClass = {}", target.getClass());  
    log.info("proxyClass = {}", proxy.getClass());

	proxy.save();
	
	Assertions.assertThat(AopUtils.isAopProxy(proxy)).isTrue();  
	Assertions.assertThat(AopUtils.isJdkDynamicProxy(proxy)).isTrue();  
	Assertions.assertThat(AopUtils.isCglibProxy(proxy)).isFalse();
}
```

- `new ProxyFactory(target)`: 프록시 팩토리를 생성할 때, 생성자에 프록시의 호출 대상을 함께 넘긴다. 프록시 팩토리는 이 인스턴스 정보를 기반으로 프록시를 만들어낸다. 만약 이 인스턴스가 인터페이스의 구현체라면 (인스턴스에 인터페이스가 있다면) JDK 동적 프록시를 기본으로 사용하고, 인터페이스가 없고 구체 클래스만 있다면 CGLIB을 통해서 동적 프록시를 생성한다. 여기서는 `target`이 `new ServiceImpl()`의 인스턴스이기 때문에 `ServiceInterface` 인터페이스가 있다. 따라서 이 인터페이스를 기반으로 JDK 동적 프록시를 생성한다.
- `proxyFactory.addAdvice(new TimeAdvice())`: 프록시 팩토리를 통해서 만든 프록시가 사용할 부가 기능 로직을 설정한다. JDK 동적 프록시가 제공하는 `InvocationHandler`와 CGLIB이 제공하는 `MethodInterceptor`의 개념과 유사하다. 이렇게 프록시가 제공하는 부가 기능 로직을 `Advice`라고 한다.
- `proxyFactory.getProxy()`: 프록시 객체를 생성하고 그 결과를 받는다.

다음의 실행 결과를 살펴보면 JDK 동적 프록시가 생성된 것을 확인할 수 있다.

```
03:47:56.552 [main] INFO hello.proxy.proxyfactory.ProxyFactoryTest - targetClass = class hello.proxy.common.ServiceImpl
03:47:56.553 [main] INFO hello.proxy.proxyfactory.ProxyFactoryTest - proxyClass = class jdk.proxy2.$Proxy9
03:47:56.557 [main] INFO hello.proxy.common.advice.TimeAdvice - TimeAdvice 실행
03:47:56.557 [main] INFO hello.proxy.common.ServiceImpl - save 호출
03:47:56.557 [main] INFO hello.proxy.common.advice.TimeAdvice - TimeAdvice 종료. resultTime = 0
```

#### 프록시 팩토리를 통한 프록시 적용 확인
참고로 다음의 기능들은 모두 프록시 팩토리를 사용했을 때만 확인 가능하다. 프록시가 잘 적용되었는지 확인하려면 다음 기능을 사용하면 된다.
- `AopUtils.isAopProxy(proxy)`: 프록시 팩토리를 통해서 프록시가 생성되면 JDK 동적 프록시나, CGLIB 모두 참이다.
- `AopUtils.isJdkDynamicProxy(proxy)`: 프록시 팩토리를 통해서 프록시가 생성되고, JDK 동적 프록시일 경우 참
- `AopUtils.isCglibProxy(proxy)`: 프록시 팩토리를 통해서 프록시가 생성되고, CGLIB 동적 프록시일 경우 참

#### 프록시 팩토리 사용 - CGLIB 동적 프록시 사용
```java
@Test  
@DisplayName("인터페이스가 있으면 CGLIB 동적 프록시 사용")  
void concreteProxy() {  
    ConcreteService target = new ConcreteService();  
    ProxyFactory proxyFactory = new ProxyFactory(target);  
    proxyFactory.addAdvice(new TimeAdvice());  
    ConcreteService proxy = (ConcreteService) proxyFactory.getProxy();  
  
    log.info("targetClass = {}", target.getClass());  
    log.info("proxyClass = {}", proxy.getClass());  
  
    proxy.call();  
  
    Assertions.assertThat(AopUtils.isAopProxy(proxy)).isTrue();  
    Assertions.assertThat(AopUtils.isJdkDynamicProxy(proxy)).isFalse();  
    Assertions.assertThat(AopUtils.isCglibProxy(proxy)).isTrue();  
}
```

실행 결과의 클래스 정보를 살펴보면 CGLIB 프록시가 적용된 것을 눈으로도 확인할 수 있다.

```
04:14:30.589 [main] INFO hello.proxy.proxyfactory.ProxyFactoryTest - targetClass = class hello.proxy.common.ConcreteService
04:14:30.590 [main] INFO hello.proxy.proxyfactory.ProxyFactoryTest - proxyClass = class hello.proxy.common.ConcreteService$$EnhancerBySpringCGLIB$$81910790
04:14:30.591 [main] INFO hello.proxy.common.advice.TimeAdvice - TimeAdvice 실행
04:14:30.596 [main] INFO hello.proxy.common.ConcreteService - ConcreteService 호출
04:14:30.597 [main] INFO hello.proxy.common.advice.TimeAdvice - TimeAdvice 종료. resultTime = 6
```

#### 프록시 팩토리 사용 - proxyTargetClass 추가

```java
@Test  
@DisplayName("ProxyTargetClass 옵션을 사용하면 인터페이스가 있어도 CGLIB를 사용하고, 클래스 기반 동적 프록시를 사용")  
void proxyTargetClass() {  
    ServiceInterface target = new ServiceImpl();  
    ProxyFactory proxyFactory = new ProxyFactory(target);  
  
    proxyFactory.setProxyTargetClass(true);  
  
    proxyFactory.addAdvice(new TimeAdvice());  
    ServiceInterface proxy = (ServiceInterface) proxyFactory.getProxy();  
  
    log.info("targetClass = {}", target.getClass());  
    log.info("proxyClass = {}", proxy.getClass());  
  
    proxy.save();  
  
    Assertions.assertThat(AopUtils.isAopProxy(proxy)).isTrue();  
    Assertions.assertThat(AopUtils.isJdkDynamicProxy(proxy)).isFalse();  
    Assertions.assertThat(AopUtils.isCglibProxy(proxy)).isTrue();  
}
```

인터페이스가 있지만, CGLIB를 사용해서 클래스 기반 동적 프록시를 만드는 방법이다. 프록시 팩토리는 `proxyTargetClass`라는 옵션을 제공하는데, 이 옵션에 `true`를 넣으면 인터페이스가 있어도 강제로 CGLIB를 사용한다.

```
04:17:07.793 [main] INFO hello.proxy.proxyfactory.ProxyFactoryTest - targetClass = class hello.proxy.common.ServiceImpl
04:17:07.794 [main] INFO hello.proxy.proxyfactory.ProxyFactoryTest - proxyClass = class hello.proxy.common.ServiceImpl$$EnhancerBySpringCGLIB$$75199bd
04:17:07.796 [main] INFO hello.proxy.common.advice.TimeAdvice - TimeAdvice 실행
04:17:07.801 [main] INFO hello.proxy.common.ServiceImpl - save 호출
04:17:07.801 [main] INFO hello.proxy.common.advice.TimeAdvice - TimeAdvice 종료. resultTime = 5
```

> [!summary] 정리
> 프록시 팩토리의 서비스 추상화 덕분에 구체적인 CGLIB, JDK 동적 프록시 기술에 의존하지 않고 매우 편리하게 동적 프록시를 생성할 수 있다.
> 
> 프록시의 부가 기능 로직도 특정 기술에 종속적이지 않게 `Advice` 하나로 편리하게 사용할 수 있었다. 이것은 프록시 팩토리가 내부에서 JDK 동적 프록시인 경우 `InvocationHandler`가 `Advice`를 호출하도록 개발해두고, CGLIB인 경우 `MethodInterceptor`가 `Advice`를 호출하도록 기능을 개발해두었기 때문이다.


> [!warning] 스프링 부트 AOP의 proxyTargetClass
> 스프링 부트는 AOP를 적용할 때 기본적으로 `proxyTargetClass(true)`로 설정해서 사용한다. 따라서 인터페이스가 있어도 항상 CGLIB를 사용해서 구체 클래스를 기반으로 프록시를 생성한다. 자세한 이유는 뒤에서 설명한다.

## 포인트컷, 어드바이스, 어드바이저 - 소개
- **포인트 컷(Pointcut)**: 어디에 부가 기능을 적용할 지, 어디에 부가 기능을 적용하지 않을지 판단하는 필터링 로직이다. 주로 클래스와 메서드 이름으로 필터링 한다. 이름 그대로 어떤 포인트(Point)에 기능을 적용하지 않을지 잘라서(Cut) 구분하는 것이다.
- **어드바이스(Advice)**: 프록시가 호출하는 부가 기능이다. 단순히 프록시 로직이라 생각하면 된다.
- **어드바이저(Advisor)**: 단순하게 하나의 포인트컷과 하나의 어드바이스를 가지고 있는 것이다. 쉽게 이야기해서 *포인트컷1 + 어드바이스1*이 합쳐진 것을 칭하는 개념이다.

부가 기능 로직을 적용해야 한다고 가정하고 정리해보자.

- 포인트컷으로 **어디에** 적용할지 선택
- 어드바이스로 **어떤** 로직을 적용할지 선택

어드바이저는 이 두 개념이 합쳐져서, 모두 알고 있을 때 어드바이저라고 한다. 쉽게 말해 어디에 어떤 로직을 적용할 지 알고 있는 것이다.

**쉽게 기억하기**
- 조언(`Advice`)을 어디에(`Pointcut`)에 할 것인가?
- 조언자(`Advisor`)는 어디(`Pointcut`)에 조언(`Advice`)을 해야할지 알고 있다.

#### 역할과 책임
이렇게 구분한 것은 역할과 책임을 명확하게 분리한 것이다.

![[proxy-factory-3.png]]

- 포인트컷은 대상 여부를 확인하는 필터 역할만 담당한다.
- 어드바이스는 깔끔하게 부가 기능 로직만 담당한다.
- 둘을 합치면 어드바이저가 된다. 스프링의 어드바이저는 하나의 포인트컷 + 하나의 어드바이스로 구성된다.

> [!warning] 
> 단어들의 정의는 문맥상 이해를 돕기 위한 것이고, 프록시에 맞추어 설명했다. 이후 AOP 부분에서 다시 한번 정리한다. 그림은 이해를 돕기 위한 것이고 실제 구현은 약간 다를 수 있다.

## 어드바이저 - 예제 코드 1
어드바이저는 하나의 포인트 컷과 하나의 어드바이스를 가지고 있다. 프록시 팩토리를 통해 프록시를 생성할 때 어드바이저를 제공하면 어디에 어떤 기능을 제공할 지 알 수 있다.

```java
@Test  
void advisorTest1() {  
    ServiceInterface target = new ServiceImpl();  
    ProxyFactory proxyFactory = new ProxyFactory(target);  
  
    DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(Pointcut.TRUE, new TimeAdvice());  
    proxyFactory.addAdvisor(advisor);  
  
    ServiceInterface proxy = (ServiceInterface) proxyFactory.getProxy();  
    proxy.save();  
    proxy.find();  
}
```
- `new DefaultPointcutAdvisor`: `Advisor` 인터페이스의 가장 일반적인 구현체이다. 생성자를 통해 하나의 포인트컷과 하나의 어드바이스를 넣어주면 된다. 어드바이저는 하나의 포인트컷과 하나의 어드바이스로 구성된다.
- `Pointcut.TRUE`: 항상 `true`를 반환하는 포인트컷이다.
- `new TimeAdvice()`: 앞서 개발한 `TimeAdvice` 어드바이스를 제공한다.
- `proxyFactory.addAdvisor(advisor)`: 프록시 팩토리에 적용할 어드바이저를 지정한다. 어드바이저는 내부에 포인트컷과 어드바이스를 모두 가지고 있다. 따라서 어디에 어떤 부가 기능을 적용해야 할지 어드바이스 하나로 알 수 있다. 프록시 팩토리를 사용할 때 어드바이저는 필수이다.
- 그런데 이전에 `proxyFactory.addAdvice(new TimeAdvice())`로 어드바이저가 아니라 어드바이스를 바로 적용했다. 그런데 이것은 단순히 편의 메서드이고 결과적으로 해당 메서드 내부에서 지금 코드와 똑같은 기본 어드바이저가 생성된다.



---
References: 김영한의 스프링 핵심 원리 - 고급편

Links to this page: 