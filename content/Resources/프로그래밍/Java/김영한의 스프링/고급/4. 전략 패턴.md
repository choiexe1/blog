---
title: 
tags:
  - java
  - programming
  - design-pattern
  - strategy-pattern
publish: true
date: 2024-12-31
---
## 전략 패턴 - 예제 1
이번에는 앞서 템플릿 메소드 패턴으로 해결 했던 동일한 문제를 전략 패턴을 사용해서 해결해본다.

템플릿 메서드 패턴은 부모클래스에 변하지 않는 템플릿을 두고, 변하는 부분을 자식 클래스에 두어서 상속을 이용해 문제를 해결했다.

전략 패턴은 변하지 않는 부분을 `Context`라는 곳에 두고, 변하는 부분을 `Strategy`라는 인터페이스를 만들어 해당 인터페이스를 구현하도록 해서 문제를 해결한다. 상속이 아니라 위임으로 문제를 해결하는 것이다.

전략 패턴에서 `Context`는 변하지 않는 템플릿 역할을 하고, `Strategy`는 변하는 알고리즘 역할을 한다. 그림으로 살펴보면 다음과 같다.

![[strategy-1.png]]

다음과 같이 변하는 부분, 즉 알고리즘을 인터페이스로 제공하기 위해 `Strategy` 인터페이스를 구현한다.

```java
public interface Strategy {  
    void call();  
}
```

이 `Strategy`는 `Context`의 내부에서 `call()`을 호출한다. 따라서 `call()`을 어떻게 구현하냐에 따라서 제공되는 알고리즘이 변경되는 것이다. 다음으로 이 인터페이스를 구현하는 구현체를 구현한다.

```java
@Slf4j  
public class StrategyLogic1 implements Strategy {  
    @Override  
    public void call() {  
        log.info("비즈니스 로직1 실행");  
    }  
}

@Slf4j  
public class StrategyLogic2 implements Strategy {  
    @Override  
    public void call() {  
        log.info("비즈니스 로직2 실행");  
    }  
}
```

`Strategy1`과 `Strategy2`는 각각 `Strategy`의 구현체이며 `call()`의 구현이 서로 상이하다.

```java
/**  
 * 필드에 전략을 보관하는 방식  
 */  
@Slf4j  
public class ContextV1 {  
    private Strategy strategy;  
  
    public ContextV1(Strategy strategy) {  
        this.strategy = strategy;  
    }  
  
    public void execute() {  
        long startTime = System.currentTimeMillis();  
  
        strategy.call();  
  
        long endTime = System.currentTimeMillis();  
        long resultTime = endTime - startTime;  
        log.info("resultTime = {}ms", resultTime);  
    }  
}
```

`ContextV1`은 변하지 않는 로직을 가지고 있는 템플릿 역할을 하는 코드이다. 전략 패턴에서는 이것을 컨텍스트(문맥)이라 한다. 쉽게 이야기해서 컨텍스트(문맥)는 크게 변하지 않지만 그 문맥 속에서 `strategy`를 통해 일부 전략이 변경된다고 생각하면 된다.

`ContextV1`은 내부에 `Strategy` 인터페이스를 의존하는 `strategy` 필드를 가지고 있다. 이 필드에 변하는 부분인 `Strategy`의 구현체를 주입하면 된다. 전략 패턴의 핵심은 `Context`가 `Strategy` 인터페이스에만 의존한다는 점이다. 덕분에 `Strategy`의 구현체를 변경하거나 새로 만들어도 `Context` 코드에는 영향을 주지 않는다.

굉장히 익숙한 패턴의 코드인데, 스프링의 의존관계 주입에서 사용하는 방식이 바로 전략 패턴이다.

```java
@Test  
void strategyV1() {  
    StrategyLogic1 strategyLogic1 = new StrategyLogic1();  
    ContextV1 context1 = new ContextV1(strategyLogic1);  
  
    StrategyLogic2 strategyLogic2 = new StrategyLogic2();  
    ContextV1 context2 = new ContextV1(strategyLogic2);  
  
    context1.execute();  
    context2.execute();  
}
```

코드를 살펴보면 의존관계 주입을 통해 `Context` 안에 원하는 전략을 주입하고, `execute`로 실행한다.

## 전략 패턴 - 예제 2
전략 패턴도 익명 내부 클래스를 활용할 수 있다.




---
References: 김영한의 스프링 핵심 원리 - 고급편

Links to this page: 