---
title: 
tags:
  - java
  - programming
  - design-pattern
  - strategy-pattern
publish: true
date: 2025-01-01
---
## 전략 패턴 - 예제 1
이번에는 앞서 템플릿 메소드 패턴으로 해결 했던 동일한 문제를 전략 패턴을 사용해서 해결해본다.

템플릿 메서드 패턴은 부모클래스에 변하지 않는 템플릿을 두고, 변하는 부분을 자식 클래스에 두어서 상속을 이용해 문제를 해결했다.

전략 패턴은 변하지 않는 부분을 `Context`라는 곳에 두고, 변하는 부분을 `Strategy`라는 인터페이스를 만들어 해당 인터페이스를 구현하도록 해서 문제를 해결한다. 상속이 아니라 위임으로 문제를 해결하는 것이다.

전략 패턴에서 `Context`는 변하지 않는 템플릿 역할을 하고, `Strategy`는 변하는 알고리즘 역할을 한다. 그림으로 살펴보면 다음과 같다.

![[strategy-1.png]]

다음과 같이 변하는 부분, 즉 알고리즘을 인터페이스로 제공하기 위해 `Strategy` 인터페이스를 구현한다.

```java
public interface Strategy {  
    void call();  
}
```

이 `Strategy`는 `Context`의 내부에서 `call()`을 호출한다. 따라서 `call()`을 어떻게 구현하냐에 따라서 제공되는 알고리즘이 변경되는 것이다. 다음으로 이 인터페이스를 구현하는 구현체를 구현한다.

```java
@Slf4j  
public class StrategyLogic1 implements Strategy {  
    @Override  
    public void call() {  
        log.info("비즈니스 로직1 실행");  
    }  
}

@Slf4j  
public class StrategyLogic2 implements Strategy {  
    @Override  
    public void call() {  
        log.info("비즈니스 로직2 실행");  
    }  
}
```

`Strategy1`과 `Strategy2`는 각각 `Strategy`의 구현체이며 `call()`의 구현이 서로 상이하다.

```java
/**  
 * 필드에 전략을 보관하는 방식  
 */  
@Slf4j  
public class ContextV1 {  
    private Strategy strategy;  
  
    public ContextV1(Strategy strategy) {  
        this.strategy = strategy;  
    }  
  
    public void execute() {  
        long startTime = System.currentTimeMillis();  
  
        strategy.call();  
  
        long endTime = System.currentTimeMillis();  
        long resultTime = endTime - startTime;  
        log.info("resultTime = {}ms", resultTime);  
    }  
}
```

`ContextV1`은 변하지 않는 로직을 가지고 있는 템플릿 역할을 하는 코드이다. 전략 패턴에서는 이것을 컨텍스트(문맥)이라 한다. 쉽게 이야기해서 컨텍스트(문맥)는 크게 변하지 않지만 그 문맥 속에서 ``

---
References: 김영한의 스프링 핵심 원리 - 고급편

Links to this page: 