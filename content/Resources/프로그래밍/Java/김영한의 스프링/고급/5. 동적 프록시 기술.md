---
title: 
tags:
  - java
  - programming
  - design-pattern
  - proxy-pattern
  - decorator-pattern
  - dynamic-proxy
  - spring
  - cglib
  - jdk-dynamic-proxy
  - reflection
publish: true
date: 2025-01-02
---
## 리플렉션
지금까지 프록시를 사용해서 기존 코드를 변경하지 않고 로그 추적기라는 부가 기능을 적용할 수 있었다. 그런데 문제는 대상 클래스 수만큼 로그 추적기를 위한 프록시 클래스를 만들어야 한다는 점이다. 로그 추적을 위한 프록시 클래스들의 소스코드는 거의 같은 모양을 하고 있다.

자바가 기본으로 제공하는 **JDK 동적 프록시** 기술이나 **CGLIB** 같은 프록시 생성 오픈소스 기술을 활용하면 프록시 객체를 동적으로 만들어 낼 수 있다. 쉽게 이야기 해서 프록시 클래스를 지금처럼 계속 만들지 않아도 된다는 것이다. 프록시를 적용할 코드를 하나만 만들어두고, 동적 프록시 기술을 사용해서 프록시 객체를 찍어내면 된다.

JDK 동적 프록시를 이해하기 위해서는 먼저 자바의 **리플렉션** 기술을 이해해야 한다. 리플렉션 기술을 사용하면 클래스나 메서드의 메타정보를 동적으로 획득하고, 코드도 동적으로 호출할 수 있다.

여기서는 JDK 동적 프록시를 이해하기 위한 최소한의 리플렉션 기술을 알아본다.

```java
@Slf4j  
public class ReflectionTest {  

    @Test  
    void reflection0() {  
        Hello target = new Hello();  
  
        // 공통 로직1 시작  
        log.info("start");  
        String result1 = target.callA();  
        log.info("result = {}", result1);  
        // 공통 로직1 종료  
  
        // 공통 로직2 시작  
        log.info("start");  
        String result2 = target.callB();  
        log.info("result = {}", result2);  
        // 공통 로직2 종료  
    }  
  
    @Slf4j  
    static class Hello {  
        public String callA() {  
            log.info("callA");  
            return "A";  
        }  
  
        public String callB() {  
            log.info("callB");  
            return "B";  
        }  
    }  
}
```

`reflrection0()` 메서드를 살펴보면 `공통로직1`과 `공통로직2`는 호출하는 메서드만 다르고 전체 코드 흐름이 완전히 같다.

여기서 `공통 로직1`과 `공통 로직2`를 하나의 메서드로 뽑아서 합칠 수 있을까? 쉬워 보이지만 메서드로 뽑아서 공통화 하는 것은 생각보다 어렵다. 중간에 호출되는 메서드가 다르기 때문이다. 호출하는 메서드인 `target.callA()`와 `target.callB()` 부분만 동적으로 처리할 수 있다면 문제를 해결할 수 있다.

이럴 때 사용하는 기술이 바로 리플렉션이다. 리플렉션은 클래스나 메서드의 메타정보를 사용해서 동적으로 호출하는 메서드를 변경할 수 있다.

```java
@Test  
void reflection1() throws Exception {  
    // 클래스 정보 획득  
    Class classHello = Class.forName("hello.proxy.jdkdynamic.ReflectionTest$Hello");  
  
    Hello target = new Hello();  
  
    // callA 메서드 정보 획득하고 실행  
    Method methodCallA = classHello.getMethod("callA");  
    Object result1 = methodCallA.invoke(target);  
    log.info("result1 = {}", result1);  
  
    // callB 메서드 정보 획득하고 실행  
    Method methodCallB = classHello.getMethod("callB");  
    Object result2 = methodCallB.invoke(target);  
    log.info("result2 = {}", result2);  
}
```
- `Class.forName("hello.proxy.jdkdynamic.ReflectionTest$Hello")`: 클래스 메타정보를 획득한다. 참고로 내부 클래스는 구분을 위해 `$` 기호를 사용한다. `ReflectionTest` 클래스에 [[중첩 클래스와 내부 클래스#정적 중첩 클래스 (Static Nested Class)|정적 중첩 클래스]]인 `Hello`가 존재하기 때문에 `$`를 사용한다. 
- `classHello.getMethod("call")`: 해당 클래스의 `call` 메서드 메타정보를 획득한다.
- `methodCallA.invoke(target)`: 획득한 메서드 메타정보로 실제 인스턴스의 메서드를 호출한다. 여기서 `methodCallA`는 `Hello` 클래스의 `callA()`라는 메서드 메타정보이다. `methodCallA.invoke(인스턴스)`를 호출하면서 인스턴스를 넘겨주면 해당 인스턴스의 `callA()` 메서드를 찾아서 실행한다. 여기서는 `target`의 `callA()` 메서드를 호출한다.

이렇게 메서드 정보를 획득해서 메서드를 호출하면 **클래스나 메서드 정보를 동적으로 변경할 수 있다는 장점**이 있다. 문자열 데이터를 기반으로 정보를 획득하기 때문이다.

어쨌든 기존의 `callA()`와 `callB()` 메서드를 직접 호출하는 부분이 `Method`로 대체되었다. 덕분에 이제 공통 로직을 만들 수 있다.

```java
private void dynamicCall(Method method, Object target) throws Exception {  
    log.info("start");  
    Object result = method.invoke(target);  
    log.info("result = {}", result);  
}
```

`dynamicCall()`은 메서드 호출을 이렇게 리플렉션을 이용해 추상화한 메서드이다. 

- `Method method`: 첫 번째 파라미터인 `method`는 호출할 메서드 정보가 전달된다. 기존에는 메서드 이름을 직접 호출했지만 이제는 `Method`라는 메타정보를 통해서 호출할 메서드 정보가 동적으로 제공된다.
- `Object target`: 실제 실행할 인스턴스 정보가 넘어온다. 물론 `method.invoke(target)`을 사용할 때 호출할 클래스와 메서드 정보가 서로 다르면 예외가 발생한다.
- `throws Exception`: 다양한 체크 예외를 던

이제 이 메서드를 이용해서 기존 코드를 변경하면 다음과 같다.

```java
@Test  
void reflection2() throws Exception {  
    // 클래스 정보 획득  
    Class classHello = Class.forName("hello.proxy.jdkdynamic.ReflectionTest$Hello");  
  
    Hello target = new Hello();  
  
    // callA 메서드 정보 획득하고 실행  
    Method methodCallA = classHello.getMethod("callA");  
    dynamicCall(methodCallA, target);  
  
    // callB 메서드 정보 획득하고 실행  
    Method methodCallB = classHello.getMethod("callB");  
    dynamicCall(methodCallB, target);  
}
```


---
References: 김영한의 스프링 핵심 원리 - 고급편

Links to this page: [[중첩 클래스와 내부 클래스]]