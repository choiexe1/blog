---
title: 
tags:
  - java
  - programming
  - design-pattern
  - proxy-pattern
  - decorator-pattern
  - dynamic-proxy
  - spring
  - cglib
  - jdk-dynamic-proxy
  - reflection
publish: true
date: 2025-01-02
---
## 리플렉션
지금까지 프록시를 사용해서 기존 코드를 변경하지 않고 로그 추적기라는 부가 기능을 적용할 수 있었다. 그런데 문제는 대상 클래스 수만큼 로그 추적기를 위한 프록시 클래스를 만들어야 한다는 점이다. 로그 추적을 위한 프록시 클래스들의 소스코드는 거의 같은 모양을 하고 있다.

자바가 기본으로 제공하는 **JDK 동적 프록시** 기술이나 **CGLIB** 같은 프록시 생성 오픈소스 기술을 활용하면 프록시 객체를 동적으로 만들어 낼 수 있다. 쉽게 이야기 해서 프록시 클래스를 지금처럼 계속 만들지 않아도 된다는 것이다. 프록시를 적용할 코드를 하나만 만들어두고, 동적 프록시 기술을 사용해서 프록시 객체를 찍어내면 된다.

JDK 동적 프록시를 이해하기 위해서는 먼저 자바의 **리플렉션** 기술을 이해해야 한다. 리플렉션 기술을 사용하면 클래스나 메서드의 메타정보를 동적으로 획득하고, 코드도 동적으로 호출할 수 있다.

여기서는 JDK 동적 프록시를 이해하기 위한 최소한의 리플렉션 기술을 알아본다.

```java
@Slf4j  
public class ReflectionTest {  

    @Test  
    void reflection0() {  
        Hello target = new Hello();  
  
        // 공통 로직1 시작  
        log.info("start");  
        String result1 = target.callA();  
        log.info("result = {}", result1);  
        // 공통 로직1 종료  
  
        // 공통 로직2 시작  
        log.info("start");  
        String result2 = target.callB();  
        log.info("result = {}", result2);  
        // 공통 로직2 종료  
    }  
  
    @Slf4j  
    static class Hello {  
        public String callA() {  
            log.info("callA");  
            return "A";  
        }  
  
        public String callB() {  
            log.info("callB");  
            return "B";  
        }  
    }  
}
```

`reflrection0()` 메서드를 살펴보면 `공통로직1`과 `공통로직2`는 호출하는 메서드만 다르고 전체 코드 흐름이 완전히 같다.

여기서 `공통 로직1`과 `공통 로직2`를 하나의 메서드로 뽑아서 합칠 수 있을까? 쉬워 보이지만 메서드로 뽑아서 공통화 하는 것은 생각보다 어렵다. 중간에 호출되는 메서드가 다르기 때문이다. 호출하는 메서드인 `target.callA()`와 `target.callB()` 부분만 동적으로 처리할 수 있다면 문제를 해결할 수 있다.

이럴 때 사용하는 기술이 바로 리플렉션이다. 리플렉션은 클래스나 메서드의 메타정보를 사용해서 동적으로 호출하는 메서드를 변경할 수 있다.

```java

```

---
References: 김영한의 스프링 핵심 원리 - 고급편

Links to this page: 