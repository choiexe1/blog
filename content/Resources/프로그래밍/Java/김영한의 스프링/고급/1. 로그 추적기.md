---
title: 
tags:
  - java
  - programming
  - spring
publish: true
date: 2024-12-29
---
## 예제 프로젝트 만들기 - V0
- Gradle - Groovy
- Java 17
- Spring Boot 3.4.1
	- Spring Web
	- Lombok

스프링에 대한 핵심 원리를 파악해보기 위해 먼저 예제 프로젝트로 상품을 주문하는 프로세스로 가정하고, 일반적인 웹 어플리케이션에서 `Controller -> Service -> Repository`로 이어지는 흐름을 최대한 단순하게 만들어본다.

```java title="OrderRepositoryV0.java"
@Repository  
@RequiredArgsConstructor  
public class OrderRepositoryV0 {  
    public void save(String itemId) {  
        if (itemId.equals("ex")) {  
            throw new IllegalStateException("예외 발생");  
        }  
          
        sleep(1000);  
    }  
  
    private void sleep(int ms) {  
        try {  
            Thread.sleep(ms);  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
    }  
}
```

```java title="OrderServiceV0.java"
@Service  
@RequiredArgsConstructor  
public class OrderServiceV0 {  
    private final OrderRepositoryV0 orderRepository;  
  
    public void orderItem(String itemId) {  
        orderRepository.save(itemId);  
    }  
}
```

```java title="OrderControllerV0.java"
@RestController  
@RequiredArgsConstructor  
public class OrderControllerV0 {  
    private final OrderServiceV0 orderService;  
  
    @GetMapping("/v0/request")  
    public String request(String itemId) {  
        orderService.orderItem(itemId);  
        return "ok";  
    }  
}
```

테스트 삼아 요청을 보내보면 정상적으로 잘 동작한다.

## 로그 추적기 - 요구사항 분석

다음의 상황을 가정하고 로그 추적기를 구현해본다.
```
새로운 회사에 입사했는데, 수 년간 운영중인 거대한 프로젝트에 투입되었다. 
전체 소스 코드는 수 십만 라인이고 클래스 수도 수 백개 이상이다. 처음 맡겨진 요구사항은 로그 추적기를 만드는 것이다.

어플리케이션이 점점 커지면서 점점 모니터링과 운영이 중요해지는 단계이다. 
특히 최근 자주 병목이 발생하고 있다. 어떤 부분에서 병목이 발생하는지, 그리고 어떤 부분에서 예외가 발생하는지를 로그를 통해 확인하는 것이 점점 중요해지고 있다.

기존에는 개발자가 문제가 발생한 다음에 관련 부분을 어렵게 찾아서 로그를 하나하나 직접 만들어서 남겼다. 로그를 미리 남겨둔다면 이런 부분을 손쉽게 찾을 수 있을 것이다. 
이 부분을 개선하고 자동화 하는 것이 미션이다.
```

**요구사항**
- 모든 `public` 메서드의 호출과 응답 정보를 로그에 출력
- 어플리케이션의 흐름을 변경하면 안됨
	- 로그를 남긴다고 해서 비즈니스 로직의 동작에 영향을 주어선 안됨
- 메서드 호출에 걸린 시간 출력
- 정상 흐름과 예외 흐름 구분
	- 예외 발생 시 예외 정보가 남아야 함
- 메서드 호출의 깊이 표현
- HTTP 요청을 구분
	- HTTP 요청 단위로 특정 ID를 남겨서 어떤 HTTP 요청에서 시작된 것인지 명확하게 구분이 가능해야 함
	- 트랜잭션 ID (DB 트랜잭션 X), 여기서는 하나의 HTTP 요청이 시작해서 끝날 때 까지를 하나의 트랜잭션이라 함

**예시**

```
정상 요청
[796bccd9] OrderController.request()
[796bccd9] |-->OrderService.orderItem()
[796bccd9] | |-->OrderRepository.save()
[796bccd9] | |<--OrderRepository.save() time=1004ms
[796bccd9] |<--OrderService.orderItem() time=1014ms
[796bccd9] OrderController.request() time=1016ms

예외 발생
[b7119f27] OrderController.request()
[b7119f27] |-->OrderService.orderItem()
[b7119f27] | |-->OrderRepository.save()
[b7119f27] | |<X-OrderRepository.save() time=0ms ex=java.lang.IllegalStateException: 예외 발생!
[b7119f27] |<X-OrderService.orderItem() time=10ms ex=java.lang.IllegalStateException: 예외 발생!
[b7119f27] OrderController.request() time=11ms ex=java.lang.IllegalStateException: 예외 발생!
```

## 로그 추적기 V1 - 프로토타입 개발
어플리케이션의 모든 로직에 직접 로그를 남겨도 되지만, 그것보다는 더 효율적인 방법이 필요하다. 특히 트랜잭션 ID와 깊이를 표현하는 방법은 기존 정보를 이어 받아야 하기 때문에 단순히 로그만 남긴다고 해결할 수 있는 것은 아니다.

요구사항에 맞추어 어플리케이션에 효과적으로 로그를 남기기 위한 로그 추적기를 개발해본다.

```java title="TraceId.java"
public class TraceId {  
    private final String id;  
    private final int level;  
  
    public TraceId() {  
        this.id = createId();  
        this.level = 0;  
    }  
  
    private TraceId(String id, int level) {  
        this.id = id;  
        this.level = level;  
    }  
  
    private String createId() {  
        return UUID.randomUUID().toString().substring(0, 8);  
    }  
  
    public TraceId createNextId() {  
        return new TraceId(id, level + 1);  
    }  
  
    public TraceId createPreviousId() {  
        return new TraceId(id, level - 1);  
    }  
  
    public boolean isFirstLevel() {  
        return level == 0;  
    }  
  
    public String getId() {  
        return id;  
    }  
  
    public int getLevel() {  
        return level;  
    }  
}
```

예시를 살펴보면 `트랜잭션 ID`와 로그의 깊이를 표현할 방법이 필요하다. 이 `TraceId` 클래스는 `트랜잭션 ID`와 깊이를 표현하는 `Level` 개념을 묶어서 만든 클래스이다. 이 `TraceId`는 단순히 `트랜잭션 ID`와 `level` 정보를 함께 가지고 있다.


```java title="TraceStatus.java"
public class TraceStatus {  
    private TraceId traceId;  
    private Long startTimeMs;  
    private String message;  
  
    public TraceStatus(TraceId traceId, Long startTimeMs, String message) {  
        this.traceId = traceId;  
        this.startTimeMs = startTimeMs;  
        this.message = message;  
    }  
  
    public TraceId getTraceId() {  
        return traceId;  
    }  
  
    public Long getStartTimeMs() {  
        return startTimeMs;  
    }  
  
    public String getMessage() {  
        return message;  
    }  
}
```

`TraceStatus`는 로그를 시작할 때의 상태 정보를 갖고 있다. 이 상태 정보는 로그를 종료할 때 사용된다.

```java title="HelloTraceV1.java"
@Slf4j  
@Component  
public class HelloTraceV1 {  
    private static final String START_PREFIX = "-->";  
    private static final String COMPLETE_PREFIX = "<--";  
    private static final String EX_PREFIX = "<X-";  
  
    public TraceStatus begin(String message) {  
        TraceId traceId = new TraceId();  
        Long startTimeMs = System.currentTimeMillis();  
        log.info("[{}] {}{}", traceId.getId(), addSpace(START_PREFIX, traceId.getLevel()), message);  
        return new TraceStatus(traceId, startTimeMs, message);  
    }  
  
    public void end(TraceStatus status) {  
        complete(status, null);  
    }  
  
    public void exception(TraceStatus status, Exception e) {  
        complete(status, e);  
    }  
  
    private void complete(TraceStatus status, Exception e) {  
        Long stopTimeMs = System.currentTimeMillis();  
        long resultTimeMs = stopTimeMs - status.getStartTimeMs();  
        TraceId traceId = status.getTraceId();  
        if (e == null) {  
            log.info("[{}] {}{} time={}ms", traceId.getId(),  
                    addSpace(COMPLETE_PREFIX, traceId.getLevel()), status.getMessage(),  
                    resultTimeMs);  
        } else {  
            log.info("[{}] {}{} time={}ms ex={}", traceId.getId(),  
                    addSpace(EX_PREFIX, traceId.getLevel()), status.getMessage(), resultTimeMs,  
                    e.toString());  
        }  
    }  
  
    private static String addSpace(String prefix, int level) {  
        StringBuilder sb = new StringBuilder();  
        for (int i = 0; i < level; i++) {  
            sb.append((i == level - 1) ? "|" + prefix : "| ");  
        }  
        return sb.toString();  
    }  
}
```

공개 메서드는 다음 세 가지이다.
- `begin()`
- `end()`
- `exception()`



---
References: 김영한의 스프링 핵심 원리 - 고급편

Links to this page: 