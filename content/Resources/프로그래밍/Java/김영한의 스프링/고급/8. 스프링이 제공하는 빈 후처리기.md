---
title: 
tags:
  - java
  - programming
  - proxy
  - bean-post-processor
publish: true
date: 2025-01-03
---
# 스프링이 제공하는 빈 후처리기

## 배경
- 개발자의 게으름은 끝이 없다. 빈 후처리기 자체를 직접 작성하고 등록하는 것도 귀찮은 행위다.
- 스프링 부트는 편의를 위해 자동으로 프록시를 생성해주는 빈 후처리기인 `AnnotationAwareAspectJAutoProxyCreator`를 스프링 빈으로 등록한다.

## 라이브러리 추가

```gradle title="build.gradle"
implementation 'org.springframework.boot:spring-boot-starter-aop'
```

- 스프링 부트가 없던 시절에는 `@EnableAspectJAutoProxy`를 직접 사용해야 했다.
- 이 라이브러리를 추가하면 `aspectjweaver`라는 `aspectJ` 관련 라이브러리를 등록하고 스프링 부트가 AOP 관련 클래스를 자동으로 스프링 빈에 등록한다.

## 자동 프록시 생성기 AutoProxyCreater
- 위 라이브러리를 추가하면 **자동으로 프록시를 생성해주는 빈 후처리기인 `AnnotationAwareAspectJAutoProxyCreator`를 스프링 빈으로 등록**한다.
- 이름 그대로 자동으로 프록시를 생성해주는 빈 후처리기이다.
- 이 빈 후처리기는 스프링 빈으로 등록된 `Advisor`들을 자동으로 찾아서 프록시가 필요한 곳에 자동으로 프록시를 적용한다.
- `Advisor` 안에는 `Pointcut`과 `Advice`가 이미 모두 포함되어 있다. 따라서 `Advisor`만 알고 있으면 그 안에 있는 `Pointcut`으로 어떤 스프링 빈에 프록시를 적용해야 할 지 알 수 있다. 그리고 `Advice`로 부가 기능을 적용하면 된다.

## 자동 프록시 생성기의 작동 과정
![[auto-bean-post-processor-1.png]]
1. **생성**: 스프링이 스프링 빈 대상이 되는 객체를 생성한다.
2. **전달**: 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달한다.
3. **모든 Advisor 빈 조회**: 자동 프록시 생성 빈 후처리기는 스프링 컨테이너에서 모든 `Advisor`를 조회한다.
4. **프록시 적용 대상 체크**: 앞서 조회한 `Advisor`에 포함되어 있는 포인트컷을 사용해서 해당 객체가 프록시를 적용할 대상인지 아닌지 판단한다.
	- 이 때 객체의 클래스 정보는 물론이고, 해당 객체의 모든 메서드를 포인트컷에 하나하나 모두 매칭해본다.
	- 조건이 하나라도 만족하면 프록시 적용 대상이 된다.
	- 예를 들어 10개의 메서드 중에 하나만 포인트컷 조건에 만족해도 프록시 적용 대상이 된다.
5. **프록시 생성**: 프록시 적용 대상이면 프록시를 생성하고 반환해서 프록시를 스프링 빈으로 등록한다. 만약 프록시 적용 대상이 아니라면 원본 객체를 반환해서 원본 객체를 스프링 빈으로 등록한다.
6. **빈 등록**: 반환된 객체는 스프링 빈으로 등록된다.

## 프록시 생성 단계의 포인트컷과 프록시 실행 단계의 포인트컷
- **프록시 생성 여부 판단**: 자동 프록시 생성 빈 후처리기는 프록시 생성 여부 판단을 위해 어드바이저의 포인트컷을 참조한다.
	- 프록시 생성 여부 판단 단계에서는 포인트컷을 이용해 프록시를 생성할 지 판단하는 것이다.
- **어드바이스 적용 여부 판단**: 생성된 프록시는 어드바이저에서 포인트컷을 다시 참조해서 포인트컷 조건에 맞을 때 메서드를 실행하고, 타겟을 실행한다.
	- 어드바이스 적용 여부 판단 단계에서는 메서드를 실행할 지의 여부를 판단하는 것이다.

## 예시

#### 자동 프록시 생성 빈 후처리기 사용
- 자동 프록시 생성 빈 후처리기는 **스프링 컨테이너에서 모든 어드바이저를 조회하고, 해당 어드바이저 내부의 포인트컷을 통해 프록시를 생성**한다.
- 따라서 개발자는 어드바이저만 스프링 빈으로 등록하면 된다.

```java
@Configuration  
@Import({AppV1Config.class, AppV2Config.class})  
public class AutoProxyConfig {  
  
    @Bean  
    public Advisor advisor1(LogTrace logTrace) {  
        NameMatchMethodPointcut pointcut = new NameMatchMethodPointcut();  
        pointcut.setMappedNames("request*", "order*", "save*");  
  
        LogTraceAdvice advice = new LogTraceAdvice(logTrace);  
        return new DefaultPointcutAdvisor(pointcut, advice);  
    }  
}
```


```
2025-01-03 10:18:43.162  INFO 7288 --- [           main] h.p.trace.logtrace.ThreadLocalLogTrace   : [8a954eb2] |-->AppV1Config.orderServiceV1()
2025-01-03 10:18:43.162  INFO 7288 --- [           main] h.p.trace.logtrace.ThreadLocalLogTrace   : [8a954eb2] |   |-->AppV1Config.orderRepositoryV1()
2025-01-03 10:18:43.163  INFO 7288 --- [           main] h.p.trace.logtrace.ThreadLocalLogTrace   : [8a954eb2] |   |<--AppV1Config.orderRepositoryV1() time=1ms
2025-01-03 10:18:43.164  INFO 7288 --- [           main] h.p.trace.logtrace.ThreadLocalLogTrace   : [8a954eb2] |<--AppV1Config.orderServiceV1() time=2ms
2025-01-03 10:18:43.166  INFO 7288 --- [           main] h.p.trace.logtrace.ThreadLocalLogTrace   : [8a954eb2] AppV1Config.orderControllerV1() time=9ms
```

- 그런데 어플리케이션을 실행해보면 스프링이 초기화되면서 기대하지 않은 로그들이 올라온다.
- 그 이유는 현재 사용중인 포인트컷이 단순히 메서드 이름에 `request*`, `order*`, `save*`만 포함되어 있으면 매칭된다고 판단하기 때문이다.
- 



---
References: 김영한의 스프링 핵심 원리 - 고급편

Links to this page: [[7. 빈 후처리기]]