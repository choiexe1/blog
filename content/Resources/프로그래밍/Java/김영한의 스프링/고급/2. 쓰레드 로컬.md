---
title: 
tags:
  - java
  - programming
  - thread
publish: true
date: 2024-12-30
---
## 필드 동기화 - 개발
앞서 [[1. 로그 추적기|로그 추적기]]를 만들면서 다음 로그를 출력할 때 `트랜잭션 ID`와 `level`을 동기화 하는 문제가 있었다. 그리고 이 문제를 해결하기 위해 `TraceId`를 파라미터로 넘기도록 구현했다. 이렇게 해서 동기화는 성공했지만 로그를 출력하는 모든 메서드에 `TraceId` 파라미터를 추가해야 하는 문제가 발생했다.

이런 문제를 해결할 목적으로 새로운 버전의 로그 추적기를 구현한다. 향후 다양한 구현체로 변경할 수 있도록 `LogTrace` 인터페이스를 먼저 정의한다.

```java
public interface LogTrace {  
    TraceStatus begin(String message);  
  
    void end(TraceStatus status);  
  
    void exception(TraceStatus status, Exception exception);  
}
```

이 `LogTrace` 인터페이스에는 로그 추적기를 위한 최소한의 기능인 `begin()`, `end()`, `exception()`을 정의했다. 이제 파라미터를 넘기지 않고 `TraceId`를 동기화 할 수 있는 `FieldLogTrace`를 구현해본다.

```java
@Slf4j  
public class FieldLogTrace implements LogTrace {  
    private static final String START_PREFIX = "-->";  
    private static final String COMPLETE_PREFIX = "<--";  
    private static final String EX_PREFIX = "<X-";  
  
    private TraceId traceIdHolder;  
  
    @Override  
    public TraceStatus begin(String message) {  
        syncTraceId();  
        TraceId traceId = traceIdHolder;  
  
        Long startTimeMs = System.currentTimeMillis();  
        log.info("[{}] {}{}", traceId.getId(), addSpace(START_PREFIX, traceId.getLevel()), message);  
        return new TraceStatus(traceId, startTimeMs, message);  
    }  
  
    private void syncTraceId() {  
        if (traceIdHolder == null) {  
            traceIdHolder = new TraceId();  
        } else {  
            traceIdHolder = traceIdHolder.createNextId();  
        }  
    }  
  
    @Override  
    public void end(TraceStatus status) {  
        complete(status, null);  
    }  
  
    @Override  
    public void exception(TraceStatus status, Exception exception) {  
        complete(status, exception);  
  
    }  
  
    private void releaseTraceId() {  
        if (traceIdHolder.isFirstLevel()) {  
            traceIdHolder = null;  
        } else {  
            traceIdHolder = traceIdHolder.createPreviousId();  
        }  
    }  
  
    private void complete(TraceStatus status, Exception e) {  
        Long stopTimeMs = System.currentTimeMillis();  
        long resultTimeMs = stopTimeMs - status.getStartTimeMs();  
        TraceId traceId = status.getTraceId();  
        if (e == null) {  
            log.info("[{}] {}{} time={}ms", traceId.getId(),  
                    addSpace(COMPLETE_PREFIX, traceId.getLevel()), status.getMessage(),  
                    resultTimeMs);  
        } else {  
            log.info("[{}] {}{} time={}ms ex={}", traceId.getId(),  
                    addSpace(EX_PREFIX, traceId.getLevel()), status.getMessage(), resultTimeMs,  
                    e.toString());  
        }  
  
        releaseTraceId();  
    }  
  
  
    private static String addSpace(String prefix, int level) {  
        StringBuilder sb = new StringBuilder();  
        for (int i = 0; i < level; i++) {  
            sb.append((i == level - 1) ? "|" + prefix : "| ");  
        }  
        return sb.toString();  
    }  
}
```

`FieldLogTrace`는 기존에 만들었던 `HelloTraceV2`와 거의 같은 기능을 한다. `TraceId`를 동기화 하는 부분만 파라미터를 사용하는 것에서 `TraceId traceIdHolder` 필드를 사용하도록 변경되었다.

이제 직전 로그의 `traceId`는 파라미터로 전달되는 것이 아니라 `FieldLogTrace`의 필드인 `traceIdHolder`에 저장된다.

---
References: 김영한의 스프링 핵심 원리 - 고급편

Links to this page: [[1. 로그 추적기]]