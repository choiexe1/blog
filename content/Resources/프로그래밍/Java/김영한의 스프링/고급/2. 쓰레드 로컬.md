---
title: 
tags:
  - java
  - programming
  - thread
publish: true
date: 2024-12-30
---
## 필드 동기화 - 개발
앞서 [[1. 로그 추적기|로그 추적기]]를 만들면서 다음 로그를 출력할 때 `트랜잭션 ID`와 `level`을 동기화 하는 문제가 있었다. 그리고 이 문제를 해결하기 위해 `TraceId`를 파라미터로 넘기도록 구현했다. 이렇게 해서 동기화는 성공했지만 로그를 출력하는 모든 메서드에 `TraceId` 파라미터를 추가해야 하는 문제가 발생했다.

이런 문제를 해결할 목적으로 새로운 버전의 로그 추적기를 구현한다. 향후 다양한 구현체로 변경할 수 있도록 `LogTrace` 인터페이스를 먼저 정의한다.

```java
public interface LogTrace {  
    TraceStatus begin(String message);  
  
    void end(TraceStatus status);  
  
    void exception(TraceStatus status, Exception exception);  
}
```

이 `LogTrace` 인터페이스에는 로그 추적기를 위한 최소한의 기능인 `begin()`, `end()`, `exception()`을 정의했다. 이제 파라미터를 넘기지 않고 `TraceId`를 동기화 할 수 있는 `FieldLogTrace`를 구현해본다.

```java
@Slf4j  
public class FieldLogTrace implements LogTrace {  
    private static final String START_PREFIX = "-->";  
    private static final String COMPLETE_PREFIX = "<--";  
    private static final String EX_PREFIX = "<X-";  
  
    private TraceId traceIdHolder;  
  
    @Override  
    public TraceStatus begin(String message) {  
        syncTraceId();  
        TraceId traceId = traceIdHolder;  
  
        Long startTimeMs = System.currentTimeMillis();  
        log.info("[{}] {}{}", traceId.getId(), addSpace(START_PREFIX, traceId.getLevel()), message);  
        return new TraceStatus(traceId, startTimeMs, message);  
    }  
  
    private void syncTraceId() {  
        if (traceIdHolder == null) {  
            traceIdHolder = new TraceId();  
        } else {  
            traceIdHolder = traceIdHolder.createNextId();  
        }  
    }  
  
    @Override  
    public void end(TraceStatus status) {  
        complete(status, null);  
    }  
  
    @Override  
    public void exception(TraceStatus status, Exception exception) {  
        complete(status, exception);  
  
    }  
  
    private void releaseTraceId() {  
        if (traceIdHolder.isFirstLevel()) {  
            traceIdHolder = null;  
        } else {  
            traceIdHolder = traceIdHolder.createPreviousId();  
        }  
    }  
  
    private void complete(TraceStatus status, Exception e) {  
        Long stopTimeMs = System.currentTimeMillis();  
        long resultTimeMs = stopTimeMs - status.getStartTimeMs();  
        TraceId traceId = status.getTraceId();  
        if (e == null) {  
            log.info("[{}] {}{} time={}ms", traceId.getId(),  
                    addSpace(COMPLETE_PREFIX, traceId.getLevel()), status.getMessage(),  
                    resultTimeMs);  
        } else {  
            log.info("[{}] {}{} time={}ms ex={}", traceId.getId(),  
                    addSpace(EX_PREFIX, traceId.getLevel()), status.getMessage(), resultTimeMs,  
                    e.toString());  
        }  
  
        releaseTraceId();  
    }  
  
  
    private static String addSpace(String prefix, int level) {  
        StringBuilder sb = new StringBuilder();  
        for (int i = 0; i < level; i++) {  
            sb.append((i == level - 1) ? "|" + prefix : "| ");  
        }  
        return sb.toString();  
    }  
}
```

`FieldLogTrace`는 기존에 만들었던 `HelloTraceV2`와 거의 같은 기능을 한다. `TraceId`를 동기화 하는 부분만 파라미터를 사용하는 것에서 `TraceId traceIdHolder` 필드를 사용하도록 변경되었다.

이제 직전 로그의 `traceId`는 파라미터로 전달되는 것이 아니라 `FieldLogTrace`의 필드인 `traceIdHolder`에 저장된다.

```java
class FieldLogTraceTest {  
    FieldLogTrace trace = new FieldLogTrace();  
  
    @Test  
    void begin_end_level2() {  
        TraceStatus status1 = trace.begin("hello1");  
        TraceStatus status2 = trace.begin("hello2");  
        trace.end(status2);  
        trace.end(status1);  
    }

	@Test  
	void begin_exception_level2() {  
	    TraceStatus status1 = trace.begin("hello1");  
	    TraceStatus status2 = trace.begin("hello2");  
	    trace.exception(status2, new IllegalStateException());  
	    trace.exception(status1, new IllegalStateException());  
	}
}
```

테스트를 실행해보면 다음과 같은 로그를 출력한다.

```
begin_end_level2() 호출
01:27:25.759 [main] INFO hello.advanced.trace.logtrace.FieldLogTrace -- [463b3b8d] hello1
01:27:25.761 [main] INFO hello.advanced.trace.logtrace.FieldLogTrace -- [463b3b8d] |-->hello2
01:27:25.761 [main] INFO hello.advanced.trace.logtrace.FieldLogTrace -- [463b3b8d] |<--hello2 time=0ms
01:27:25.761 [main] INFO hello.advanced.trace.logtrace.FieldLogTrace -- [463b3b8d] hello1 time=3ms

begin_exception_level2() 호출
01:27:25.768 [main] INFO hello.advanced.trace.logtrace.FieldLogTrace -- [8ab06286] hello1
01:27:25.768 [main] INFO hello.advanced.trace.logtrace.FieldLogTrace -- [8ab06286] |-->hello2
01:27:25.768 [main] INFO hello.advanced.trace.logtrace.FieldLogTrace -- [8ab06286] |<X-hello2 time=0ms ex=java.lang.IllegalStateException
01:27:25.768 [main] INFO hello.advanced.trace.logtrace.FieldLogTrace -- [8ab06286] hello1 time=0ms ex=java.lang.IllegalStateException
```

이제 불필요하게 `TraceId`를 파라미터로 전달하지 않아도 되고, 어플리케이션의 메서드 파라미터도 변경하지 않아도 된다.

## 필드 동기화 - 적용

다양한 예제 클래스를 적용해볼 것이므로 다음과 같이 구성 클래스를 정의한다.

```java
@Configuration  
public class LogTraceConfig {  
    @Bean  
    public LogTrace logTrace() {  
        return new FieldLogTrace();  
    }  
}
```

그리고 해당 `LogTrace`를 컨트롤러, 서비스, 리포지토리에서 주입 받고 불필요한 파라미터(`TraceId`)를 제거한다. `beginSync()`도 이제 사라졌으므로 `begin()` 메서드를 호출하도록 변경한다.

```java
@RestController  
@RequiredArgsConstructor  
public class OrderControllerV3 {  
    private final OrderServiceV3 orderService;  
    private final LogTrace trace;  
  
    @GetMapping("/v3/request")  
    public String request(String itemId) {  
        TraceStatus status = null;  
  
        try {  
            status = trace.begin("OrderController.request()");  
            orderService.orderItem(itemId);  
            trace.end(status);  
            return "ok";  
        } catch (RuntimeException e) {  
            trace.exception(status, e);  
            throw e;  
        }  
    }  
}
```

브라우저에서 컨트롤러를 호출해보면 다음과 같이 로그가 의도한대로 출력된다.

```
[5b7648b5] OrderController.request()
[5b7648b5] |-->OrderService.orderItem()
[5b7648b5] | |-->OrderRepository.save()
[5b7648b5] | |<--OrderRepository.save() time=1005ms
[5b7648b5] |<--OrderService.orderItem() time=1006ms
[5b7648b5] OrderController.request() time=1008ms
```

이 `traceIdHolder` 필드를 사용한 동기화 덕분에 파라미터 추가 없는 깔끔한 로그 추적기를 완성했다. 그런데 이런 클래스를 실제 서비스에 배포하면 무슨 일이 발생할까? 바로 **동시성 문제**가 발생한다.

## 필드 동기화 - 동시성 문제
앞서 만든 로그 추적기를 실제 서비스에 배포했다 가정해보자. 테스트 할 때는 문제가 없는 것 처럼 보인다. 그런데 `FieldLogTrace`는 심각한 동시성 문제를 가지고 있다. 동시성 문제는 동시에 여러번 호출 되었을 때 발생하므로, 동시에 여러번 호출해보면 된다.

```
[io-8080-exec-10] h.advanced.trace.logtrace.FieldLogTrace  : [9d9cf047] OrderController.request()
[io-8080-exec-10] h.advanced.trace.logtrace.FieldLogTrace  : [9d9cf047] |-->OrderService.orderItem()
[io-8080-exec-10] h.advanced.trace.logtrace.FieldLogTrace  : [9d9cf047] | |-->OrderRepository.save()
[nio-8080-exec-1] h.advanced.trace.logtrace.FieldLogTrace  : [9d9cf047] | | |-->OrderController.request()
[nio-8080-exec-1] h.advanced.trace.logtrace.FieldLogTrace  : [9d9cf047] | | | |-->OrderService.orderItem()
[nio-8080-exec-1] h.advanced.trace.logtrace.FieldLogTrace  : [9d9cf047] | | | | |-->OrderRepository.save()
[io-8080-exec-10] h.advanced.trace.logtrace.FieldLogTrace  : [9d9cf047] | |<--OrderRepository.save() time=1004ms
[io-8080-exec-10] h.advanced.trace.logtrace.FieldLogTrace  : [9d9cf047] |<--OrderService.orderItem() time=1004ms
[io-8080-exec-10] h.advanced.trace.logtrace.FieldLogTrace  : [9d9cf047] OrderController.request() time=1005ms
[nio-8080-exec-1] h.advanced.trace.logtrace.FieldLogTrace  : [9d9cf047] | | | | |<--OrderRepository.save() time=1005ms
[nio-8080-exec-1] h.advanced.trace.logtrace.FieldLogTrace  : [9d9cf047] | | | |<--OrderService.orderItem() time=1006ms
[nio-8080-exec-1] h.advanced.trace.logtrace.FieldLogTrace  : [9d9cf047] | | |<--OrderController.request() time=1007ms
```

로그를 살펴보면 `level`도 이상하고, `트랜잭션 ID`도 이상하다. 기대하는 결과와 다르다. `[nio-8080-exec-1]`는 톰캣에서 할당한 쓰레드 이름인데 요청을 살펴보면 동시 요청 했을 때 다른 쓰레드가 할당 됐지만 같은 `트랜잭션 ID`로 처리된 것을 볼 수 있다.

**nio-8080-exec-1**
- nio: `Non-blocking I/O`를 의미
	- 스프링 부트는 기본적으로 톰캣을 내장 웹서버로 사용하며, NIO 기반의 멀티스레드 모델을 사용한다.
- 8080: 어플리케이션이 사용하는 포트 번호
- exec-1: 스레드 풀에서 실행중인 작업 스레드의 번호이다.

#### 동시성 문제


---
References: 김영한의 스프링 핵심 원리 - 고급편

Links to this page: [[1. 로그 추적기]]