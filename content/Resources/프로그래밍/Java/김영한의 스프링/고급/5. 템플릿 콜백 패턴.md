---
title: 
tags:
  - java
  - programming
  - design-pattern
  - template-callback-pattern
  - strategy-pattern
publish: true
date: 2024-12-31
---
## 템플릿 콜백 패턴 - 시작
`ContextV2`는 변하지 않는 템플릿 역할을 했다. 그리고 변하는 부분은 파라미터로 넘어온 `Strategy`의 코드를 실행해서 처리한다. 이렇게 다른 코드의 인수로서 넘겨주는 실행 가능한 코드를 콜백(Callback)이라 한다.

#### 자바 언어에서 콜백 
- 자바 언어에서 실행 가능한 코드를 인수로 넘기려면 객체가 필요하다. 자바 8부터는 람다를 사용할 수 있다.
- 자바 8 이전에는 보통 하나의 메소드를 가진 인터페이스를 구현하고, 주로 익명 내부 클래스를 사용했다.
- 최근에는 주로 람다를 사용한다.

앞서 만들었던 `ContextV2`가 전략 패턴 중 하나인 템플릿 콜백 패턴이다. 
```java
public interface Callback {  
    void call();  
}
```

```java
@Slf4j  
public class TimeLogTemplate {  
  
    public void execute(Callback callback) {  
        long startTime = System.currentTimeMillis();  
  
        callback.call();  
  
        long endTime = System.currentTimeMillis();  
        long resultTime = endTime - startTime;  
        log.info("resultTime = {}ms", resultTime);  
    }  
}
```

동일한 구조를 가지므로 이해하는데 어렵지는 않다.

```java
@Slf4j  
public class TemplateCallbackTest {
	/**  
	 * 템플릿 콜백 패턴 - 람다  
	 */  
	@Test  
	void callbackV2() {  
	    TimeLogTemplate template = new TimeLogTemplate();  
	  
	    template.execute(() -> log.info("비즈니스 로직1 실행"));  
	    template.execute(() -> log.info("비즈니스 로직2 실행"));  
	}
	
    /**  
     * 템플릿 콜백 패턴 - 익명 내부 클래스  
     */  
    @Test  
    void callbackV1() {  
        TimeLogTemplate template = new TimeLogTemplate();  
  
        template.execute(new Callback() {  
            @Override  
            public void call() {  
                log.info("비즈니스 로직1 실행");  
            }  
        });  
  
        template.execute(new Callback() {  
            @Override  
            public void call() {  
                log.info("비즈니스 로직2 실행");  
            }  
        });  
    }  
}
```

별도의 클래스를 만들어서 전달해도 되지만, 콜백을 사용할 경우 익명 내부 클래스나 람다를 사용하는 것이 편리하다. 물론 여러곳에서 함께 사용되는 경우 재사용을 위해 콜백을 별도의 클래스로 만들어도 된다.

## 템플릿 콜백 패턴 - 적용

```java
public interface TraceCallback<T> {  
    T call();  
}
```

콜백을 호출하는 함수마다 반환 타입이 다르므로 제네릭 클래스로 선언했다.

```java
public class TraceTemplate {  
    private final LogTrace trace;  
  
    public TraceTemplate(LogTrace trace) {  
        this.trace = trace;  
    }  
  
    public <T> T execute(String message, TraceCallback<T> callback) {  
        TraceStatus status = null;  
  
        try {  
            status = trace.begin(message);  
  
            T result = callback.call();  
  
            trace.end(status);  
            return result;  
        } catch (Exception e) {  
            trace.exception(status, e);  
            throw e;  
        }  
    }  
}
```

`TraceTemplate`은 생성자 주입으로 `LogTrace trace`를 주입받고, 내부에서 사용한다. 전략은 `execute` 실행 시 파라미터로 전달받은 `callback`에 의해 변경된다.


```java
@RestController  
public class OrderControllerV5 {  
    private final OrderServiceV5 orderService;  
    private final TraceTemplate template;  
  
    public OrderControllerV5(OrderServiceV5 orderService, LogTrace trace) {  
        this.orderService = orderService;  
        this.template = new TraceTemplate(trace);  
    }  
  
    @GetMapping("/v5/request")  
    public String request(String itemId) {  
        return template.execute("OrderController.request()", new TraceCallback<String>() {  
            @Override  
            public String call() {  
                orderService.orderItem(itemId);  
                return "ok";  
            }  
        });  
    }  
}
```

스프링 컨테이너를 이용해 의존성 주입을 받는데, 먼저 템플릿을 필드에 선언하고 컨트롤러 생성자 호출 시점에 `LogTrace trace`를 주입 받아 템플릿을 생성한다. 이렇게 하지 않으면 컨트롤러 내부의 메서드마다 템플릿을 선언해주어야 하기 때문에 번거롭다.

그리고 결정적으로 `template.execute()`의 실행 시점에 `TraceCallback`을 전달해서 실행한다. 여기서는 익명 내부 클래스를 사용해서 전달했다.

```java
@Service  
public class OrderServiceV5 {  
    private final OrderRepositoryV5 orderRepository;  
    private final TraceTemplate template;  
  
    public OrderServiceV5(LogTrace trace, OrderRepositoryV5 orderRepository) {  
        this.template = new TraceTemplate(trace);  
        this.orderRepository = orderRepository;  
    }  
  
    public void orderItem(String itemId) {  
        template.execute("OrderService.orderItem()", () -> {  
            orderRepository.save(itemId);  
            return null;  
        });  
    }  
}
```

```java

```


---
References: 김영한의 스프링 핵심 원리 - 고급편

Links to this page: 