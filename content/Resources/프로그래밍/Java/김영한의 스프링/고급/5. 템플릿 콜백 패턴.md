---
title: 
tags:
  - java
  - programming
  - design-pattern
  - template-callback-pattern
publish: true
date: 2024-12-31
---
## 템플릿 콜백 패턴 - 시작
`ContextV2`는 변하지 않는 템플릿 역할을 했다. 그리고 변하는 부분은 파라미터로 넘어온 `Strategy`의 코드를 실행해서 처리한다. 이렇게 다른 코드의 인수로서 넘겨주는 실행 가능한 코드를 콜백(Callback)이라 한다.

#### 자바 언어에서 콜백 
- 자바 언어에서 실행 가능한 코드를 인수로 넘기려면 객체가 필요하다. 자바 8부터는 람다를 사용할 수 있다.
- 자바 8 이전에는 보통 하나의 메소드를 가진 인터페이스를 구현하고, 주로 익명 내부 클래스를 사용했다.
- 최근에는 주로 람다를 사용한다.

앞서 만들었던 `ContextV2`가 전략 패턴이면서, 템플릿 콜백 패턴이다. 
```java
public interface Callback {  
    void call();  
}
```

```java
@Slf4j  
public class TimeLogTemplate {  
  
    public void execute(Callback callback) {  
        long startTime = System.currentTimeMillis();  
  
        callback.call();  
  
        long endTime = System.currentTimeMillis();  
        long resultTime = endTime - startTime;  
        log.info("resultTime = {}ms", resultTime);  
    }  
}
```

동일한 구조를 가지므로 이해하는데 어렵지는 않다.

```java
@Slf4j  
public class TemplateCallbackTest {
	/**  
	 * 템플릿 콜백 패턴 - 람다  
	 */  
	@Test  
	void callbackV2() {  
	    TimeLogTemplate template = new TimeLogTemplate();  
	  
	    template.execute(() -> log.info("비즈니스 로직1 실행"));  
	    template.execute(() -> log.info("비즈니스 로직2 실행"));  
	}
	
    /**  
     * 템플릿 콜백 패턴 - 익명 내부 클래스  
     */  
    @Test  
    void callbackV1() {  
        TimeLogTemplate template = new TimeLogTemplate();  
  
        template.execute(new Callback() {  
            @Override  
            public void call() {  
                log.info("비즈니스 로직1 실행");  
            }  
        });  
  
        template.execute(new Callback() {  
            @Override  
            public void call() {  
                log.info("비즈니스 로직2 실행");  
            }  
        });  
    }  
}
```

별도의 클래스를 만들어서 전달해도 되지만, 콜백을 사용할 경우 익명 내부 클래스나 람다를 사용하는 것이 편리하다. 물론 여러곳에서 함께 사용되는 경우 재사용을 위해 콜백을 별도의 클래스로 만들어도 된다.

---
References: 김영한의 스프링 핵심 원리 - 고급편

Links to this page: 