{
	"nodes":[
		{"id":"2ddbbd91273dc543","type":"text","text":"# 쓰레드 로컬 (ThreadLocal)","x":-141,"y":-156,"width":333,"height":60,"color":"1"},
		{"id":"ae8b939d1ecd84e0","type":"text","text":"#### 동시성 문제\n공유되는 자원을 여러 쓰레드에서 변경할 때 발생하는 문제이다.\n\n스프링에선 기본적으로 빈을 등록할 때 싱글톤 객체로 등록한다.\n\n그런데 동시성 문제는 이런 싱글톤 객체(스프링 컨테이너 내의 공유자원)의 필드에 값을 여러 쓰레드에서 변경하는 경우에 발생한다.","x":70,"y":-540,"width":500,"height":201},
		{"id":"e6e62da491384197","type":"text","text":"#### 사용법\n`ThreadLocal`은 제네릭 클래스이다. 따라서 다음과 같이\b 사용한다.\n\n- `ThreadLocal<String> declare`\n\n**값을 저장할 때**\n- `ThreadLocal.set()`\n\n**값을 가져올 때**\n- `ThreadLocal.get()`\n\n**값을 제거할 때**\n- `ThreadLocal.remove()`\n","x":-220,"y":280,"width":349,"height":419},
		{"id":"9892c8535c4ea578","type":"text","text":"#### 쓰레드 로컬이란?\n쓰레드 로컬은 해당 쓰레드만 접근할 수 있는 특별한 저장소를 말한다. \n\n쉽게 이야기해서 물건 보관 창구를 떠올리면 된다. \n\n여러 사람이 같은 물건 보관 창구를 사용하더라도 창구 직원은 사용자를 인식해서 사용자별로 확실하게 물건을 구분해준다.\n\n그래서 `사용자 A`, `사용자 B` 모두 창구 직원을 통해서 물건을 보관하고 꺼내지만 창고 직원이 사용자에 따라 보관한 물건을 구분해주는 것이다.","x":420,"y":-240,"width":400,"height":350},
		{"id":"0432d1ec40bfd068","x":-780,"y":-339,"width":383,"height":287,"color":"2","type":"text","text":"#### 사용이 끝나면 반드시 값 제거\n쓰레드에서 `ThreadLocal`을 모두 사용하고 나면 반드시 `ThreadLocal.remove()`를 호출해서 쓰레드에 저장된 값을 제거해야한다.\n\n멀티 쓰레드 환경에서는 쓰레드 풀을 사용해서 사용한 쓰레드를 다시 쓰레드 풀에 반납하고 재사용한다.\n\n따라서 사용이 끝난 쓰레드에 저장된 값을 제거하지 않으면 남아있을 수 있다.\n"}
	],
	"edges":[
		{"id":"d423df8fff59af00","fromNode":"2ddbbd91273dc543","fromSide":"top","toNode":"ae8b939d1ecd84e0","toSide":"left"},
		{"id":"29bd1a62240fe43a","fromNode":"2ddbbd91273dc543","fromSide":"right","toNode":"9892c8535c4ea578","toSide":"left"},
		{"id":"fe49c47391ed15bd","fromNode":"2ddbbd91273dc543","fromSide":"bottom","toNode":"e6e62da491384197","toSide":"top"},
		{"id":"58114023b97d76df","fromNode":"2ddbbd91273dc543","fromSide":"left","toNode":"0432d1ec40bfd068","toSide":"right"}
	]
}