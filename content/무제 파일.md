해시 충돌을 완벽하게 해결 할 수 있는 방법은 없다. 단순히 생각해봐도 100개의 요소를 10개의 배열에 충돌 없이 집어 넣는다는 것은 불가능하다.

다만 해시 충돌의 영향을 최소화하고 효과적으로 관리하는 방법이 있을 뿐이다. 다음은 단순하게 충돌이 발생하면 같은 해시 인덱스에 저장해버리는 것이다.

![[해시-충돌-해결-1.png]]
충돌이 일어나면 배열 내부에 배열이나 다른 자료구조를 생성해서, 저장하는 것이다.

### 해시 충돌과 조회
해시 충돌이 난 경우 내부의 데이터를 하나씩 비교해보면 원하는 결과를 찾을 수 있다. 

해시 충돌 시 해시 인덱스에 배열을 넣고 그 내부에 데이터들을 저장했다고 가정하면 그 배열을 전체 순회하며 일치하는 값을 찾는 것이다.

![[해시-충돌-해결-2.png]]

### 최악의 경우
![[해시-충돌-최악의경우.png]]
해시 알고리즘의 최악의 경우는 입력 값이 모두 같은 해시 인덱스일 때 발생한다.

따라서 모든 데이터가 9번 인덱스에 저장되고 결국 데이터를 조회할 때 9번 인덱스에 저장된 `n`개의 데이터 갯수만큼 값을 반복해서 비교해야 한다.

따라서 최악의 경우 조회 성능이 `O(n)`의 성능을 보인다.

> [!note] 정리
> 해시 인덱스를 사용하는 방식은 최악의 경우 조회 성능이 `O(n)`의 성능을 보인다.
> 
> 하지만 확률적으로 보면 어느 정도 넓게 퍼지기 때문에 평균으로 보면 대부분 `O(1)`의 성능을 제공한다. 해시 충돌이 가끔 발생해도 내부에서 값을 몇 번만 비교하는 수준이기 때문에 대부분의 경우 매우 빠르게 값을 찾을 수 있다.

> [!note] 참고
> 해시 충돌의 해결 방법을 찾아보니, 강의에서 설명한 해시 충돌 해결 방법은 `Chaining`과 유사한 방식이다. `Chaining`은 연결 리스트를 활용하여 충돌이 일어난 값들을 연결하는 방식을 취한다.
> 
> 그 외에 `Open Addressing`이라는 방식도 있는데, 이는 해시 함수로 얻은 주소가 아닌 다른 주소 공간에 데이터를 저장하는 방식이라고 한다.